/**
 * Precisely APIs
 * Enhance & enrich your data, applications, business processes, and workflows with rich location, information, and identify APIs.
 *
 * The version of the OpenAPI document: 12.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { CrimeRiskByAddressBatchRequest } from '../model/crimeRiskByAddressBatchRequest';
import { CrimeRiskByLocationBatchRequest } from '../model/crimeRiskByLocationBatchRequest';
import { CrimeRiskResponse } from '../model/crimeRiskResponse';
import { CrimeRiskResponseList } from '../model/crimeRiskResponseList';
import { DistanceToFloodHazardAddressRequest } from '../model/distanceToFloodHazardAddressRequest';
import { DistanceToFloodHazardLocationRequest } from '../model/distanceToFloodHazardLocationRequest';
import { DistanceToFloodHazardResponse } from '../model/distanceToFloodHazardResponse';
import { EarthquakeHistory } from '../model/earthquakeHistory';
import { EarthquakeRiskByAddressRequest } from '../model/earthquakeRiskByAddressRequest';
import { EarthquakeRiskByLocationRequest } from '../model/earthquakeRiskByLocationRequest';
import { EarthquakeRiskResponse } from '../model/earthquakeRiskResponse';
import { EarthquakeRiskResponseList } from '../model/earthquakeRiskResponseList';
import { ErrorInfo } from '../model/errorInfo';
import { FireHistory } from '../model/fireHistory';
import { FireRiskByAddressRequest } from '../model/fireRiskByAddressRequest';
import { FireRiskByLocationRequest } from '../model/fireRiskByLocationRequest';
import { FireRiskResponse } from '../model/fireRiskResponse';
import { FireRiskResponseList } from '../model/fireRiskResponseList';
import { FireStations } from '../model/fireStations';
import { FloodRiskByAddressRequest } from '../model/floodRiskByAddressRequest';
import { FloodRiskByLocationRequest } from '../model/floodRiskByLocationRequest';
import { FloodRiskResponse } from '../model/floodRiskResponse';
import { FloodRiskResponseList } from '../model/floodRiskResponseList';
import { WaterBodyResponse } from '../model/waterBodyResponse';

import { ObjectSerializer, Authentication, Interceptor } from '../model/models';
import { OAuth,oAuthCredInfo } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.precisely.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum RisksServiceApiApiKeys {
}

export class RisksServiceApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
	protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

	protected interceptors: Interceptor[] = [];
    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this._basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: RisksServiceApiApiKeys, value: string) {
        this.authentications[RisksServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Accepts addresses as input and Returns local crime indexes.
     * @summary Get Crime Risk By Address
     * @param address free form address text
     * @param type this is crime type; valid values are following 11 crime types with \&#39;all\&#39; as default (more than one can also be given as comma separated types)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response
     */
    public async getCrimeRiskByAddress (address: string, type?: string, includeGeometry?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CrimeRiskResponse;  }> {
        const localVarPath = this._basePath + '/risks/v1/crime/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling getCrimeRiskByAddress.');
        }

        if (address !== undefined) {
            localVarQueryParameters['address'] = ObjectSerializer.serialize(address, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (includeGeometry !== undefined) {
            localVarQueryParameters['includeGeometry'] = ObjectSerializer.serialize(includeGeometry, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: CrimeRiskResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This is a Batch offering for \'Crime Risk By Address\' service. It accepts a single address or a list of addresses and retrieve local crime indexes.
     * @summary Post Crime Risk By Address
     * @param crimeRiskByAddressBatchRequest 
     */
    public async getCrimeRiskByAddressBatch (crimeRiskByAddressBatchRequest: CrimeRiskByAddressBatchRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CrimeRiskResponseList;  }> {
        const localVarPath = this._basePath + '/risks/v1/crime/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'crimeRiskByAddressBatchRequest' is not null or undefined
        if (crimeRiskByAddressBatchRequest === null || crimeRiskByAddressBatchRequest === undefined) {
            throw new Error('Required parameter crimeRiskByAddressBatchRequest was null or undefined when calling getCrimeRiskByAddressBatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(crimeRiskByAddressBatchRequest, "CrimeRiskByAddressBatchRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: CrimeRiskResponseList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Accepts latitude/longitude as input and returns and Returns local crime indexes.
     * @summary Get Crime Risk By  Location
     * @param longitude The longitude of the location
     * @param latitude The latitude of the location
     * @param type this is crime type; valid values are following 11 crime types with \&#39;all\&#39; as default (more than one can also be given as comma separated types)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response
     */
    public async getCrimeRiskByLocation (longitude: string, latitude: string, type?: string, includeGeometry?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CrimeRiskResponse;  }> {
        const localVarPath = this._basePath + '/risks/v1/crime/bylocation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
            throw new Error('Required parameter longitude was null or undefined when calling getCrimeRiskByLocation.');
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
            throw new Error('Required parameter latitude was null or undefined when calling getCrimeRiskByLocation.');
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (includeGeometry !== undefined) {
            localVarQueryParameters['includeGeometry'] = ObjectSerializer.serialize(includeGeometry, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: CrimeRiskResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This is a Batch offering for \'Crime Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve local crime indexes.
     * @summary Post Crime Risk By Location
     * @param crimeRiskByLocationBatchRequest 
     */
    public async getCrimeRiskByLocationBatch (crimeRiskByLocationBatchRequest: CrimeRiskByLocationBatchRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CrimeRiskResponseList;  }> {
        const localVarPath = this._basePath + '/risks/v1/crime/bylocation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'crimeRiskByLocationBatchRequest' is not null or undefined
        if (crimeRiskByLocationBatchRequest === null || crimeRiskByLocationBatchRequest === undefined) {
            throw new Error('Required parameter crimeRiskByLocationBatchRequest was null or undefined when calling getCrimeRiskByLocationBatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(crimeRiskByLocationBatchRequest, "CrimeRiskByLocationBatchRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: CrimeRiskResponseList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Accepts addresses as input and Returns the distance from nearest water bodies along with body name and location.
     * @summary Get Distance To Flood Hazard By Address
     * @param address The address of the location
     * @param maxCandidates This specifies the value of maxCandidates
     * @param waterBodyType This specifies the value of waterBodyType
     * @param searchDistance This specifies the search distance
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters
     */
    public async getDistanceToCoastByAddress (address?: string, maxCandidates?: string, waterBodyType?: string, searchDistance?: string, searchDistanceUnit?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: WaterBodyResponse;  }> {
        const localVarPath = this._basePath + '/risks/v1/shoreline/distancetofloodhazard/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (address !== undefined) {
            localVarQueryParameters['address'] = ObjectSerializer.serialize(address, "string");
        }

        if (maxCandidates !== undefined) {
            localVarQueryParameters['maxCandidates'] = ObjectSerializer.serialize(maxCandidates, "string");
        }

        if (waterBodyType !== undefined) {
            localVarQueryParameters['waterBodyType'] = ObjectSerializer.serialize(waterBodyType, "string");
        }

        if (searchDistance !== undefined) {
            localVarQueryParameters['searchDistance'] = ObjectSerializer.serialize(searchDistance, "string");
        }

        if (searchDistanceUnit !== undefined) {
            localVarQueryParameters['searchDistanceUnit'] = ObjectSerializer.serialize(searchDistanceUnit, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: WaterBodyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This is a Batch offering for \'Distance To Flood Hazard By Address\' service. It accepts a single address or a list of addresses and retrieve the distance from nearest water bodies along with body name and location.
     * @summary Post Distance To Flood Hazard By Address
     * @param distanceToFloodHazardAddressRequest 
     */
    public async getDistanceToCoastByAddressBatch (distanceToFloodHazardAddressRequest: DistanceToFloodHazardAddressRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DistanceToFloodHazardResponse;  }> {
        const localVarPath = this._basePath + '/risks/v1/shoreline/distancetofloodhazard/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'distanceToFloodHazardAddressRequest' is not null or undefined
        if (distanceToFloodHazardAddressRequest === null || distanceToFloodHazardAddressRequest === undefined) {
            throw new Error('Required parameter distanceToFloodHazardAddressRequest was null or undefined when calling getDistanceToCoastByAddressBatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(distanceToFloodHazardAddressRequest, "DistanceToFloodHazardAddressRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: DistanceToFloodHazardResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Accepts latitude & longitude as input and Returns the distance from nearest water bodies along with body name and location.
     * @summary Get Distance To Flood Hazard By Location
     * @param longitude The longitude of the location
     * @param latitude The latitude of the location
     * @param maxCandidates This specifies the value of maxCandidates
     * @param waterBodyType This specifies the value of waterBodyType
     * @param searchDistance This specifies the search distance
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters
     */
    public async getDistanceToCoastByLocation (longitude?: string, latitude?: string, maxCandidates?: string, waterBodyType?: string, searchDistance?: string, searchDistanceUnit?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: WaterBodyResponse;  }> {
        const localVarPath = this._basePath + '/risks/v1/shoreline/distancetofloodhazard/bylocation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "string");
        }

        if (maxCandidates !== undefined) {
            localVarQueryParameters['maxCandidates'] = ObjectSerializer.serialize(maxCandidates, "string");
        }

        if (waterBodyType !== undefined) {
            localVarQueryParameters['waterBodyType'] = ObjectSerializer.serialize(waterBodyType, "string");
        }

        if (searchDistance !== undefined) {
            localVarQueryParameters['searchDistance'] = ObjectSerializer.serialize(searchDistance, "string");
        }

        if (searchDistanceUnit !== undefined) {
            localVarQueryParameters['searchDistanceUnit'] = ObjectSerializer.serialize(searchDistanceUnit, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: WaterBodyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This is a Batch offering for \'Distance To Flood Hazard By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve the distance from nearest water bodies along with body name and location.
     * @summary Post Distance To Flood Hazard By Location
     * @param distanceToFloodHazardLocationRequest 
     */
    public async getDistanceToCoastByLocationBatch (distanceToFloodHazardLocationRequest: DistanceToFloodHazardLocationRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DistanceToFloodHazardResponse;  }> {
        const localVarPath = this._basePath + '/risks/v1/shoreline/distancetofloodhazard/bylocation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'distanceToFloodHazardLocationRequest' is not null or undefined
        if (distanceToFloodHazardLocationRequest === null || distanceToFloodHazardLocationRequest === undefined) {
            throw new Error('Required parameter distanceToFloodHazardLocationRequest was null or undefined when calling getDistanceToCoastByLocationBatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(distanceToFloodHazardLocationRequest, "DistanceToFloodHazardLocationRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: DistanceToFloodHazardResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Accepts postcode as input and Returns historical earthquake details for a particular postcode.
     * @summary Earthquake History
     * @param postCode 5 digit Postal code to search
     * @param startDate Start time in milliseconds(UTC)
     * @param endDate End time in milliseconds(UTC)
     * @param minMagnitude Minimum richter scale magnitude
     * @param maxMagnitude Maximum Richter scale magnitude
     * @param maxCandidates Maximum response events
     */
    public async getEarthquakeHistory (postCode: string, startDate?: string, endDate?: string, minMagnitude?: string, maxMagnitude?: string, maxCandidates?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: EarthquakeHistory;  }> {
        const localVarPath = this._basePath + '/risks/v1/earthquakehistory';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'postCode' is not null or undefined
        if (postCode === null || postCode === undefined) {
            throw new Error('Required parameter postCode was null or undefined when calling getEarthquakeHistory.');
        }

        if (postCode !== undefined) {
            localVarQueryParameters['postCode'] = ObjectSerializer.serialize(postCode, "string");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (minMagnitude !== undefined) {
            localVarQueryParameters['minMagnitude'] = ObjectSerializer.serialize(minMagnitude, "string");
        }

        if (maxMagnitude !== undefined) {
            localVarQueryParameters['maxMagnitude'] = ObjectSerializer.serialize(maxMagnitude, "string");
        }

        if (maxCandidates !== undefined) {
            localVarQueryParameters['maxCandidates'] = ObjectSerializer.serialize(maxCandidates, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: EarthquakeHistory;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Accepts addresses as input and Returns counts of earthquakes for various richter measurements and values.
     * @summary Get Earthquake Risk By Address
     * @param address free form address text
     * @param richterValue all (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response
     */
    public async getEarthquakeRiskByAddress (address: string, richterValue?: string, includeGeometry?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: EarthquakeRiskResponse;  }> {
        const localVarPath = this._basePath + '/risks/v1/earthquake/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling getEarthquakeRiskByAddress.');
        }

        if (address !== undefined) {
            localVarQueryParameters['address'] = ObjectSerializer.serialize(address, "string");
        }

        if (richterValue !== undefined) {
            localVarQueryParameters['richterValue'] = ObjectSerializer.serialize(richterValue, "string");
        }

        if (includeGeometry !== undefined) {
            localVarQueryParameters['includeGeometry'] = ObjectSerializer.serialize(includeGeometry, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: EarthquakeRiskResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This is a Batch offering for \'Earthquake Risk By Address\' service. It accepts a single address or a list of addresses and retrieve counts of earthquakes for various richter measurements and values.
     * @summary Post Earthquake Risk By Address
     * @param earthquakeRiskByAddressRequest 
     */
    public async getEarthquakeRiskByAddressBatch (earthquakeRiskByAddressRequest: EarthquakeRiskByAddressRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: EarthquakeRiskResponseList;  }> {
        const localVarPath = this._basePath + '/risks/v1/earthquake/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'earthquakeRiskByAddressRequest' is not null or undefined
        if (earthquakeRiskByAddressRequest === null || earthquakeRiskByAddressRequest === undefined) {
            throw new Error('Required parameter earthquakeRiskByAddressRequest was null or undefined when calling getEarthquakeRiskByAddressBatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(earthquakeRiskByAddressRequest, "EarthquakeRiskByAddressRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: EarthquakeRiskResponseList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Accepts latitude & longitude as input and Returns counts of earthquakes for various richter measurements and values.
     * @summary Get Earthquake Risk By Location
     * @param longitude The longitude of the location
     * @param latitude The latitude of the location
     * @param richterValue all (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response
     */
    public async getEarthquakeRiskByLocation (longitude: string, latitude: string, richterValue?: string, includeGeometry?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: EarthquakeRiskResponse;  }> {
        const localVarPath = this._basePath + '/risks/v1/earthquake/bylocation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
            throw new Error('Required parameter longitude was null or undefined when calling getEarthquakeRiskByLocation.');
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
            throw new Error('Required parameter latitude was null or undefined when calling getEarthquakeRiskByLocation.');
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "string");
        }

        if (richterValue !== undefined) {
            localVarQueryParameters['richterValue'] = ObjectSerializer.serialize(richterValue, "string");
        }

        if (includeGeometry !== undefined) {
            localVarQueryParameters['includeGeometry'] = ObjectSerializer.serialize(includeGeometry, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: EarthquakeRiskResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This is a Batch offering for \'Earthquake Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve counts of earthquakes for various richter measurements and values.
     * @summary Post Earthquake Risk By Location
     * @param earthquakeRiskByLocationRequest 
     */
    public async getEarthquakeRiskByLocationBatch (earthquakeRiskByLocationRequest: EarthquakeRiskByLocationRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: EarthquakeRiskResponseList;  }> {
        const localVarPath = this._basePath + '/risks/v1/earthquake/bylocation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'earthquakeRiskByLocationRequest' is not null or undefined
        if (earthquakeRiskByLocationRequest === null || earthquakeRiskByLocationRequest === undefined) {
            throw new Error('Required parameter earthquakeRiskByLocationRequest was null or undefined when calling getEarthquakeRiskByLocationBatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(earthquakeRiskByLocationRequest, "EarthquakeRiskByLocationRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: EarthquakeRiskResponseList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Accepts postcode as input and Returns fire event details for a particular postcode.
     * @summary Get Fire History
     * @param postCode 5 digit Postal code to search
     * @param startDate Start time in milliseconds(UTC)
     * @param endDate End time in milliseconds(UTC)
     * @param maxCandidates Maximum response events
     */
    public async getFireHistory (postCode: string, startDate?: string, endDate?: string, maxCandidates?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FireHistory;  }> {
        const localVarPath = this._basePath + '/risks/v1/firehistory';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'postCode' is not null or undefined
        if (postCode === null || postCode === undefined) {
            throw new Error('Required parameter postCode was null or undefined when calling getFireHistory.');
        }

        if (postCode !== undefined) {
            localVarQueryParameters['postCode'] = ObjectSerializer.serialize(postCode, "string");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (maxCandidates !== undefined) {
            localVarQueryParameters['maxCandidates'] = ObjectSerializer.serialize(maxCandidates, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireHistory;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Accepts addresses as input and Returns fire risk data by risk types.
     * @summary Get Fire Risk By Address
     * @param address Free form address text
     * @param includeGeometry Flag to return Geometry default is N
     */
    public async getFireRiskByAddress (address: string, includeGeometry?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FireRiskResponse;  }> {
        const localVarPath = this._basePath + '/risks/v1/fire/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling getFireRiskByAddress.');
        }

        if (address !== undefined) {
            localVarQueryParameters['address'] = ObjectSerializer.serialize(address, "string");
        }

        if (includeGeometry !== undefined) {
            localVarQueryParameters['includeGeometry'] = ObjectSerializer.serialize(includeGeometry, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireRiskResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This is a Batch offering for \'Fire Risk By Address\' service. It accepts a single address or a list of addresses and retrieve fire risk data by risk types.
     * @summary Post Fire Risk By Address
     * @param fireRiskByAddressRequest 
     */
    public async getFireRiskByAddressBatch (fireRiskByAddressRequest: FireRiskByAddressRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FireRiskResponseList;  }> {
        const localVarPath = this._basePath + '/risks/v1/fire/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'fireRiskByAddressRequest' is not null or undefined
        if (fireRiskByAddressRequest === null || fireRiskByAddressRequest === undefined) {
            throw new Error('Required parameter fireRiskByAddressRequest was null or undefined when calling getFireRiskByAddressBatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(fireRiskByAddressRequest, "FireRiskByAddressRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireRiskResponseList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Accepts latitude & longitude as input and Returns fire risk data by risk types.
     * @summary Get Fire Risk By Location
     * @param longitude Longitude of Location
     * @param latitude Latitude of Location
     * @param includeGeometry Flag to return Geometry default is N
     */
    public async getFireRiskByLocation (longitude: string, latitude: string, includeGeometry?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FireRiskResponse;  }> {
        const localVarPath = this._basePath + '/risks/v1/fire/bylocation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
            throw new Error('Required parameter longitude was null or undefined when calling getFireRiskByLocation.');
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
            throw new Error('Required parameter latitude was null or undefined when calling getFireRiskByLocation.');
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "string");
        }

        if (includeGeometry !== undefined) {
            localVarQueryParameters['includeGeometry'] = ObjectSerializer.serialize(includeGeometry, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireRiskResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This is a Batch offering for \'Fire Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve fire risk data by risk types.
     * @summary Post Fire Risk By Location
     * @param fireRiskByLocationRequest 
     */
    public async getFireRiskByLocationBatch (fireRiskByLocationRequest: FireRiskByLocationRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FireRiskResponseList;  }> {
        const localVarPath = this._basePath + '/risks/v1/fire/bylocation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'fireRiskByLocationRequest' is not null or undefined
        if (fireRiskByLocationRequest === null || fireRiskByLocationRequest === undefined) {
            throw new Error('Required parameter fireRiskByLocationRequest was null or undefined when calling getFireRiskByLocationBatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(fireRiskByLocationRequest, "FireRiskByLocationRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireRiskResponseList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Accepts addresses as input and Returns nearest fire stations.
     * @summary Get Fire Station By Address
     * @param address Free Address
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location.
     * @param travelTime Max travel time from input location to fire station. Maximum allowed is 2 hours
     * @param travelTimeUnit minutes (default), hours, seconds, milliseconds
     * @param travelDistance Max travel distance from input location to fire station. Maximum allowed is 50 miles
     * @param travelDistanceUnit Feet (default), Kilometers, Miles, Meters
     * @param sortBy time (default), distance
     * @param historicTrafficTimeBucket Historic traffic time slab
     */
    public async getFireStationByAddress (address: string, maxCandidates?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, sortBy?: string, historicTrafficTimeBucket?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FireStations;  }> {
        const localVarPath = this._basePath + '/risks/v1/firestation/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling getFireStationByAddress.');
        }

        if (address !== undefined) {
            localVarQueryParameters['address'] = ObjectSerializer.serialize(address, "string");
        }

        if (maxCandidates !== undefined) {
            localVarQueryParameters['maxCandidates'] = ObjectSerializer.serialize(maxCandidates, "string");
        }

        if (travelTime !== undefined) {
            localVarQueryParameters['travelTime'] = ObjectSerializer.serialize(travelTime, "string");
        }

        if (travelTimeUnit !== undefined) {
            localVarQueryParameters['travelTimeUnit'] = ObjectSerializer.serialize(travelTimeUnit, "string");
        }

        if (travelDistance !== undefined) {
            localVarQueryParameters['travelDistance'] = ObjectSerializer.serialize(travelDistance, "string");
        }

        if (travelDistanceUnit !== undefined) {
            localVarQueryParameters['travelDistanceUnit'] = ObjectSerializer.serialize(travelDistanceUnit, "string");
        }

        if (sortBy !== undefined) {
            localVarQueryParameters['sortBy'] = ObjectSerializer.serialize(sortBy, "string");
        }

        if (historicTrafficTimeBucket !== undefined) {
            localVarQueryParameters['historicTrafficTimeBucket'] = ObjectSerializer.serialize(historicTrafficTimeBucket, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireStations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Accepts latitude & longitude as input and Returns nearest fire stations.
     * @summary Get Fire Station By Location
     * @param longitude Longitude of Location
     * @param latitude Latitude of Location
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location.
     * @param travelTime Max travel time from input location to fire station. Maximum allowed is 2 hours
     * @param travelTimeUnit minutes (default), hours, seconds, milliseconds
     * @param travelDistance Max travel distance from input location to fire station. Maximum allowed is 50 miles
     * @param travelDistanceUnit Feet (default), Kilometers, Miles, Meters
     * @param sortBy time (default), distance
     * @param historicTrafficTimeBucket Historic traffic time slab
     */
    public async getFireStationByLocation (longitude: string, latitude: string, maxCandidates?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, sortBy?: string, historicTrafficTimeBucket?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FireStations;  }> {
        const localVarPath = this._basePath + '/risks/v1/firestation/bylocation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
            throw new Error('Required parameter longitude was null or undefined when calling getFireStationByLocation.');
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
            throw new Error('Required parameter latitude was null or undefined when calling getFireStationByLocation.');
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "string");
        }

        if (maxCandidates !== undefined) {
            localVarQueryParameters['maxCandidates'] = ObjectSerializer.serialize(maxCandidates, "string");
        }

        if (travelTime !== undefined) {
            localVarQueryParameters['travelTime'] = ObjectSerializer.serialize(travelTime, "string");
        }

        if (travelTimeUnit !== undefined) {
            localVarQueryParameters['travelTimeUnit'] = ObjectSerializer.serialize(travelTimeUnit, "string");
        }

        if (travelDistance !== undefined) {
            localVarQueryParameters['travelDistance'] = ObjectSerializer.serialize(travelDistance, "string");
        }

        if (travelDistanceUnit !== undefined) {
            localVarQueryParameters['travelDistanceUnit'] = ObjectSerializer.serialize(travelDistanceUnit, "string");
        }

        if (sortBy !== undefined) {
            localVarQueryParameters['sortBy'] = ObjectSerializer.serialize(sortBy, "string");
        }

        if (historicTrafficTimeBucket !== undefined) {
            localVarQueryParameters['historicTrafficTimeBucket'] = ObjectSerializer.serialize(historicTrafficTimeBucket, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireStations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Accepts addresses as input and Returns flood risk data for flood zones and base flood elevation values.
     * @summary Get Flood Risk By Address
     * @param address Free text Address
     * @param includeZoneDesc Flag to return zone description
     * @param includeGeometry Flag to return Geometry
     */
    public async getFloodRiskByAddress (address: string, includeZoneDesc?: string, includeGeometry?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FloodRiskResponse;  }> {
        const localVarPath = this._basePath + '/risks/v1/flood/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling getFloodRiskByAddress.');
        }

        if (address !== undefined) {
            localVarQueryParameters['address'] = ObjectSerializer.serialize(address, "string");
        }

        if (includeZoneDesc !== undefined) {
            localVarQueryParameters['includeZoneDesc'] = ObjectSerializer.serialize(includeZoneDesc, "string");
        }

        if (includeGeometry !== undefined) {
            localVarQueryParameters['includeGeometry'] = ObjectSerializer.serialize(includeGeometry, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FloodRiskResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This is a Batch offering for \'Flood Risk By Address\' service. It accepts a single address or a list of addresses and retrieve flood risk data for flood zones and base flood elevation values.
     * @summary Post Flood Risk By Address
     * @param floodRiskByAddressRequest 
     */
    public async getFloodRiskByAddressBatch (floodRiskByAddressRequest: FloodRiskByAddressRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FloodRiskResponseList;  }> {
        const localVarPath = this._basePath + '/risks/v1/flood/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'floodRiskByAddressRequest' is not null or undefined
        if (floodRiskByAddressRequest === null || floodRiskByAddressRequest === undefined) {
            throw new Error('Required parameter floodRiskByAddressRequest was null or undefined when calling getFloodRiskByAddressBatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(floodRiskByAddressRequest, "FloodRiskByAddressRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FloodRiskResponseList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Accepts latitude & longitude as input and Returns flood risk data for flood zones and base flood elevation values.
     * @summary Get Flood Risk By Location
     * @param longitude Longitude of Location
     * @param latitude Latitude of Location
     * @param includeZoneDesc Flag to return zone description
     * @param includeGeometry Flag to return Geometry
     */
    public async getFloodRiskByLocation (longitude: string, latitude: string, includeZoneDesc?: string, includeGeometry?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FloodRiskResponse;  }> {
        const localVarPath = this._basePath + '/risks/v1/flood/bylocation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
            throw new Error('Required parameter longitude was null or undefined when calling getFloodRiskByLocation.');
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
            throw new Error('Required parameter latitude was null or undefined when calling getFloodRiskByLocation.');
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "string");
        }

        if (includeZoneDesc !== undefined) {
            localVarQueryParameters['includeZoneDesc'] = ObjectSerializer.serialize(includeZoneDesc, "string");
        }

        if (includeGeometry !== undefined) {
            localVarQueryParameters['includeGeometry'] = ObjectSerializer.serialize(includeGeometry, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FloodRiskResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This is a Batch offering for \'Flood Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve flood risk data for flood zones and base flood elevation values.
     * @summary Post Flood Risk By Location
     * @param floodRiskByLocationRequest 
     */
    public async getFloodRiskByLocationBatch (floodRiskByLocationRequest: FloodRiskByLocationRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FloodRiskResponseList;  }> {
        const localVarPath = this._basePath + '/risks/v1/flood/bylocation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'floodRiskByLocationRequest' is not null or undefined
        if (floodRiskByLocationRequest === null || floodRiskByLocationRequest === undefined) {
            throw new Error('Required parameter floodRiskByLocationRequest was null or undefined when calling getFloodRiskByLocationBatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(floodRiskByLocationRequest, "FloodRiskByLocationRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FloodRiskResponseList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
