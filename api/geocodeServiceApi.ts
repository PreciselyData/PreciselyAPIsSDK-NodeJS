/**
 * Precisely APIs
 * Enhance & enrich your data, applications, business processes, and workflows with rich location, information, and identify APIs.
 *
 * The version of the OpenAPI document: 12.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { ErrorInfo } from '../model/errorInfo';
import { GeocodeRequest } from '../model/geocodeRequest';
import { GeocodeServiceResponse } from '../model/geocodeServiceResponse';
import { GeocodeServiceResponseList } from '../model/geocodeServiceResponseList';
import { KeyLookupRequest } from '../model/keyLookupRequest';
import { PBKeyAddressRequest } from '../model/pBKeyAddressRequest';
import { PBKeyResponse } from '../model/pBKeyResponse';
import { PBKeyResponseList } from '../model/pBKeyResponseList';
import { ReverseGeocodeRequest } from '../model/reverseGeocodeRequest';

import { ObjectSerializer, Authentication, Interceptor } from '../model/models';
import { OAuth,oAuthCredInfo } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.precisely.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum GeocodeServiceApiApiKeys {
}

export class GeocodeServiceApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
	protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

	protected interceptors: Interceptor[] = [];
    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this._basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: GeocodeServiceApiApiKeys, value: string) {
        this.authentications[GeocodeServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * This service accepts an address and returns the location coordinates corresponding to that address. Premium offers the best accuracy and is a high precision geocoder leveraging Master Location Data - geocodes to Street or building level. Advanced offers advanced accuracy and geocodes to Street level.Basic offering will geocode to a Place or Postal level. Good accuracy.
     * @summary Get Forward Geocode(Basic/Premium/Advanced)
     * @param datapackBundle datapackBundle
     * @param country Country name or ISO code.
     * @param mainAddress Single line input, treated as collection of field elements.
     * @param matchMode Match modes determine the leniency used to make a match between the input address and the reference data.
     * @param fallbackGeo Specifies whether to attempt to determine a geographic region centroid when an address-level geocode cannot be determined.
     * @param fallbackPostal Specifies whether to attempt to determine a post code centroid when an address-level geocode cannot be determined.
     * @param maxCands The maximum number of candidates to return.
     * @param streetOffset Indicates the offset distance from the street segments to use in street-level geocoding.
     * @param streetOffsetUnits Specifies the unit of measurement for the street offset.
     * @param cornerOffset Specifies the distance to offset the street end points in street-level matching.
     * @param cornerOffsetUnits Specifies the unit of measurement for the corner offset.
     * @param removeAccentMarks Specifies whether to Suppress accents and other diacritical marks.
     */
    public async geocode (datapackBundle: 'premium' | 'basic' | 'advanced', country?: string, mainAddress?: string, matchMode?: 'Exact' | 'Standard' | 'Relaxed' | 'Custom' | 'Interactive(USA Only)' | 'CASS(USA Only)', fallbackGeo?: string, fallbackPostal?: string, maxCands?: string, streetOffset?: string, streetOffsetUnits?: 'METERS' | 'FEET', cornerOffset?: string, cornerOffsetUnits?: 'METERS' | 'FEET', removeAccentMarks?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponse;  }> {
        const localVarPath = this._basePath + '/geocode/v1/{datapackBundle}/geocode'
            .replace('{' + 'datapackBundle' + '}', encodeURIComponent(String(datapackBundle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datapackBundle' is not null or undefined
        if (datapackBundle === null || datapackBundle === undefined) {
            throw new Error('Required parameter datapackBundle was null or undefined when calling geocode.');
        }

        if (country !== undefined) {
            localVarQueryParameters['country'] = ObjectSerializer.serialize(country, "string");
        }

        if (mainAddress !== undefined) {
            localVarQueryParameters['mainAddress'] = ObjectSerializer.serialize(mainAddress, "string");
        }

        if (matchMode !== undefined) {
            localVarQueryParameters['matchMode'] = ObjectSerializer.serialize(matchMode, "'Exact' | 'Standard' | 'Relaxed' | 'Custom' | 'Interactive(USA Only)' | 'CASS(USA Only)'");
        }

        if (fallbackGeo !== undefined) {
            localVarQueryParameters['fallbackGeo'] = ObjectSerializer.serialize(fallbackGeo, "string");
        }

        if (fallbackPostal !== undefined) {
            localVarQueryParameters['fallbackPostal'] = ObjectSerializer.serialize(fallbackPostal, "string");
        }

        if (maxCands !== undefined) {
            localVarQueryParameters['maxCands'] = ObjectSerializer.serialize(maxCands, "string");
        }

        if (streetOffset !== undefined) {
            localVarQueryParameters['streetOffset'] = ObjectSerializer.serialize(streetOffset, "string");
        }

        if (streetOffsetUnits !== undefined) {
            localVarQueryParameters['streetOffsetUnits'] = ObjectSerializer.serialize(streetOffsetUnits, "'METERS' | 'FEET'");
        }

        if (cornerOffset !== undefined) {
            localVarQueryParameters['cornerOffset'] = ObjectSerializer.serialize(cornerOffset, "string");
        }

        if (cornerOffsetUnits !== undefined) {
            localVarQueryParameters['cornerOffsetUnits'] = ObjectSerializer.serialize(cornerOffsetUnits, "'METERS' | 'FEET'");
        }

        if (removeAccentMarks !== undefined) {
            localVarQueryParameters['removeAccentMarks'] = ObjectSerializer.serialize(removeAccentMarks, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This is a Batch offering for geocode service. It accepts a single address or a list of addresses and returns location coordinates
     * @summary Post Forward Geocode
     * @param datapackBundle 
     * @param geocodeRequest 
     */
    public async geocodeBatch (datapackBundle: string, geocodeRequest: GeocodeRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponseList;  }> {
        const localVarPath = this._basePath + '/geocode/v1/{datapackBundle}/geocode'
            .replace('{' + 'datapackBundle' + '}', encodeURIComponent(String(datapackBundle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datapackBundle' is not null or undefined
        if (datapackBundle === null || datapackBundle === undefined) {
            throw new Error('Required parameter datapackBundle was null or undefined when calling geocodeBatch.');
        }

        // verify required parameter 'geocodeRequest' is not null or undefined
        if (geocodeRequest === null || geocodeRequest === undefined) {
            throw new Error('Required parameter geocodeRequest was null or undefined when calling geocodeBatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(geocodeRequest, "GeocodeRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponseList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This service accepts an address and returns the corresponding PreciselyID
     * @summary Get PreciselyID By Address
     * @param address The address to be searched.
     * @param country 3 letter ISO code of the country to be searched.
     */
    public async getPBKey (address: string, country?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PBKeyResponse;  }> {
        const localVarPath = this._basePath + '/geocode/v1/key/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling getPBKey.');
        }

        if (address !== undefined) {
            localVarQueryParameters['address'] = ObjectSerializer.serialize(address, "string");
        }

        if (country !== undefined) {
            localVarQueryParameters['country'] = ObjectSerializer.serialize(country, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PBKeyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This is a Batch offering for \'PreciselyID By Address\' service. It accepts a single address or a list of addresses and returns the corresponding PreciselyID.
     * @summary Post PreciselyID By Address
     * @param pBKeyAddressRequest 
     */
    public async getPBKeys (pBKeyAddressRequest: PBKeyAddressRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PBKeyResponseList;  }> {
        const localVarPath = this._basePath + '/geocode/v1/key/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'pBKeyAddressRequest' is not null or undefined
        if (pBKeyAddressRequest === null || pBKeyAddressRequest === undefined) {
            throw new Error('Required parameter pBKeyAddressRequest was null or undefined when calling getPBKeys.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(pBKeyAddressRequest, "PBKeyAddressRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PBKeyResponseList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This service accepts a PreciselyID and returns the corresponding address associated with that PreciselyID.
     * @summary Get Key Lookup
     * @param key PreciselyID which maps to a unique address.
     * @param type Specifies the key type - PreciselyID and GNAF_PID for Aus.
     * @param country 3 letter ISO code of the country to be searched.
     */
    public async keyLookup (key: string, type: string, country?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponse;  }> {
        const localVarPath = this._basePath + '/geocode/v1/keylookup';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling keyLookup.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling keyLookup.');
        }

        if (key !== undefined) {
            localVarQueryParameters['key'] = ObjectSerializer.serialize(key, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (country !== undefined) {
            localVarQueryParameters['country'] = ObjectSerializer.serialize(country, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This service accepts batches of PreciselyID\'s and returns the corresponding address associated with those PreciselyID\'s.
     * @summary Post Key Lookup
     * @param keyLookupRequest 
     */
    public async keyLookupBatch (keyLookupRequest: KeyLookupRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponseList;  }> {
        const localVarPath = this._basePath + '/geocode/v1/keylookup';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'keyLookupRequest' is not null or undefined
        if (keyLookupRequest === null || keyLookupRequest === undefined) {
            throw new Error('Required parameter keyLookupRequest was null or undefined when calling keyLookupBatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(keyLookupRequest, "KeyLookupRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponseList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This is a Batch offering for geocode service. It accepts a single address or a list of addresses and returns location coordinates
     * @summary Post Reverse Geocode
     * @param datapackBundle 
     * @param reverseGeocodeRequest 
     */
    public async reverseGeocodBatch (datapackBundle: string, reverseGeocodeRequest: ReverseGeocodeRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponseList;  }> {
        const localVarPath = this._basePath + '/geocode/v1/{datapackBundle}/reverseGeocode'
            .replace('{' + 'datapackBundle' + '}', encodeURIComponent(String(datapackBundle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datapackBundle' is not null or undefined
        if (datapackBundle === null || datapackBundle === undefined) {
            throw new Error('Required parameter datapackBundle was null or undefined when calling reverseGeocodBatch.');
        }

        // verify required parameter 'reverseGeocodeRequest' is not null or undefined
        if (reverseGeocodeRequest === null || reverseGeocodeRequest === undefined) {
            throw new Error('Required parameter reverseGeocodeRequest was null or undefined when calling reverseGeocodBatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(reverseGeocodeRequest, "ReverseGeocodeRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponseList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This service accepts location coordinate and returns an address.
     * @summary Get Reverse Geocode(Basic/Premium/Advanced)
     * @param datapackBundle datapackBundle
     * @param x Longitude of the location.
     * @param y Latitude of the location.
     * @param country Country name or ISO code.
     * @param coordSysName Coordinate system to convert geometry to in format codespace:code.
     * @param distance Radius in which search is performed.
     * @param distanceUnits Unit of measurement.
     */
    public async reverseGeocode (datapackBundle: 'premium' | 'basic' | 'advanced', x: string, y: string, country?: string, coordSysName?: string, distance?: string, distanceUnits?: 'METERS' | 'FEET', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponse;  }> {
        const localVarPath = this._basePath + '/geocode/v1/{datapackBundle}/reverseGeocode'
            .replace('{' + 'datapackBundle' + '}', encodeURIComponent(String(datapackBundle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datapackBundle' is not null or undefined
        if (datapackBundle === null || datapackBundle === undefined) {
            throw new Error('Required parameter datapackBundle was null or undefined when calling reverseGeocode.');
        }

        // verify required parameter 'x' is not null or undefined
        if (x === null || x === undefined) {
            throw new Error('Required parameter x was null or undefined when calling reverseGeocode.');
        }

        // verify required parameter 'y' is not null or undefined
        if (y === null || y === undefined) {
            throw new Error('Required parameter y was null or undefined when calling reverseGeocode.');
        }

        if (x !== undefined) {
            localVarQueryParameters['x'] = ObjectSerializer.serialize(x, "string");
        }

        if (y !== undefined) {
            localVarQueryParameters['y'] = ObjectSerializer.serialize(y, "string");
        }

        if (country !== undefined) {
            localVarQueryParameters['country'] = ObjectSerializer.serialize(country, "string");
        }

        if (coordSysName !== undefined) {
            localVarQueryParameters['coordSysName'] = ObjectSerializer.serialize(coordSysName, "string");
        }

        if (distance !== undefined) {
            localVarQueryParameters['distance'] = ObjectSerializer.serialize(distance, "string");
        }

        if (distanceUnits !== undefined) {
            localVarQueryParameters['distanceUnits'] = ObjectSerializer.serialize(distanceUnits, "'METERS' | 'FEET'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
