/**
 * Precisely APIs
 * Enhance & enrich your data, applications, business processes, and workflows with rich location, information, and identify APIs.
 *
 * The version of the OpenAPI document: 11.9.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { Demographics } from '../model/demographics';
import { DemographicsAdvancedRequest } from '../model/demographicsAdvancedRequest';
import { ErrorInfo } from '../model/errorInfo';
import { Segmentation } from '../model/segmentation';

import { ObjectSerializer, Authentication, Interceptor } from '../model/models';
import { OAuth,oAuthCredInfo } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.precisely.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum DemographicsServiceApiApiKeys {
}

export class DemographicsServiceApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
	protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

	protected interceptors: Interceptor[] = [];
    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this._basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: DemographicsServiceApiApiKeys, value: string) {
        this.authentications[DemographicsServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Demographics Advanced Endpoint will return the aggregated values of the selected demographics variables of the regions falling inside a user provided geometry or travel time/distance boundaries. All the intersecting demographic boundaries will be snapped completely, and user will have option to request these boundaries in response.  
     * @summary Demographics Advanced Endpoint
     * @param demographicsAdvancedRequest 
     */
    public async getDemographicsAdvanced (demographicsAdvancedRequest: DemographicsAdvancedRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Demographics;  }> {
        const localVarPath = this._basePath + '/demographics-segmentation/v1/advanced/demographics';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'demographicsAdvancedRequest' is not null or undefined
        if (demographicsAdvancedRequest === null || demographicsAdvancedRequest === undefined) {
            throw new Error('Required parameter demographicsAdvancedRequest was null or undefined when calling getDemographicsAdvanced.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(demographicsAdvancedRequest, "DemographicsAdvancedRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Demographics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Demographics Basic Endpoint will return the aggregated values of the selected demographics variables of the regions falling inside the search radius. All the intersecting demographic boundaries will be snapped completely and user will have option to request these boundaries in response.  
     * @summary Demographics Basic
     * @param address Address to be searched
     * @param longitude Longitude of the location
     * @param latitude Latitude of the location
     * @param searchRadius Radius within which demographics details are required. Max. value is 52800 Feet or 10 miles
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters 
     * @param travelTime Travel Time based on ‘travelMode’ within which demographics details are required. Max. value is 1 hour.
     * @param travelTimeUnit minutes,hours,seconds,milliseconds. Default is meters.Default is minutes.
     * @param travelDistance Travel Distance based on ‘travelMode’ within which demographics details are required. Max. value is 10 miles.
     * @param travelDistanceUnit feet,kilometers,miles,meters.  Default is feet.
     * @param travelMode Default is driving.
     * @param country 3 digit ISO country code (Used in case address is mentioned).
     * @param profile Applicable on ranged variables. Returns top sorted result based on the input value.
     * @param filter If Y, demographic boundaries are returned in response.
     * @param includeGeometry 
     */
    public async getDemographicsBasic (address?: string, longitude?: string, latitude?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, country?: string, profile?: string, filter?: string, includeGeometry?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Demographics;  }> {
        const localVarPath = this._basePath + '/demographics-segmentation/v1/basic/demographics';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (address !== undefined) {
            localVarQueryParameters['address'] = ObjectSerializer.serialize(address, "string");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "string");
        }

        if (searchRadius !== undefined) {
            localVarQueryParameters['searchRadius'] = ObjectSerializer.serialize(searchRadius, "string");
        }

        if (searchRadiusUnit !== undefined) {
            localVarQueryParameters['searchRadiusUnit'] = ObjectSerializer.serialize(searchRadiusUnit, "string");
        }

        if (travelTime !== undefined) {
            localVarQueryParameters['travelTime'] = ObjectSerializer.serialize(travelTime, "string");
        }

        if (travelTimeUnit !== undefined) {
            localVarQueryParameters['travelTimeUnit'] = ObjectSerializer.serialize(travelTimeUnit, "string");
        }

        if (travelDistance !== undefined) {
            localVarQueryParameters['travelDistance'] = ObjectSerializer.serialize(travelDistance, "string");
        }

        if (travelDistanceUnit !== undefined) {
            localVarQueryParameters['travelDistanceUnit'] = ObjectSerializer.serialize(travelDistanceUnit, "string");
        }

        if (travelMode !== undefined) {
            localVarQueryParameters['travelMode'] = ObjectSerializer.serialize(travelMode, "string");
        }

        if (country !== undefined) {
            localVarQueryParameters['country'] = ObjectSerializer.serialize(country, "string");
        }

        if (profile !== undefined) {
            localVarQueryParameters['profile'] = ObjectSerializer.serialize(profile, "string");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "string");
        }

        if (includeGeometry !== undefined) {
            localVarQueryParameters['includeGeometry'] = ObjectSerializer.serialize(includeGeometry, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Demographics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Provides the demographic details around a specified address. GeoLife \'byaddress\' service accepts address as an input to return a specific population segment\'s age group, ethnicity, income, purchasing behaviour, commuter patterns and more.
     * @summary Demographics By Address.
     * @param address The address to be searched.
     * @param country 3 letter ISO code of the country to be searched.Allowed values USA,CAN,GBR,AUS.
     * @param profile Retrieves the sorted demographic data on the basis of pre-defined profiles that can display the top 3 or top 5 results (by location) either in ascending or descending order.Allowed values Top5Ascending,Top5Descending,Top3Ascending,Top3Descending
     * @param filter The \&#39;filter\&#39; parameter retrieves the demographic data based upon specified input themes.
     * @param valueFormat The \&#39;valueFormat\&#39; parameter is applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
     * @param variableLevel The \&#39;variableLevel\&#39; retrieves demographic facts in response based on the input value
     */
    public async getDemographicsByAddress (address: string, country?: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Demographics;  }> {
        const localVarPath = this._basePath + '/demographics-segmentation/v1/demographics/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling getDemographicsByAddress.');
        }

        if (address !== undefined) {
            localVarQueryParameters['address'] = ObjectSerializer.serialize(address, "string");
        }

        if (country !== undefined) {
            localVarQueryParameters['country'] = ObjectSerializer.serialize(country, "string");
        }

        if (profile !== undefined) {
            localVarQueryParameters['profile'] = ObjectSerializer.serialize(profile, "string");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "string");
        }

        if (valueFormat !== undefined) {
            localVarQueryParameters['valueFormat'] = ObjectSerializer.serialize(valueFormat, "string");
        }

        if (variableLevel !== undefined) {
            localVarQueryParameters['variableLevel'] = ObjectSerializer.serialize(variableLevel, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Demographics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This endpoint will allow the user to request demographics details by census boundary id. Multiple comma separated boundary ids will be accepted. 
     * @summary Demographics By Boundaryids.
     * @param boundaryIds Accepts comma separated multiple boundary ids.
     * @param profile Applicable on ranged variables. Returns top sorted result based on the input value.
     * @param filter Accept the comma separated theme names and filter response based on value. Maximum 10 can be provided.
     * @param valueFormat Applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
     * @param variableLevel Retrieves demographic facts in response based on the input value.
     */
    public async getDemographicsByBoundaryIds (boundaryIds?: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Demographics;  }> {
        const localVarPath = this._basePath + '/demographics-segmentation/v1/demographics/byboundaryids';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (boundaryIds !== undefined) {
            localVarQueryParameters['boundaryIds'] = ObjectSerializer.serialize(boundaryIds, "string");
        }

        if (profile !== undefined) {
            localVarQueryParameters['profile'] = ObjectSerializer.serialize(profile, "string");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "string");
        }

        if (valueFormat !== undefined) {
            localVarQueryParameters['valueFormat'] = ObjectSerializer.serialize(valueFormat, "string");
        }

        if (variableLevel !== undefined) {
            localVarQueryParameters['variableLevel'] = ObjectSerializer.serialize(variableLevel, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Demographics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Provides the demographic details around a specified location. GeoLife \'bylocation\' service accepts longitude and latitude as an input to return a specific population segment\'s age group, ethnicity, income, purchasing behaviour, commuter patterns and more.
     * @summary Demographics By Location.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     * @param profile Retrieves the sorted demographic data on the basis of pre-defined profiles that can display the top 3 or top 5 results (by location) either in ascending or descending order.Allowed values Top5Ascending,Top5Descending,Top3Ascending,Top3Descending
     * @param filter The \&#39;filter\&#39; parameter retrieves the demographic data based upon specified input themes.
     * @param valueFormat The \&#39;valueFormat\&#39; parameter is applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
     * @param variableLevel The \&#39;variableLevel\&#39; retrieves demographic facts in response based on the input value
     */
    public async getDemographicsByLocation (longitude?: string, latitude?: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Demographics;  }> {
        const localVarPath = this._basePath + '/demographics-segmentation/v1/demographics/bylocation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "string");
        }

        if (profile !== undefined) {
            localVarQueryParameters['profile'] = ObjectSerializer.serialize(profile, "string");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "string");
        }

        if (valueFormat !== undefined) {
            localVarQueryParameters['valueFormat'] = ObjectSerializer.serialize(valueFormat, "string");
        }

        if (variableLevel !== undefined) {
            localVarQueryParameters['variableLevel'] = ObjectSerializer.serialize(variableLevel, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Demographics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Provides the segmentation details around a specified address. GeoLife \'Segmentation by Address\' service accepts address as an input to return the lifestyle characteristics of households in terms of their family status, children characteristics, income behaviors, financial preferences and interests.
     * @summary Segmentation By Address.
     * @param address The address to be searched.
     * @param country 3 letter ISO code of the country to be searched.Allowed values USA,CAN,GBR,FRA,ITA,AUS,DEU.
     */
    public async getSegmentationByAddress (address: string, country?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Segmentation;  }> {
        const localVarPath = this._basePath + '/demographics-segmentation/v1/segmentation/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling getSegmentationByAddress.');
        }

        if (address !== undefined) {
            localVarQueryParameters['address'] = ObjectSerializer.serialize(address, "string");
        }

        if (country !== undefined) {
            localVarQueryParameters['country'] = ObjectSerializer.serialize(country, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Segmentation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Provides the segmentation details around a specified location. GeoLife \'segmentation bylocation\' service accepts longitude and latitude as an input to return the lifestyle characteristics of households in terms of their family status, children characteristics, income behaviors, financial preferences and interests.
     * @summary Segmentation By Location.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     */
    public async getSegmentationByLocation (longitude: string, latitude: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Segmentation;  }> {
        const localVarPath = this._basePath + '/demographics-segmentation/v1/segmentation/bylocation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
            throw new Error('Required parameter longitude was null or undefined when calling getSegmentationByLocation.');
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
            throw new Error('Required parameter latitude was null or undefined when calling getSegmentationByLocation.');
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Segmentation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
