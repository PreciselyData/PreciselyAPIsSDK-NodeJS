/**
 * Precisely APIs
 * Enhance & enrich your data, applications, business processes, and workflows with rich location, information, and identify APIs.
 *
 * The version of the OpenAPI document: 11.9.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { ErrorInfo } from '../model/errorInfo';
import { MetadataResponse } from '../model/metadataResponse';
import { POIByGeometryRequest } from '../model/pOIByGeometryRequest';
import { PlacesResponse } from '../model/placesResponse';
import { Poi } from '../model/poi';
import { PoiCount } from '../model/poiCount';
import { PoiCountRequest } from '../model/poiCountRequest';

import { ObjectSerializer, Authentication, Interceptor } from '../model/models';
import { OAuth,oAuthCredInfo } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.precisely.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum PlacesServiceApiApiKeys {
}

export class PlacesServiceApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
	protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

	protected interceptors: Interceptor[] = [];
    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this._basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PlacesServiceApiApiKeys, value: string) {
        this.authentications[PlacesServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * This service returns a list of Category codes & associated metadata which can then be used as inputs for querying the Points of Interest By Address or Location methods listed above.
     * @summary Category Code Metadata.
     * @param categoryCode 4, 6, or 11 digits category code to filter the response.
     * @param level 1, 2, or 3.
     */
    public async getCategoryCodeMetadata (categoryCode?: string, level?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: MetadataResponse;  }> {
        const localVarPath = this._basePath + '/places/v1/metadata/category';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (categoryCode !== undefined) {
            localVarQueryParameters['categoryCode'] = ObjectSerializer.serialize(categoryCode, "string");
        }

        if (level !== undefined) {
            localVarQueryParameters['level'] = ObjectSerializer.serialize(level, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: MetadataResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This service returns complete details of a chosen point of interest by an identifier. The identifier could be selected from Autocomplete API response.
     * @summary Points Of Interest Details By Id
     * @param id POI unique Identifier.
     */
    public async getPOIById (id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Poi;  }> {
        const localVarPath = this._basePath + '/places/v1/poi/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPOIById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Poi;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This service accepts an address as input and returns nearby points-of-interest places around that address. Additional input features include retrieving data by name, type, standard industrial classifications and category codes, as well as geographic filtering by radius, travel times and travel distances. Response features include JSON/XML as well as CSV download.
     * @summary Get POIs By Address.
     * @param address The address to be searched.
     * @param country Country ISO code.
     * @param name Specifies the name of the place (POI) to be searched. Also performs search on partially specified names. It requires minimum 3 characters to search.
     * @param type Filters the points of interest (POIs) by place types.
     * @param categoryCode Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values.
     * @param sicCode Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values
     * @param maxCandidates Maximum number of POIs that can be retrieved
     * @param searchRadius Radius range within which search is performed.
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters (default).
     * @param travelTime Travel time within which search is performed (POIs which can be reached within travel time).
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds.
     * @param travelDistance Travel distance within which search is performed (POIs which can be reached within travel distance).
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
     * @param travelMode Mode of commute.
     * @param sortBy Whether to sort the results based on relevance (best match) or by nearest distance from input location.
     * @param fuzzyOnName Whether to allow fuzzy seacrh on name input.
     * @param page Specifies the page number of results where page size is the value of maxCandidates input in request.
     * @param matchMode Determine the leniency used to make a match between the input name and the reference data.
     * @param specificMatchOn Specifies the field for the Specific Match Mode.
     */
    public async getPOIsByAddress (address?: string, country?: string, name?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, sortBy?: string, fuzzyOnName?: string, page?: string, matchMode?: string, specificMatchOn?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PlacesResponse;  }> {
        const localVarPath = this._basePath + '/places/v1/poi/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (address !== undefined) {
            localVarQueryParameters['address'] = ObjectSerializer.serialize(address, "string");
        }

        if (country !== undefined) {
            localVarQueryParameters['country'] = ObjectSerializer.serialize(country, "string");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (categoryCode !== undefined) {
            localVarQueryParameters['categoryCode'] = ObjectSerializer.serialize(categoryCode, "string");
        }

        if (sicCode !== undefined) {
            localVarQueryParameters['sicCode'] = ObjectSerializer.serialize(sicCode, "string");
        }

        if (maxCandidates !== undefined) {
            localVarQueryParameters['maxCandidates'] = ObjectSerializer.serialize(maxCandidates, "string");
        }

        if (searchRadius !== undefined) {
            localVarQueryParameters['searchRadius'] = ObjectSerializer.serialize(searchRadius, "string");
        }

        if (searchRadiusUnit !== undefined) {
            localVarQueryParameters['searchRadiusUnit'] = ObjectSerializer.serialize(searchRadiusUnit, "string");
        }

        if (travelTime !== undefined) {
            localVarQueryParameters['travelTime'] = ObjectSerializer.serialize(travelTime, "string");
        }

        if (travelTimeUnit !== undefined) {
            localVarQueryParameters['travelTimeUnit'] = ObjectSerializer.serialize(travelTimeUnit, "string");
        }

        if (travelDistance !== undefined) {
            localVarQueryParameters['travelDistance'] = ObjectSerializer.serialize(travelDistance, "string");
        }

        if (travelDistanceUnit !== undefined) {
            localVarQueryParameters['travelDistanceUnit'] = ObjectSerializer.serialize(travelDistanceUnit, "string");
        }

        if (travelMode !== undefined) {
            localVarQueryParameters['travelMode'] = ObjectSerializer.serialize(travelMode, "string");
        }

        if (sortBy !== undefined) {
            localVarQueryParameters['sortBy'] = ObjectSerializer.serialize(sortBy, "string");
        }

        if (fuzzyOnName !== undefined) {
            localVarQueryParameters['fuzzyOnName'] = ObjectSerializer.serialize(fuzzyOnName, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (matchMode !== undefined) {
            localVarQueryParameters['matchMode'] = ObjectSerializer.serialize(matchMode, "string");
        }

        if (specificMatchOn !== undefined) {
            localVarQueryParameters['specificMatchOn'] = ObjectSerializer.serialize(specificMatchOn, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PlacesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This service accepts city or postcode (alongwith country) and returns points-of-interest places within a city or postcode. Additional input features include retrieving data by name, type, standard industrial classifications and category codes, as well as geographic filtering by radius, travel times and travel distances. Response features include JSON/XML as well as CSV download.
     * @summary GET Points Of Interest By Area.
     * @param areaName1 Specifies the largest geographical area, typically a state or province
     * @param areaName3 Specifies a city or town name
     * @param postcode1 Specifies the postcode(ZIP code) in the appropriate format for the country
     * @param postcode2 Specifies the postcode(ZIP code) extension
     * @param country Country ISO code
     * @param name Specifies the name of the place (POI) to be searched. Also performs search on partially specified names. It requires minimum 3 characters to search
     * @param type Filters the points of interest (POIs) by place types
     * @param categoryCode Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values
     * @param sicCode Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values
     * @param maxCandidates Maximum number of POIs that can be retrieved
     * @param fuzzyOnName Whether to allow fuzzy seacrh on name input
     * @param page Specifies the page number of results where page size is the value of maxCandidates input in request
     * @param matchMode Determine the leniency used to make a match between the input name and the reference data
     * @param specificMatchOn Specifies the field for the Specific Match Mode
     */
    public async getPOIsByArea (areaName1?: string, areaName3?: string, postcode1?: string, postcode2?: string, country?: string, name?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, fuzzyOnName?: string, page?: string, matchMode?: string, specificMatchOn?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PlacesResponse;  }> {
        const localVarPath = this._basePath + '/places/v1/poi/byarea';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (areaName1 !== undefined) {
            localVarQueryParameters['areaName1'] = ObjectSerializer.serialize(areaName1, "string");
        }

        if (areaName3 !== undefined) {
            localVarQueryParameters['areaName3'] = ObjectSerializer.serialize(areaName3, "string");
        }

        if (postcode1 !== undefined) {
            localVarQueryParameters['postcode1'] = ObjectSerializer.serialize(postcode1, "string");
        }

        if (postcode2 !== undefined) {
            localVarQueryParameters['postcode2'] = ObjectSerializer.serialize(postcode2, "string");
        }

        if (country !== undefined) {
            localVarQueryParameters['country'] = ObjectSerializer.serialize(country, "string");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (categoryCode !== undefined) {
            localVarQueryParameters['categoryCode'] = ObjectSerializer.serialize(categoryCode, "string");
        }

        if (sicCode !== undefined) {
            localVarQueryParameters['sicCode'] = ObjectSerializer.serialize(sicCode, "string");
        }

        if (maxCandidates !== undefined) {
            localVarQueryParameters['maxCandidates'] = ObjectSerializer.serialize(maxCandidates, "string");
        }

        if (fuzzyOnName !== undefined) {
            localVarQueryParameters['fuzzyOnName'] = ObjectSerializer.serialize(fuzzyOnName, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (matchMode !== undefined) {
            localVarQueryParameters['matchMode'] = ObjectSerializer.serialize(matchMode, "string");
        }

        if (specificMatchOn !== undefined) {
            localVarQueryParameters['specificMatchOn'] = ObjectSerializer.serialize(specificMatchOn, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PlacesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Accepts a user-defined boundary as input and returns all Points of Interest within the boundary. Additionally, user can filter the response by name, type, standard industrial classifications and category codes.
     * @summary Points Of Interest By Boundary
     * @param pOIByGeometryRequest 
     */
    public async getPOIsByGeometry (pOIByGeometryRequest: POIByGeometryRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PlacesResponse;  }> {
        const localVarPath = this._basePath + '/places/v1/poi/byboundary';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'pOIByGeometryRequest' is not null or undefined
        if (pOIByGeometryRequest === null || pOIByGeometryRequest === undefined) {
            throw new Error('Required parameter pOIByGeometryRequest was null or undefined when calling getPOIsByGeometry.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(pOIByGeometryRequest, "POIByGeometryRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PlacesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This service accepts latitude/longitude as input and returns nearby points-of-interest places around that location. Additional input features include retrieving data by name, type, standard industrial classifications and category codes, as well as geographic filtering by radius, travel times and travel distances. Response features include JSON/XML as well as CSV download
     * @summary Get POIs By Location.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     * @param name Specifies the name of the place (POI) to be searched. Also performs search on partially specified names. It requires minimum 3 characters to search.
     * @param type Filters the points of interest (POIs) by place types.
     * @param categoryCode Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values.
     * @param sicCode Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values
     * @param maxCandidates Maximum number of POIs that can be retrieved
     * @param searchRadius Radius range within which search is performed.
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters (default).
     * @param travelTime Travel time within which search is performed (POIs which can be reached within travel time).
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds.
     * @param travelDistance Travel distance within which search is performed (POIs which can be reached within travel distance).
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
     * @param travelMode Mode of commute.
     * @param sortBy Whether to sort the results based on relevance (best match) or by nearest distance from input location.
     * @param fuzzyOnName Whether to allow fuzzy seacrh on name input.
     * @param page Specifies the page number of results where page size is the value of maxCandidates input in request.
     * @param matchMode Determine the leniency used to make a match between the input name and the reference data.
     * @param specificMatchOn Specifies the field for the Specific Match Mode.
     */
    public async getPOIsByLocation (longitude: string, latitude: string, name?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, sortBy?: string, fuzzyOnName?: string, page?: string, matchMode?: string, specificMatchOn?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PlacesResponse;  }> {
        const localVarPath = this._basePath + '/places/v1/poi/bylocation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
            throw new Error('Required parameter longitude was null or undefined when calling getPOIsByLocation.');
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
            throw new Error('Required parameter latitude was null or undefined when calling getPOIsByLocation.');
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "string");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (categoryCode !== undefined) {
            localVarQueryParameters['categoryCode'] = ObjectSerializer.serialize(categoryCode, "string");
        }

        if (sicCode !== undefined) {
            localVarQueryParameters['sicCode'] = ObjectSerializer.serialize(sicCode, "string");
        }

        if (maxCandidates !== undefined) {
            localVarQueryParameters['maxCandidates'] = ObjectSerializer.serialize(maxCandidates, "string");
        }

        if (searchRadius !== undefined) {
            localVarQueryParameters['searchRadius'] = ObjectSerializer.serialize(searchRadius, "string");
        }

        if (searchRadiusUnit !== undefined) {
            localVarQueryParameters['searchRadiusUnit'] = ObjectSerializer.serialize(searchRadiusUnit, "string");
        }

        if (travelTime !== undefined) {
            localVarQueryParameters['travelTime'] = ObjectSerializer.serialize(travelTime, "string");
        }

        if (travelTimeUnit !== undefined) {
            localVarQueryParameters['travelTimeUnit'] = ObjectSerializer.serialize(travelTimeUnit, "string");
        }

        if (travelDistance !== undefined) {
            localVarQueryParameters['travelDistance'] = ObjectSerializer.serialize(travelDistance, "string");
        }

        if (travelDistanceUnit !== undefined) {
            localVarQueryParameters['travelDistanceUnit'] = ObjectSerializer.serialize(travelDistanceUnit, "string");
        }

        if (travelMode !== undefined) {
            localVarQueryParameters['travelMode'] = ObjectSerializer.serialize(travelMode, "string");
        }

        if (sortBy !== undefined) {
            localVarQueryParameters['sortBy'] = ObjectSerializer.serialize(sortBy, "string");
        }

        if (fuzzyOnName !== undefined) {
            localVarQueryParameters['fuzzyOnName'] = ObjectSerializer.serialize(fuzzyOnName, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (matchMode !== undefined) {
            localVarQueryParameters['matchMode'] = ObjectSerializer.serialize(matchMode, "string");
        }

        if (specificMatchOn !== undefined) {
            localVarQueryParameters['specificMatchOn'] = ObjectSerializer.serialize(specificMatchOn, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PlacesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Accepts a user-defined boundary as input and returns the Count number of POIs within the boundary. Additionally, user can request the count of filtered POIs by name, type, standard industrial classifications and category codes within the given polygon.
     * @summary Points Of Interest Count
     * @param contentType 
     * @param poiCountRequest 
     */
    public async getPOIsCount (contentType: string, poiCountRequest: PoiCountRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PoiCount;  }> {
        const localVarPath = this._basePath + '/places/v1/poicount';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getPOIsCount.');
        }

        // verify required parameter 'poiCountRequest' is not null or undefined
        if (poiCountRequest === null || poiCountRequest === undefined) {
            throw new Error('Required parameter poiCountRequest was null or undefined when calling getPOIsCount.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(poiCountRequest, "PoiCountRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PoiCount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This service returns a list of standard industrial classification codes & associated metadata which can then be used as inputs for querying the Points of Interest By Address or Location methods listed above.
     * @summary Get SIC Metadata
     * @param sicCode 4 or 8 digits SIC code to filter the response.
     * @param level 1 or 2.
     */
    public async getSICMetadata (sicCode?: string, level?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: MetadataResponse;  }> {
        const localVarPath = this._basePath + '/places/v1/metadata/sic';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (sicCode !== undefined) {
            localVarQueryParameters['sicCode'] = ObjectSerializer.serialize(sicCode, "string");
        }

        if (level !== undefined) {
            localVarQueryParameters['level'] = ObjectSerializer.serialize(level, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: MetadataResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * This service accepts partial text input and returns matching points of interest, sorted by relevance or distance.
     * @summary Points Of Interest Autocomplete
     * @param xForwardedFor 
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     * @param searchText Free text which will accept a multi-word string. Combination of POI name and address is possible.
     * @param searchOnNameOnly 
     * @param searchRadius Radius range within which search is performed.
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters (default).
     * @param travelTime Travel time within which search is performed (POIs which can be reached within travel time).
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds.
     * @param travelDistance Travel distance within which search is performed (POIs which can be reached within travel distance).
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
     * @param travelMode Mode of commute.
     * @param country Country ISO code.
     * @param areaName1 Specifies the largest geographical area, typically a state or province.
     * @param areaName3 Specifies a city or town name.
     * @param postcode1 Specifies the postcode(ZIP code) in the appropriate format for the country.
     * @param postcode2 Specifies the postcode(ZIP code) extension.
     * @param ipAddress IP address which will be used to auto detect the location in order to serve contextually relevant results.
     * @param autoDetectLocation Specifies whether to detect client\&#39;s location using IP address. If IP address(below) is not provided and autoDetectLocation is set \&#39;True\&#39; then IP address will be picked from HTTP request automatically.
     * @param type Filters the points of interest (POIs) by place types.
     * @param categoryCode Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values.
     * @param sicCode Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values.
     * @param maxCandidates Maximum number of POIs that can be retrieved.
     * @param sortBy sortBy
     * @param matchMode Determine the leniency used to make a match between the input name and the reference data.
     * @param specificMatchOn Specifies the field for the Specific Match Mode.
     */
    public async poisAutocomplete (xForwardedFor?: string, longitude?: string, latitude?: string, searchText?: string, searchOnNameOnly?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, country?: string, areaName1?: string, areaName3?: string, postcode1?: string, postcode2?: string, ipAddress?: string, autoDetectLocation?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, sortBy?: string, matchMode?: string, specificMatchOn?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PlacesResponse;  }> {
        const localVarPath = this._basePath + '/places/v1/poi/autocomplete';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "string");
        }

        if (searchText !== undefined) {
            localVarQueryParameters['searchText'] = ObjectSerializer.serialize(searchText, "string");
        }

        if (searchOnNameOnly !== undefined) {
            localVarQueryParameters['searchOnNameOnly'] = ObjectSerializer.serialize(searchOnNameOnly, "string");
        }

        if (searchRadius !== undefined) {
            localVarQueryParameters['searchRadius'] = ObjectSerializer.serialize(searchRadius, "string");
        }

        if (searchRadiusUnit !== undefined) {
            localVarQueryParameters['searchRadiusUnit'] = ObjectSerializer.serialize(searchRadiusUnit, "string");
        }

        if (travelTime !== undefined) {
            localVarQueryParameters['travelTime'] = ObjectSerializer.serialize(travelTime, "string");
        }

        if (travelTimeUnit !== undefined) {
            localVarQueryParameters['travelTimeUnit'] = ObjectSerializer.serialize(travelTimeUnit, "string");
        }

        if (travelDistance !== undefined) {
            localVarQueryParameters['travelDistance'] = ObjectSerializer.serialize(travelDistance, "string");
        }

        if (travelDistanceUnit !== undefined) {
            localVarQueryParameters['travelDistanceUnit'] = ObjectSerializer.serialize(travelDistanceUnit, "string");
        }

        if (travelMode !== undefined) {
            localVarQueryParameters['travelMode'] = ObjectSerializer.serialize(travelMode, "string");
        }

        if (country !== undefined) {
            localVarQueryParameters['country'] = ObjectSerializer.serialize(country, "string");
        }

        if (areaName1 !== undefined) {
            localVarQueryParameters['areaName1'] = ObjectSerializer.serialize(areaName1, "string");
        }

        if (areaName3 !== undefined) {
            localVarQueryParameters['areaName3'] = ObjectSerializer.serialize(areaName3, "string");
        }

        if (postcode1 !== undefined) {
            localVarQueryParameters['postcode1'] = ObjectSerializer.serialize(postcode1, "string");
        }

        if (postcode2 !== undefined) {
            localVarQueryParameters['postcode2'] = ObjectSerializer.serialize(postcode2, "string");
        }

        if (ipAddress !== undefined) {
            localVarQueryParameters['ipAddress'] = ObjectSerializer.serialize(ipAddress, "string");
        }

        if (autoDetectLocation !== undefined) {
            localVarQueryParameters['autoDetectLocation'] = ObjectSerializer.serialize(autoDetectLocation, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (categoryCode !== undefined) {
            localVarQueryParameters['categoryCode'] = ObjectSerializer.serialize(categoryCode, "string");
        }

        if (sicCode !== undefined) {
            localVarQueryParameters['sicCode'] = ObjectSerializer.serialize(sicCode, "string");
        }

        if (maxCandidates !== undefined) {
            localVarQueryParameters['maxCandidates'] = ObjectSerializer.serialize(maxCandidates, "string");
        }

        if (sortBy !== undefined) {
            localVarQueryParameters['sortBy'] = ObjectSerializer.serialize(sortBy, "string");
        }

        if (matchMode !== undefined) {
            localVarQueryParameters['matchMode'] = ObjectSerializer.serialize(matchMode, "string");
        }

        if (specificMatchOn !== undefined) {
            localVarQueryParameters['specificMatchOn'] = ObjectSerializer.serialize(specificMatchOn, "string");
        }

        localVarHeaderParams['X-Forwarded-For'] = ObjectSerializer.serialize(xForwardedFor, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PlacesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
