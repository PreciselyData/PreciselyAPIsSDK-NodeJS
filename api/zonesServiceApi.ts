/**
 * Precisely APIs
 * Enhance & enrich your data, applications, business processes, and workflows with rich location, information, and identify APIs.
 *
 * The version of the OpenAPI document: 12.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { BasicBoundary } from '../model/basicBoundary';
import { ErrorInfo } from '../model/errorInfo';
import { POIBoundaryAddressRequest } from '../model/pOIBoundaryAddressRequest';
import { POIBoundaryLocationRequest } from '../model/pOIBoundaryLocationRequest';
import { POIBoundaryResponse } from '../model/pOIBoundaryResponse';
import { PoiBoundary } from '../model/poiBoundary';
import { TravelBoundaries } from '../model/travelBoundaries';

import { ObjectSerializer, Authentication, Interceptor } from '../model/models';
import { OAuth,oAuthCredInfo } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.precisely.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum ZonesServiceApiApiKeys {
}

export class ZonesServiceApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
	protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

	protected interceptors: Interceptor[] = [];
    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this._basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ZonesServiceApiApiKeys, value: string) {
        this.authentications[ZonesServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Gets Basic Boundary by Address.
     * @summary Gets Basic Boundary by Address.
     * @param address Address around which Basic Boundary is requested
     * @param country Three digit ISO country code
     * @param distance 
     * @param distanceUnit 
     * @param resolution This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4.
     * @param responseSrs 
     */
    public async getBasicBoundaryByAddress (address: string, country?: string, distance?: string, distanceUnit?: string, resolution?: string, responseSrs?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: BasicBoundary;  }> {
        const localVarPath = this._basePath + '/zones/v1/basicboundary/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling getBasicBoundaryByAddress.');
        }

        if (address !== undefined) {
            localVarQueryParameters['address'] = ObjectSerializer.serialize(address, "string");
        }

        if (country !== undefined) {
            localVarQueryParameters['country'] = ObjectSerializer.serialize(country, "string");
        }

        if (distance !== undefined) {
            localVarQueryParameters['distance'] = ObjectSerializer.serialize(distance, "string");
        }

        if (distanceUnit !== undefined) {
            localVarQueryParameters['distanceUnit'] = ObjectSerializer.serialize(distanceUnit, "string");
        }

        if (resolution !== undefined) {
            localVarQueryParameters['resolution'] = ObjectSerializer.serialize(resolution, "string");
        }

        if (responseSrs !== undefined) {
            localVarQueryParameters['responseSrs'] = ObjectSerializer.serialize(responseSrs, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: BasicBoundary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets Basic Boundary by Location.
     * @summary Gets Basic Boundary by Location.
     * @param latitude Latitude around which Basic Boundary is requested
     * @param longitude Longitude around which Basic Boundary is requested
     * @param distance This is width of the buffer (in a complete circular buffer, it would be radius of the buffer). This has to be a positive number.
     * @param distanceUnit 
     * @param resolution This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4.
     * @param responseSrs 
     * @param srsName 
     */
    public async getBasicBoundaryByLocation (latitude: string, longitude: string, distance: string, distanceUnit?: string, resolution?: string, responseSrs?: string, srsName?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: BasicBoundary;  }> {
        const localVarPath = this._basePath + '/zones/v1/basicboundary/bylocation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
            throw new Error('Required parameter latitude was null or undefined when calling getBasicBoundaryByLocation.');
        }

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
            throw new Error('Required parameter longitude was null or undefined when calling getBasicBoundaryByLocation.');
        }

        // verify required parameter 'distance' is not null or undefined
        if (distance === null || distance === undefined) {
            throw new Error('Required parameter distance was null or undefined when calling getBasicBoundaryByLocation.');
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "string");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "string");
        }

        if (distance !== undefined) {
            localVarQueryParameters['distance'] = ObjectSerializer.serialize(distance, "string");
        }

        if (distanceUnit !== undefined) {
            localVarQueryParameters['distanceUnit'] = ObjectSerializer.serialize(distanceUnit, "string");
        }

        if (resolution !== undefined) {
            localVarQueryParameters['resolution'] = ObjectSerializer.serialize(resolution, "string");
        }

        if (responseSrs !== undefined) {
            localVarQueryParameters['responseSrs'] = ObjectSerializer.serialize(responseSrs, "string");
        }

        if (srsName !== undefined) {
            localVarQueryParameters['srsName'] = ObjectSerializer.serialize(srsName, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: BasicBoundary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets Point of Interests Boundary by Address.
     * @summary Gets Point of Interests Boundary by Address.
     * @param address Address around which POI Boundary is requested
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes.
     * @param sicCode Specify starting digits or full sic code to filter the response
     * @param naicsCode Will accept naicsCode to filter POIs in results. Max 10 allowed.
     */
    public async getPOIBoundaryByAddress (address: string, categoryCode?: string, sicCode?: string, naicsCode?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PoiBoundary;  }> {
        const localVarPath = this._basePath + '/zones/v1/poiboundary/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling getPOIBoundaryByAddress.');
        }

        if (address !== undefined) {
            localVarQueryParameters['address'] = ObjectSerializer.serialize(address, "string");
        }

        if (categoryCode !== undefined) {
            localVarQueryParameters['categoryCode'] = ObjectSerializer.serialize(categoryCode, "string");
        }

        if (sicCode !== undefined) {
            localVarQueryParameters['sicCode'] = ObjectSerializer.serialize(sicCode, "string");
        }

        if (naicsCode !== undefined) {
            localVarQueryParameters['naicsCode'] = ObjectSerializer.serialize(naicsCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PoiBoundary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Batch method for getting Point of Interests Boundary by Address.
     * @summary Batch method for getting Point of Interests Boundary by Address.
     * @param pOIBoundaryAddressRequest 
     */
    public async getPOIBoundaryByAddressBatch (pOIBoundaryAddressRequest: POIBoundaryAddressRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: POIBoundaryResponse;  }> {
        const localVarPath = this._basePath + '/zones/v1/poiboundary/byaddress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'pOIBoundaryAddressRequest' is not null or undefined
        if (pOIBoundaryAddressRequest === null || pOIBoundaryAddressRequest === undefined) {
            throw new Error('Required parameter pOIBoundaryAddressRequest was null or undefined when calling getPOIBoundaryByAddressBatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(pOIBoundaryAddressRequest, "POIBoundaryAddressRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: POIBoundaryResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Point of Interests Boundary by Location.
     * @summary Get Point of Interests Boundary by Location.
     * @param latitude Latitude around which POI Boundary is requested
     * @param longitude Longitude around which POI Boundary is requested
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes
     * @param sicCode Specify starting digits or full sic code to filter the response
     * @param naicsCode Will accept naicsCode to filter POIs in results. Max 10 allowed.
     */
    public async getPOIBoundaryByLocation (latitude: string, longitude: string, categoryCode?: string, sicCode?: string, naicsCode?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PoiBoundary;  }> {
        const localVarPath = this._basePath + '/zones/v1/poiboundary/bylocation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
            throw new Error('Required parameter latitude was null or undefined when calling getPOIBoundaryByLocation.');
        }

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
            throw new Error('Required parameter longitude was null or undefined when calling getPOIBoundaryByLocation.');
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "string");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "string");
        }

        if (categoryCode !== undefined) {
            localVarQueryParameters['categoryCode'] = ObjectSerializer.serialize(categoryCode, "string");
        }

        if (sicCode !== undefined) {
            localVarQueryParameters['sicCode'] = ObjectSerializer.serialize(sicCode, "string");
        }

        if (naicsCode !== undefined) {
            localVarQueryParameters['naicsCode'] = ObjectSerializer.serialize(naicsCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PoiBoundary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Batch method for getting Point of Interests Boundary by Location.
     * @summary Batch method for getting Point of Interests Boundary by Location.
     * @param pOIBoundaryLocationRequest 
     */
    public async getPOIBoundaryByLocationBatch (pOIBoundaryLocationRequest: POIBoundaryLocationRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: POIBoundaryResponse;  }> {
        const localVarPath = this._basePath + '/zones/v1/poiboundary/bylocation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'application/xml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'pOIBoundaryLocationRequest' is not null or undefined
        if (pOIBoundaryLocationRequest === null || pOIBoundaryLocationRequest === undefined) {
            throw new Error('Required parameter pOIBoundaryLocationRequest was null or undefined when calling getPOIBoundaryByLocationBatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(pOIBoundaryLocationRequest, "POIBoundaryLocationRequest")
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: POIBoundaryResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Returns the travel boundary based on travel distance.
     * @summary Get TravelBoundary By Distance.
     * @param point Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format
     * @param address Address around which Basic Boundary is requested.
     * @param costs Travel time used to calculate the travel boundary.
     * @param costUnit Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
     * @param db Mode of commute.
     * @param country 3 character ISO code or country name.
     * @param maxOffroadDistance Maximum distance to allow travel off the road network.
     * @param maxOffroadDistanceUnit MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param destinationSrs Desired coordinate system of the travel boundary.
     * @param majorRoads Whether to include all roads in the calculation or just major roads.
     * @param returnHoles Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time
     * @param returnIslands Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time
     * @param simplificationFactor Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex
     * @param bandingStyle Style of banding to be used in the result
     * @param historicTrafficTimeBucket Whether routing calculation uses the historic traffic speeds
     * @param defaultAmbientSpeed The speed to travel when going off a network road to find the travel boundary (for all road types).
     * @param ambientSpeedUnit The unit of measure to use to calculate the ambient speed.
     */
    public async getTravelBoundaryByDistance (point?: string, address?: string, costs?: string, costUnit?: string, db?: string, country?: string, maxOffroadDistance?: string, maxOffroadDistanceUnit?: string, destinationSrs?: string, majorRoads?: string, returnHoles?: string, returnIslands?: string, simplificationFactor?: string, bandingStyle?: string, historicTrafficTimeBucket?: string, defaultAmbientSpeed?: string, ambientSpeedUnit?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TravelBoundaries;  }> {
        const localVarPath = this._basePath + '/zones/v1/travelboundary/bydistance';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (point !== undefined) {
            localVarQueryParameters['point'] = ObjectSerializer.serialize(point, "string");
        }

        if (address !== undefined) {
            localVarQueryParameters['address'] = ObjectSerializer.serialize(address, "string");
        }

        if (costs !== undefined) {
            localVarQueryParameters['costs'] = ObjectSerializer.serialize(costs, "string");
        }

        if (costUnit !== undefined) {
            localVarQueryParameters['costUnit'] = ObjectSerializer.serialize(costUnit, "string");
        }

        if (db !== undefined) {
            localVarQueryParameters['db'] = ObjectSerializer.serialize(db, "string");
        }

        if (country !== undefined) {
            localVarQueryParameters['country'] = ObjectSerializer.serialize(country, "string");
        }

        if (maxOffroadDistance !== undefined) {
            localVarQueryParameters['maxOffroadDistance'] = ObjectSerializer.serialize(maxOffroadDistance, "string");
        }

        if (maxOffroadDistanceUnit !== undefined) {
            localVarQueryParameters['maxOffroadDistanceUnit'] = ObjectSerializer.serialize(maxOffroadDistanceUnit, "string");
        }

        if (destinationSrs !== undefined) {
            localVarQueryParameters['destinationSrs'] = ObjectSerializer.serialize(destinationSrs, "string");
        }

        if (majorRoads !== undefined) {
            localVarQueryParameters['majorRoads'] = ObjectSerializer.serialize(majorRoads, "string");
        }

        if (returnHoles !== undefined) {
            localVarQueryParameters['returnHoles'] = ObjectSerializer.serialize(returnHoles, "string");
        }

        if (returnIslands !== undefined) {
            localVarQueryParameters['returnIslands'] = ObjectSerializer.serialize(returnIslands, "string");
        }

        if (simplificationFactor !== undefined) {
            localVarQueryParameters['simplificationFactor'] = ObjectSerializer.serialize(simplificationFactor, "string");
        }

        if (bandingStyle !== undefined) {
            localVarQueryParameters['bandingStyle'] = ObjectSerializer.serialize(bandingStyle, "string");
        }

        if (historicTrafficTimeBucket !== undefined) {
            localVarQueryParameters['historicTrafficTimeBucket'] = ObjectSerializer.serialize(historicTrafficTimeBucket, "string");
        }

        if (defaultAmbientSpeed !== undefined) {
            localVarQueryParameters['defaultAmbientSpeed'] = ObjectSerializer.serialize(defaultAmbientSpeed, "string");
        }

        if (ambientSpeedUnit !== undefined) {
            localVarQueryParameters['ambientSpeedUnit'] = ObjectSerializer.serialize(ambientSpeedUnit, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TravelBoundaries;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Travel boundary based on travel time.
     * @summary Get TravelBoundary By Time.
     * @param point Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format
     * @param address Starting address from where the travel boundary is calculated.
     * @param costs Travel time used to calculate the travel boundary.
     * @param costUnit Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
     * @param db Mode of commute.
     * @param country 3 character ISO code or country name.
     * @param maxOffroadDistance Maximum distance to allow travel off the road network.
     * @param maxOffroadDistanceUnit MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param destinationSrs Desired coordinate system of the travel boundary.
     * @param majorRoads Whether to include all roads in the calculation or just major roads.
     * @param returnHoles Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time
     * @param returnIslands Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time
     * @param simplificationFactor Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex
     * @param bandingStyle Style of banding to be used in the result
     * @param historicTrafficTimeBucket Whether routing calculation uses the historic traffic speeds
     * @param defaultAmbientSpeed The speed to travel when going off a network road to find the travel boundary (for all road types).
     * @param ambientSpeedUnit The unit of measure to use to calculate the ambient speed.
     */
    public async getTravelBoundaryByTime (point?: string, address?: string, costs?: string, costUnit?: string, db?: string, country?: string, maxOffroadDistance?: string, maxOffroadDistanceUnit?: string, destinationSrs?: string, majorRoads?: string, returnHoles?: string, returnIslands?: string, simplificationFactor?: string, bandingStyle?: string, historicTrafficTimeBucket?: string, defaultAmbientSpeed?: string, ambientSpeedUnit?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TravelBoundaries;  }> {
        const localVarPath = this._basePath + '/zones/v1/travelboundary/bytime';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (point !== undefined) {
            localVarQueryParameters['point'] = ObjectSerializer.serialize(point, "string");
        }

        if (address !== undefined) {
            localVarQueryParameters['address'] = ObjectSerializer.serialize(address, "string");
        }

        if (costs !== undefined) {
            localVarQueryParameters['costs'] = ObjectSerializer.serialize(costs, "string");
        }

        if (costUnit !== undefined) {
            localVarQueryParameters['costUnit'] = ObjectSerializer.serialize(costUnit, "string");
        }

        if (db !== undefined) {
            localVarQueryParameters['db'] = ObjectSerializer.serialize(db, "string");
        }

        if (country !== undefined) {
            localVarQueryParameters['country'] = ObjectSerializer.serialize(country, "string");
        }

        if (maxOffroadDistance !== undefined) {
            localVarQueryParameters['maxOffroadDistance'] = ObjectSerializer.serialize(maxOffroadDistance, "string");
        }

        if (maxOffroadDistanceUnit !== undefined) {
            localVarQueryParameters['maxOffroadDistanceUnit'] = ObjectSerializer.serialize(maxOffroadDistanceUnit, "string");
        }

        if (destinationSrs !== undefined) {
            localVarQueryParameters['destinationSrs'] = ObjectSerializer.serialize(destinationSrs, "string");
        }

        if (majorRoads !== undefined) {
            localVarQueryParameters['majorRoads'] = ObjectSerializer.serialize(majorRoads, "string");
        }

        if (returnHoles !== undefined) {
            localVarQueryParameters['returnHoles'] = ObjectSerializer.serialize(returnHoles, "string");
        }

        if (returnIslands !== undefined) {
            localVarQueryParameters['returnIslands'] = ObjectSerializer.serialize(returnIslands, "string");
        }

        if (simplificationFactor !== undefined) {
            localVarQueryParameters['simplificationFactor'] = ObjectSerializer.serialize(simplificationFactor, "string");
        }

        if (bandingStyle !== undefined) {
            localVarQueryParameters['bandingStyle'] = ObjectSerializer.serialize(bandingStyle, "string");
        }

        if (historicTrafficTimeBucket !== undefined) {
            localVarQueryParameters['historicTrafficTimeBucket'] = ObjectSerializer.serialize(historicTrafficTimeBucket, "string");
        }

        if (defaultAmbientSpeed !== undefined) {
            localVarQueryParameters['defaultAmbientSpeed'] = ObjectSerializer.serialize(defaultAmbientSpeed, "string");
        }

        if (ambientSpeedUnit !== undefined) {
            localVarQueryParameters['ambientSpeedUnit'] = ObjectSerializer.serialize(ambientSpeedUnit, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        

   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{

       // this.authentications.default.applyToRequest(localVarRequestOptions);
        localVarRequestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TravelBoundaries;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
