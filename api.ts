/**
 * Precisely APIs
 * Enhance & enrich your data, applications, business processes, and workflows with rich location, information, and identify APIs.
 *
 * OpenAPI spec version: 11.7.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import request = require('request');
import http = require('http');
import moment = require('moment');


import Promise = require('bluebird');

let defaultBasePath = 'https://api.precisely.com';



// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class oAuthCredInfo {
"access_token": string;
"tokenType": string;
"issuedAt": number;
"expiresIn": number;
"clientID": string;
"org": string;
}

export class AHJ {
    'ahjType': string;
    'ahjId': string;
    'type': string;
    'fccId': string;
    'agency': string;
    'phone': string;
    'comments': string;
    'coverage': Coverage;
    'contactPerson': ContactPerson;
    'mailingAddress': AHJmailingAddress;
}

export class AHJList {
    'ahjs': Array<AHJ>;
}

export class AHJPlusPSAPResponse {
    'ahjs': AHJList;
    'psap': PSAPResponse;
    'count': number;
}

export class AHJmailingAddress {
    'formattedAddress': string;
    'mainAddressLine': string;
    'addressLastLine': string;
    'placeName': string;
    'areaName1': string;
    'areaName2': string;
    'areaName3': string;
    'areaName4': string;
    'postCode': string;
    'postCodeExt': string;
    'country': string;
    'addressNumber': string;
    'streetName': string;
    'unitType': string;
    'unitValue': string;
}

export class AbsenteeOwner {
    'code': string;
    'value': string;
}

export class Accuracy {
    'unit': string;
    'value': string;
}

export class Address {
    'objectId': string;
    'displayName': string;
    'streetSide': string;
    'businessName': string;
    'addressLine1': string;
    'addressLine2': string;
    'addressLine3': string;
    'city': string;
    'stateProvince': string;
    'county': string;
    'postalCode': string;
    'latitude': string;
    'longitude': string;
    'status': string;
    'urbanizationName': string;
    'formattedAddress': string;
    'mainAddressLine': string;
    'addressLastLine': string;
    'placeName': string;
    'areaName1': string;
    'areaName2': string;
    'areaName3': string;
    'areaName4': string;
    'postCode': string;
    'postCodeExt': string;
    'country': string;
    'addressNumber': string;
    'streetName': string;
    'unitType': string;
    'unitValue': string;
}

export class AddressTime {
    'timestamp': string;
    'address': CommonAddress;
}

export class AddressType {
    'value': string;
    'description': string;
}

export class AddressesByBoundaryRequest {
    'preferences': AddressesPreferences;
    'geometry': CommonGeometry;
    'geometryAsText': string;
    'latitude': number;
    'longitude': number;
    'travelTime': string;
    'travelTimeUnit': string;
    'travelDistance': string;
    'travelDistanceUnit': string;
    'travelMode': string;
}

export class AddressesCount {
    'totalAddressesFound': number;
}

export class AddressesDTO {
    'pbKey': string;
    'addressNumber': string;
    'streetName': string;
    'unitType': string;
    'unitValue': string;
    'type': AddressType;
    'areaName1': string;
    'areaName2': string;
    'areaName3': string;
    'areaName4': string;
    'postCode': string;
    'postCodeExt': string;
    'country': string;
    'geometry': CommonGeometry;
    'propertyType': string;
    'propertyTypeDescription': string;
    'parentPbKey': string;
    'geoId': string;
}

export class AddressesPreferences {
    'maxCandidates': string;
    'page': string;
}

export class AddressesResponse {
    'page': string;
    'candidates': string;
    'addressList': Array<AddressesDTO>;
}

export class Age {
    'range': string;
    'value': number;
}

export class AgeTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class Area {
    'unit': string;
    'value': string;
}

export class AreaCodeInfo {
    'companyName': string;
    'ocn': string;
    'ocnCategory': string;
    'npa': string;
    'nxx': string;
    'startRange': string;
    'endRange': string;
    'lata': string;
    'areaName4': string;
}

export class AssetsAndWealthTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class AttitudesAndMotivationTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class AutomobileTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class BaseFloodElevation {
    'unit': string;
    'value': string;
}

export class BasementType {
    'code': string;
    'value': string;
}

export class BasicBoundary {
    'center': BoundaryPoint;
    'geometry': PolygonGeometry;
    'distance': Distance;
}

export class BasicBoundaryAddress {
    'center': BoundaryPoint;
    'geometry': PolygonGeometry;
    'matchedAddress': MatchedAddress;
    'distance': Distance;
}

export class Boundaries {
    'boundary': Array<Boundary>;
}

export class Boundary {
    'boundaryId': string;
    'boundaryType': string;
    'boundaryRef': string;
}

export class BoundaryBuffer {
    'bufferRelation': BufferRelation;
    'distanceToBorder': DistanceToBorder;
}

export class BoundaryPoint {
    'type': string;
    'coordinates': Array<number>;
}

export class BufferRelation {
    'description': string;
    'value': string;
}

export class BuildgCondition {
    'code': string;
    'value': string;
}

export class BuildgFeaturesSqft {
    'featureAreaSqft': string;
    'areaIndicator': string;
    'description': string;
}

export class BuildgStyle {
    'code': string;
    'value': string;
}

export class BuildgType {
    'code': string;
    'value': string;
}

export class BuildingSqftSource {
    'code': string;
    'value': string;
}

export class BusinessId {
    'type': string;
    'value': string;
}

export class CaExemptions {
    'code': string;
    'value': string;
}

export class Candidate {
    'precisionLevel': number;
    'formattedStreetAddress': string;
    'formattedLocationAddress': string;
    'identifier': string;
    'precisionCode': string;
    'sourceDictionary': string;
    'matching': FieldsMatching;
    'geometry': GeoPos;
    'address': GeocodeAddress;
    'ranges': Array<CandidateRange>;
}

export class CandidateRange {
    'placeName': string;
    'lowHouse': string;
    'highHouse': string;
    'side': CandidateRange.SideEnum;
    'oddEvenIndicator': CandidateRange.OddEvenIndicatorEnum;
    'units': Array<CandidateRangeUnit>;
    'customValues': { [key: string]: any; };
}

export namespace CandidateRange {
    export enum SideEnum {
        UNKNOWN = <any> 'UNKNOWN',
        LEFT = <any> 'LEFT',
        RIGHT = <any> 'RIGHT',
        BOTH = <any> 'BOTH'
    }
    export enum OddEvenIndicatorEnum {
        UNKNOWN = <any> 'UNKNOWN',
        BOTH = <any> 'BOTH',
        ODD = <any> 'ODD',
        EVEN = <any> 'EVEN',
        IRREGULAR = <any> 'IRREGULAR'
    }
}
export class CandidateRangeUnit {
    'placeName': string;
    'unitType': string;
    'highUnitValue': string;
    'lowUnitValue': string;
    'customValues': { [key: string]: any; };
}

export class Carrier {
    'asn': string;
    'value': string;
}

export class CarrierRouteAddressRequest {
    'addresses': Array<CommonAddress>;
    'preferences': CarrierRoutePreference;
}

export class CarrierRouteBoundaries {
    'boundary': Array<RouteBoundary>;
}

export class CarrierRoutePreference {
    'includeGeometry': string;
    'postCode': string;
}

export class CarrierRouteResponse {
    'objectId': string;
    'matchedAddress': MatchedAddress;
    'code': string;
    'state': CommonState;
    'countyFips': string;
    'postalTown': string;
    'postCode': string;
    'routeDelivery': RouteDelivery;
    'boundary': RouteBoundary;
    'boundaryRef': string;
}

export class CarrierRouteResponseList {
    'boundaries': CarrierRouteBoundaries;
    'carrierRoute': Array<CarrierRouteResponse>;
}

export class Category {
    'categoryCode': string;
    'tradeDivision': string;
    'tradeGroup': string;
    'subClass': string;
    'class': string;
}

export class CategoryMetadata {
    'code': string;
    'sic': string;
    'tradeDivision': string;
    'tradeGroup': string;
    'class': string;
    'subClass': string;
    'description': string;
}

export class Cbsa {
    'name': string;
    'code': string;
}

export class Census {
    'cbsa': Cbsa;
    'matchLevel': string;
    'matchCode': string;
    'tract': string;
    'mcd': Mcd;
}

export class Center {
    'type': string;
    'coordinates': Array<number>;
}

export class ChannelPreferencesTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class City {
    'confidence': string;
    'value': string;
}

export class CommonAddress {
    'objectId': string;
    'mainAddressLine': string;
    'addressLastLine': string;
    'placeName': string;
    'areaName1': string;
    'areaName2': string;
    'areaName3': string;
    'areaName4': string;
    'postCode': string;
    'postCodeExt': string;
    'country': string;
    'addressNumber': string;
    'streetName': string;
    'unitType': string;
    'unitValue': string;
}

export class CommonGeometry {
    'type': string;
    'coordinates': any;
}

export class CommonState {
    'fips': string;
    'code': string;
}

export class Community {
    'number': string;
    'status': Status;
}

export class CommuterPatternsTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class ConfiguredDictionaryResponse {
    'dictionaries': Array<Dictionary>;
}

export class ConsistencyCode {
    'description': string;
    'value': string;
}

export class Construction {
    'code': string;
    'value': string;
}

export class ContactDetails {
    'address': MatchedAddress;
    'propertyAddress': MatchedAddress;
}

export class ContactPerson {
    'title': string;
    'fullName': string;
    'prefix': string;
    'firstName': string;
    'lastName': string;
    'phone': string;
    'fax': string;
    'email': string;
    'comments': string;
    'additionalDetails': string;
}

export class CoolingType {
    'code': string;
    'value': string;
}

export class Cost {
    'cost': number;
    'costUnit': string;
    'geometry': DirectionGeometry;
}

export class Costs extends Array<Cost> {
}

export class CountrySupport {
    'supportedCountries': Array<string>;
    'supportedDataTypes': Array<string>;
}

export class County {
    'name': string;
    'fips': string;
}

export class Coverage {
    'area': string;
    'comments': string;
    'exceptions': string;
}

export class CrimeBoundary {
    'id': string;
    'type': string;
    'ref': string;
    'geometry': GeoRiskGeometry;
}

export class CrimeIndexTheme {
    'source': string;
    'boundaryRef': string;
    'indexVariable': Array<IndexVariable>;
}

export class CrimeRiskByAddressRequest {
    'addresses': Array<RiskAddress>;
    'preferences': CrimeRiskPreferences;
}

export class CrimeRiskByLocationRequest {
    'locations': Array<GeoRiskLocations>;
    'preferences': CrimeRiskPreferences;
}

export class CrimeRiskLocationResponse {
    'themes': Array<GeoRiskCrimeTheme>;
    'boundaries': GeoRiskBoundaries;
}

export class CrimeRiskLocationResponseList {
    'crimeRisk': Array<CrimeRiskLocationResponse>;
}

export class CrimeRiskPreferences {
    'includeGeometry': string;
    'type': string;
}

export class CrimeRiskResponse {
    'themes': Array<GeoRiskCrimeTheme>;
    'boundaries': GeoRiskBoundaries;
    'matchedAddress': MatchedAddress;
}

export class CrimeRiskResponseList {
    'crimeRisk': Array<CrimeRiskResponse>;
}

export class Crs {
    'type': string;
    'properties': Properties;
}

export class CustomObject {
    'name': string;
    'description': string;
    'properties': Array<CustomObjectMember>;
}

export class CustomObjectMember {
    'name': string;
    'input': InputParameter;
    'output': OutputParameter;
}

export class CustomPreferences {
    'fINDADDRPOINTINTERP': boolean;
    'fINDSEARCHAREA': string;
    'fINDADDRESSRANGE': boolean;
    'fINDEXPANDEDSEARCHRADIUS': string;
    'fINDALTERNATELOOKUP': string;
    'fINDSTREETCENTROID': boolean;
    'fINDFIRSTLETTEREXPANDED': boolean;
}

export class DateTimeEarthQuake {
    'date': string;
    'time': string;
}

export class Demographics {
    'boundaries': Boundaries;
    'themes': DemographicsThemesV2;
    'boundaryThemes': Array<DemographicsThemesV2>;
}

export class DemographicsAdvancedPreferences {
    'profile': string;
    'filter': string;
    'includeGeometry': string;
}

export class DemographicsAdvancedRequest {
    'preferences': DemographicsAdvancedPreferences;
    'geometry': CommonGeometry;
    'geometryAsText': string;
}

export class DemographicsThemes {
    'ageTheme': AgeTheme;
    'genderTheme': GenderTheme;
    'incomeTheme': IncomeTheme;
    'raceTheme': RaceTheme;
    'ethnicityTheme': EthnicityTheme;
    'maritalStatusTheme': MaritalStatusTheme;
    'automobileTheme': AutomobileTheme;
    'purchasingBehaviorTheme': PurchasingBehaviorTheme;
    'educationalAttainmentTheme': EducationalAttainmentTheme;
    'financialProductsTheme': FinancialProductsTheme;
    'commuterPatternsTheme': CommuterPatternsTheme;
    'attitudesAndMotivationTheme': AttitudesAndMotivationTheme;
    'channelPreferencesTheme': ChannelPreferencesTheme;
    'householdSizeTheme': HouseholdSizeTheme;
}

export class DemographicsThemesV2 {
    'boundaryId': string;
    'populationTheme': PopulationTheme;
    'raceAndEthnicityTheme': RaceAndEthnicityTheme;
    'healthTheme': HealthTheme;
    'educationTheme': EducationTheme;
    'incomeTheme': IncomeThemeV2;
    'assetsAndWealthTheme': AssetsAndWealthTheme;
    'householdsTheme': HouseholdsTheme;
    'housingTheme': HousingTheme;
    'employmentTheme': EmploymentTheme;
    'expenditureTheme': ExpenditureTheme;
    'supplyAndDemandTheme': SupplyAndDemandTheme;
}

export class Depth {
    'unit': string;
    'value': number;
}

export class DeviceStatusNetwork {
    'carrier': string;
    'callType': string;
    'locAccuracySupport': string;
    'nationalNumber': string;
    'country': GeoLocationFixedLineCountry;
}

export class Dictionary {
    'vintage': string;
    'source': string;
    'description': string;
    'countrySupportInfos': Array<CountrySupport>;
}

export class DirectionGeometry {
    'type': string;
    'coordinates': Array<Array<Array<Array<number>>>>;
}

export class Distance {
    'unit': string;
    'value': string;
}

export class DistanceToBorder {
    'unit': string;
    'value': string;
}

export class DistanceToFloodHazardAddressRequest {
    'addresses': Array<RiskAddress>;
    'preferences': FloodHazardPreferences;
}

export class DistanceToFloodHazardLocationRequest {
    'locations': Array<GeoRiskLocations>;
    'preferences': FloodHazardPreferences;
}

export class DistanceToFloodHazardLocationResponse {
    'waterBodies': Array<WaterBodyLocationResponse>;
}

export class DistanceToFloodHazardResponse {
    'waterBodies': Array<WaterBodyResponse>;
}

export class DistrictType {
    'description': string;
    'value': string;
}

export class DomesticUltimateBusiness {
    'name': string;
    'address': Address;
}

export class EarthquakeEvent {
    'dateTime': DateTimeEarthQuake;
    'seismicRegionNumber': number;
    'depth': Depth;
    'magnitude': Magnitude;
    'cause': string;
    'culturalEffect': string;
    'intensity': number;
    'diastrophism': string;
    'miscPhenomena': string;
    'location': EarthquakeLocation;
}

export class EarthquakeEventsResponse {
    'event': Array<EarthquakeEvent>;
}

export class EarthquakeHistory {
    'stateCode': string;
    'county': string;
    'postCode': string;
    'events': EarthquakeEventsResponse;
}

export class EarthquakeLocation {
    'type': string;
    'coordinates': Array<number>;
}

export class EarthquakeRiskByAddressRequest {
    'addresses': Array<RiskAddress>;
    'preferences': EarthquakeRiskPreferences;
}

export class EarthquakeRiskByLocationRequest {
    'locations': Array<GeoRiskLocations>;
    'preferences': EarthquakeRiskPreferences;
}

export class EarthquakeRiskLocationResponse {
    'riskLevel': string;
    'eventsCount': EventsCount;
    'grid': Grid;
}

export class EarthquakeRiskLocationResponseList {
    'earthquakeRisk': Array<EarthquakeRiskLocationResponse>;
}

export class EarthquakeRiskPreferences {
    'includeGeometry': string;
    'richterValue': string;
}

export class EarthquakeRiskResponse {
    'riskLevel': string;
    'eventsCount': EventsCount;
    'grid': Grid;
    'matchedAddress': MatchedAddress;
}

export class EarthquakeRiskResponseList {
    'earthquakeRisk': Array<EarthquakeRiskResponse>;
}

export class Education {
    'name': string;
    'degree': string;
    'end': End;
}

export class EducationTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class EducationalAttainmentTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class Email {
    'label': string;
    'value': string;
    'md5': string;
    'sha256': string;
}

export class EmployeeCount {
    'inLocalBranch': string;
    'inOrganization': string;
}

export class Employment {
    'name': string;
    'current': boolean;
    'title': string;
    'start': Start;
    'end': End;
}

export class EmploymentTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class End {
    'year': number;
    'month': number;
    'day': number;
}

export class ErrorCode {
    'errorCode': string;
    'errorDescription': string;
}

export class ErrorInfo {
    'errors': Array<ErrorCode>;
}

export class EthnicityTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class EventsCount {
    'total': string;
    'r0': string;
    'r1': string;
    'r2': string;
    'r3': string;
    'r4': string;
    'r5': string;
    'r6': string;
    'r7': string;
    'r0Ge': string;
    'r1Ge': string;
    'r2Ge': string;
    'r3Ge': string;
    'r4Ge': string;
    'r5Ge': string;
    'r6Ge': string;
    'r7Ge': string;
}

export class ExpenditureTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class ExteriorWalls {
    'code': string;
    'value': string;
}

export class Field {
    'value': string;
    'description': string;
}

export class FieldV2 {
    'value': string;
    'name': string;
    'description': string;
}

export class FieldsMatching {
    'matchOnAddressNumber': boolean;
    'matchOnPostCode1': boolean;
    'matchOnPostCode2': boolean;
    'matchOnAreaName1': boolean;
    'matchOnAreaName2': boolean;
    'matchOnAreaName3': boolean;
    'matchOnAreaName4': boolean;
    'matchOnAllStreetFields': boolean;
    'matchOnStreetName': boolean;
    'matchOnStreetType': boolean;
    'matchOnStreetDirectional': boolean;
    'matchOnPlaceName': boolean;
    'matchOnInputFields': boolean;
}

export class FinancialProductsTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class FireDepartment {
    'name': string;
    'type': string;
    'numberOfStations': number;
    'administrativeOfficeOnly': boolean;
    'contactDetails': FireDepartmentContactDetails;
}

export class FireDepartmentContactDetails {
    'address': MatchedAddress;
    'phone': string;
    'fax': string;
}

export class FireEvent {
    'fireStartDate': string;
    'fireEndDate': string;
    'fireName': string;
    'area': Area;
    'agency': string;
}

export class FireEventsResponse {
    'event': Array<FireEvent>;
}

export class FireHistory {
    'stateCode': string;
    'postCode': string;
    'events': FireEventsResponse;
}

export class FireRiskByAddressRequest {
    'addresses': Array<RiskAddress>;
}

export class FireRiskByLocationRequest {
    'locations': Array<GeoRiskLocations>;
}

export class FireRiskLocationResponse {
    'objectId': string;
    'state': CommonState;
    'fireShed': FireShed;
}

export class FireRiskLocationResponseList {
    'fireRisk': Array<FireRiskLocationResponse>;
}

export class FireRiskResponse {
    'objectId': string;
    'state': CommonState;
    'fireShed': FireShed;
    'matchedAddress': MatchedAddress;
}

export class FireRiskResponseList {
    'fireRisk': Array<FireRiskResponse>;
}

export class FireShed {
    'id': number;
    'risk': Risk;
}

export class FireStation {
    'numWithinDepartment': string;
    'locationReference': string;
    'travelDistance': Distance;
    'travelTime': Time;
    'contactDetails': FireStationContactDetails;
    'fireDepartment': FireDepartment;
    'geometry': Geometry;
}

export class FireStationContactDetails {
    'address': MatchedAddress;
    'phone': string;
}

export class FireStations {
    'fireStation': Array<FireStation>;
    'matchedAddress': MatchedAddress;
}

export class FireStationsLocation {
    'fireStation': Array<FireStation>;
}

export class FloodBoundary {
    'id': string;
    'geometry': GeoRiskGeometry;
}

export class FloodHazardPreferences {
    'searchDistanceUnit': string;
    'searchDistance': string;
    'waterBodyType': string;
    'maxCandidates': string;
}

export class FloodRiskByAddressRequest {
    'addresses': Array<RiskAddress>;
    'preferences': FloodRiskPreferences;
}

export class FloodRiskByLocationRequest {
    'locations': Array<GeoRiskLocations>;
    'preferences': FloodRiskPreferences;
}

export class FloodRiskLocationResponse {
    'objectId': string;
    'state': CommonState;
    'floodZone': FloodZone;
    'community': Community;
    'boundary': FloodBoundary;
}

export class FloodRiskLocationResponseList {
    'floodRisk': Array<FloodRiskLocationResponse>;
}

export class FloodRiskPreferences {
    'includeGeometry': string;
    'includeZoneDesc': string;
}

export class FloodRiskResponse {
    'objectId': string;
    'state': CommonState;
    'floodZone': FloodZone;
    'community': Community;
    'boundary': FloodBoundary;
    'matchedAddress': MatchedAddress;
}

export class FloodRiskResponseList {
    'floodRisk': Array<FloodRiskResponse>;
}

export class FloodZone {
    'code': string;
    'areaType': string;
    'riskLevel': string;
    'primaryZone': PrimaryZone;
    'baseFloodElevation': BaseFloodElevation;
    'additionalInfo': string;
}

export class Foundation {
    'code': string;
    'value': string;
}

export class FreeOrReducedPriceLunches {
    'freeLunchesCount': string;
    'reducedPriceLunchedCount': string;
    'totalCount': string;
}

export class GarageType {
    'code': string;
    'value': string;
}

export class GenderTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class GeoEnrichMetadataResponse {
    'sic': Array<SicMetadata>;
    'category': Array<CategoryMetadata>;
}

export class GeoEnrichResponse {
    'page': string;
    'candidates': string;
    'totalMatchingCandidates': string;
    'poi': Array<POIPlaces>;
    'matchedAddress': MatchedAddress;
}

export class GeoLocationAccessPoint {
    'geometry': Geometry;
    'accuracy': Accuracy;
}

export class GeoLocationCountry {
    'code': string;
    'confidence': string;
    'value': string;
}

export class GeoLocationFixedLine {
    'geometry': Geometry;
    'accuracy': Accuracy;
    'deviceId': string;
    'country': GeoLocationFixedLineCountry;
}

export class GeoLocationFixedLineCountry {
    'code': string;
    'value': string;
}

export class GeoLocationIpAddr {
    'geometry': Geometry;
    'accuracy': Accuracy;
    'ipInfo': IpInfo;
}

export class GeoLocationPlace {
    'continent': string;
    'country': GeoLocationCountry;
    'consistencyCode': ConsistencyCode;
    'region': string;
    'state': GeoLocationState;
    'city': City;
    'postCode': string;
    'postCodeConfidence': string;
}

export class GeoLocationState {
    'confidence': string;
    'value': string;
}

export class GeoPos {
    'type': string;
    'coordinates': Array<number>;
    'crs': Crs;
}

export class GeoPostGeometry {
    'type': string;
    'coordinates': Array<Array<Array<Array<number>>>>;
}

export class GeoRiskBoundaries {
    'boundary': Array<CrimeBoundary>;
}

export class GeoRiskCrimeTheme {
    'crimeIndexTheme': CrimeIndexTheme;
}

export class GeoRiskGeometry {
    'type': string;
    'coordinates': Array<Array<Array<number>>>;
}

export class GeoRiskLocations {
    'geometry': Geometry;
    'objectId': string;
}

export class GeoRouteResponse {
    'directionsStyle': string;
    'distance': number;
    'distanceUnit': string;
    'language': string;
    'timeUnit': string;
    'time': number;
    'geometry': RouteGeometry;
    'routeDirections': RouteDirections;
    'intermediatePoints': IntermediatePoints;
}

export class GeoTaxLocations {
    'geometry': Geometry;
    'purchaseAmount': string;
    'objectId': string;
}

export class GeoTaxRateLocations {
    'geometry': Geometry;
    'objectId': string;
}

export class GeoZoneGeometry {
    'type': string;
    'coordinates': Array<number>;
}

export class GeocodeAddress {
    'mainAddressLine': string;
    'addressLastLine': string;
    'placeName': string;
    'areaName1': string;
    'areaName2': string;
    'areaName3': string;
    'areaName4': string;
    'postCode1': string;
    'postCode2': string;
    'country': string;
    'addressNumber': string;
    'streetName': string;
    'unitType': string;
    'unitValue': string;
    'customFields': { [key: string]: any; };
}

export class GeocodeCapabilitiesResponse {
    'serviceName': string;
    'serviceDescription': string;
    'coreVersion': string;
    'supportedCountries': Array<string>;
    'supportedOperations': Array<Operation>;
    'customObjects': Array<CustomObject>;
}

export class GeocodeCustomPreferences {
    'fALLBACKTOWORLD': boolean;
    'uSEADDRESSPOINTINTERPOLATION': boolean;
    'uSECENTERLINEOFFSET': string;
    'cENTERLINEOFFSET': string;
}

export class GeocodePreferences {
    'returnAllCandidateInfo': boolean;
    'fallbackToGeographic': boolean;
    'fallbackToPostal': boolean;
    'maxReturnedCandidates': string;
    'streetOffset': string;
    'cornerOffset': string;
    'matchMode': string;
    'clientLocale': string;
    'clientCoordSysName': string;
    'streetOffsetUnits': string;
    'cornerOffsetUnits': string;
    'mustMatchFields': FieldsMatching;
    'returnFieldsDescriptor': ReturnFieldsDescriptor;
    'outputRecordType': string;
    'customPreferences': GeocodeCustomPreferences;
    'preferredDictionaryOrders': Array<string>;
}

export class GeocodeRequest {
    /**
    * Type
    */
    'type': string;
    'preferences': GeocodePreferences;
    'addresses': Array<GeocodeRequestAddress>;
}

export class GeocodeRequestAddress {
    'mainAddressLine': string;
    'addressLastLine': string;
    'placeName': string;
    'areaName1': string;
    'areaName2': string;
    'areaName3': string;
    'areaName4': string;
    'postCode1': string;
    'postCode2': string;
    'country': string;
    'addressNumber': string;
    'streetName': string;
    'unitType': string;
    'unitValue': string;
}

export class GeocodeServiceResponse {
    'objectId': string;
    'totalPossibleCandidates': number;
    'totalMatches': number;
    'candidates': Array<Candidate>;
}

export class GeocodeServiceResponseList {
    'responses': Array<GeocodeServiceResponse>;
}

export class Geometry {
    'type': string;
    'coordinates': Array<number>;
}

export class GeosearchLocation {
    'address': MatchedAddress;
    'distance': Distance;
    'geometry': Geometry;
    'totalUnitCount': number;
    'ranges': Array<TypeaheadRange>;
}

export class GeosearchLocations {
    'location': Array<GeosearchLocation>;
}

export class GetCityStateProvinceAPIInput {
    'row': Array<GetCityStateProvinceAPIInputRow>;
}

export class GetCityStateProvinceAPIInputRow {
    /**
    * These fields are returned, unmodified, in the user_fields section of the response.
    */
    'userFields': Array<ValidateMailingAddressInputRowUserFields>;
    /**
    * The validated ZIP Code or postal code.
    */
    'postalCode': string;
}

export class GetCityStateProvinceAPIOptions {
    /**
    * Output VanityCity.
    */
    'outputVanityCity': string;
    /**
    * PerformCanadianProcessing.
    */
    'performCanadianProcessing': string;
    /**
    * MaximumResults.
    */
    'maximumResults': string;
    /**
    * PerformUSProcessing.
    */
    'performUSProcessing': string;
}

export class GetCityStateProvinceAPIOutput {
    /**
    * These fields are returned, unmodified, in the user_fields section of the response.
    */
    'userFields': Array<ValidateMailingAddressInputRowUserFields>;
    /**
    * The validated ZIP Code or postal code.
    */
    'postalCode': string;
    /**
    * City
    */
    'city': string;
    /**
    * City.Type
    */
    'cityType': string;
    /**
    * The state or province.
    */
    'stateProvince': string;
    /**
    * Reports the success or failure of the match attempt.
    */
    'status': string;
    /**
    * Reason for failure, if there is one.
    */
    'statusCode': string;
    /**
    * Description of the problem, if there is one.
    */
    'statusDescription': string;
}

export class GetCityStateProvinceAPIRequest {
    'options': GetCityStateProvinceAPIOptions;
    'input': GetCityStateProvinceAPIInput;
}

export class GetCityStateProvinceAPIResponse {
    'output': Array<GetCityStateProvinceAPIOutput>;
}

export class GetPostalCodesAPIInput {
    'row': Array<GetPostalCodesAPIInputRow>;
}

export class GetPostalCodesAPIInputRow {
    /**
    * These fields are returned, unmodified, in the user_fields section of the response.
    */
    'userFields': Array<ValidateMailingAddressInputRowUserFields>;
    /**
    * The city name.
    */
    'city': string;
    /**
    * The state or province.
    */
    'stateProvince': string;
}

export class GetPostalCodesAPIOptions {
    /**
    * Output CityType.
    */
    'outputCityType': string;
    /**
    * Output VanityCity.
    */
    'outputVanityCity': string;
}

export class GetPostalCodesAPIOutput {
    /**
    * These fields are returned, unmodified, in the user_fields section of the response.
    */
    'userFields': Array<ValidateMailingAddressInputRowUserFields>;
    /**
    * The validated ZIP Code or postal code.
    */
    'postalCode': string;
    /**
    * City.Type
    */
    'cityType': string;
    /**
    * Reports the success or failure of the match attempt.
    */
    'status': string;
    /**
    * Reason for failure, if there is one.
    */
    'statusCode': string;
    /**
    * Description of the problem, if there is one.
    */
    'statusDescription': string;
}

export class GetPostalCodesAPIRequest {
    'options': GetPostalCodesAPIOptions;
    'input': GetPostalCodesAPIInput;
}

export class GetPostalCodesAPIResponse {
    'output': Array<GetPostalCodesAPIOutput>;
}

export class GlobalUltimateBusiness {
    'name': string;
    'address': Address;
}

export class GradeLevelsTaught {
    'pk': string;
    'kg': string;
    'first': string;
    'second': string;
    'third': string;
    'fourth': string;
    'fifth': string;
    'sixth': string;
    'seventh': string;
    'eighth': string;
    'ninth': string;
    'tenth': string;
    'eleventh': string;
    'twelfth': string;
}

export class Greatschools {
    'gsId': string;
    'url': string;
    'rating': string;
}

export class Grid {
    'code': string;
    'geometry': GeoRiskGeometry;
}

export class HealthTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class HeatingType {
    'code': string;
    'value': string;
}

export class HouseholdSizeTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class HouseholdsTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class HousingTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class IPDTaxByAddressBatchRequest {
    'addresses': Array<TaxRateAddress>;
    'preferences': Preferences;
}

export class IPDTaxJurisdiction {
    'state': TaxState;
    'county': TaxCounty;
    'place': TaxPlace;
}

export class Identity {
    'fullName': string;
    'ageRange': string;
    'gender': string;
    'location': string;
    'coreId': string;
    'pbKey': string;
    'details': IdentityDetail;
}

export class IdentityDemographics {
    'maritalStatus': string;
    'occupation': string;
}

export class IdentityDetail {
    'name': IdentityName;
    'age': Age;
    'demographics': IdentityDemographics;
    'photos': Array<Photo>;
    'profiles': Profiles;
    'urls': Array<Url>;
    'education': Array<Education>;
    'employment': Array<Employment>;
}

export class IdentityName {
    'given': string;
    'family': string;
}

export class IdentityResponse {
    'identities': Array<Identity>;
}

export class IncomeTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class IncomeThemeV2 {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class IndexVariable {
    'name': string;
    'score': string;
    'category': string;
    'percentile': string;
    'stateScore': string;
}

export class IndividualValueVariable {
    'name': string;
    'description': string;
    'value': string;
}

export class IndividualValueVariableV2 {
    'name': string;
    'description': string;
    'year': string;
    'value': string;
}

export class InputParameter {
    'name': string;
    'description': string;
    'type': string;
    'defaultValue': string;
    'lowBoundary': string;
    'highBoundary': string;
    'allowedValuesWithDescriptions': { [key: string]: any; };
}

export class Interest {
    'name': string;
    'id': string;
    'affinity': string;
    'parentIds': Array<string>;
    'category': string;
}

export class IntermediatePoints {
    'type': string;
    'coordinates': Array<Array<number>>;
}

export class Intersection {
    'distance': Unit;
    'driveTime': Unit;
    'driveDistance': Unit;
    'geometry': CommonGeometry;
    'roads': Array<Road>;
}

export class IntersectionResponse {
    'intersection': Array<Intersection>;
    'matchedAddress': MatchedAddress;
}

export class IpInfo {
    'ipAddress': string;
    'proxy': Proxy;
    'network': Network;
    'place': GeoLocationPlace;
}

export class Ipd {
    'id': string;
    'districtName': string;
    'districtType': DistrictType;
    'taxCodeDescription': string;
    'effectiveDate': string;
    'expirationDate': string;
    'boundaryBuffer': BoundaryBuffer;
    'rates': Array<Rate>;
}

export class KeyLookupRequest {
    'type': string;
    'preferences': GeocodePreferences;
    'keys': Array<Keys>;
}

export class Keys {
    'objectId': string;
    'country': string;
    'value': string;
}

export class LandUse {
    'code': string;
    'value': string;
}

export class LatLongFields {
    'matchCode': string;
    'matchLevel': string;
    'streetMatchCode': string;
    'streetMatchLevel': string;
    'geometry': Geometry;
}

export class LifeStyleTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class Location {
    'label': string;
    'city': string;
    'region': string;
    'regionCode': string;
    'country': string;
    'countryCode': string;
    'formatted': string;
}

export class LocationTime {
    'geometry': Geometry;
    'objectId': string;
    'timestamp': string;
}

export class Magnitude {
    'value': number;
    'scale': string;
    'bodyWave': number;
    'surfaceWave': number;
}

export class MaritalStatusTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class Match {
    'confidence': string;
    'percentGeocode': string;
    'precisionLevel': string;
    'locationCode': string;
    'matchCode': string;
}

export class MatchedAddress {
    'formattedAddress': string;
    'mainAddressLine': string;
    'addressLastLine': string;
    'placeName': string;
    'areaName1': string;
    'areaName2': string;
    'areaName3': string;
    'areaName4': string;
    'postCode': string;
    'postCodeExt': string;
    'country': string;
    'addressNumber': string;
    'streetName': string;
    'unitType': string;
    'unitValue': string;
}

export class Matrix {
    'distance': number;
    'distanceUnit': string;
    'endPoint': StartEndPoint;
    'startPoint': StartEndPoint;
    'time': number;
    'timeUnit': string;
}

export class Mcd {
    'name': string;
    'code': string;
}

export class Network {
    'connectionFromHome': string;
    'organization': string;
    'carrier': Carrier;
    'organizationType': OrganizationType;
    'connectionType': string;
    'lineSpeed': string;
    'ipRouteType': string;
    'hostingFacility': string;
}

export class Operation {
    'name': string;
    'requiredInputs': Array<InputParameter>;
    'optionalInputs': Array<InputParameter>;
    'outputs': Array<OutputParameter>;
    'supportLevels': Array<SupportLevel>;
}

export class OrganizationType {
    'naicsCode': string;
    'isicCode': string;
    'value': string;
}

export class OutputParameter {
    'name': string;
    'description': string;
    'type': string;
}

export class Owners {
    'firstName': string;
    'middleName': string;
    'lastName': string;
}

export class PBKeyAddressRequest {
    'addresses': Array<CommonAddress>;
}

export class PBKeyResponse {
    'key': string;
    'matchedAddress': MatchedAddress;
}

export class PBKeyResponseList {
    'pbkey': Array<PbKey>;
}

export class POIBoundaryAddressRequest {
    'addresses': Array<CommonAddress>;
    'preferences': PoiBoundaryPreferences;
}

export class POIBoundaryLocationRequest {
    'locations': Array<POIBoundaryLocations>;
    'preferences': PoiBoundaryPreferences;
}

export class POIBoundaryLocations {
    'geometry': Geometry;
    'objectId': string;
}

export class POIBoundaryResponse {
    'poiBoundary': Array<PoiBoundary>;
}

export class POIByGeometryRequest {
    'name': string;
    'type': string;
    'categoryCode': string;
    'sicCode': string;
    'maxCandidates': string;
    'fuzzyOnName': string;
    'page': string;
    'matchMode': string;
    'specificMatchOn': string;
    'geometry': CommonGeometry;
    'geometryAsText': string;
}

export class POIPlaces {
    'id': string;
    'poiId': string;
    'pbkey': string;
    'parentPbkey': string;
    'geocodeConfidence': string;
    'ceoName': string;
    'ceoTitle': string;
    'name': string;
    'brandName': string;
    'tradeName': string;
    'franchiseName': string;
    'open24Hours': string;
    'distance': Distance;
    'businessId': BusinessId;
    'relevanceScore': string;
    'contactDetails': PoiContactDetails;
    'poiClassification': PoiClassification;
    'salesVolume': Array<SalesVolume>;
    'employeeCount': EmployeeCount;
    'yearStart': string;
    'goodsAgentCode': string;
    'goodsAgentCodeDescription': string;
    'legalStatusCode': string;
    'organizationStatusCode': string;
    'organizationStatusCodeDescription': string;
    'subsidaryIndicator': string;
    'subsidaryIndicatorDescription': string;
    'parentBusiness': ParentBusiness;
    'domesticUltimateBusiness': DomesticUltimateBusiness;
    'globalUltimateIndicator': string;
    'globalUltimateBusiness': GlobalUltimateBusiness;
    'familyMembers': string;
    'hierarchyCode': string;
    'tickerSymbol': string;
    'exchangeName': string;
    'geometry': Geometry;
}

export class PSAPResponse {
    'psapId': string;
    'fccId': string;
    'type': string;
    'count': number;
    'agency': string;
    'phone': string;
    'county': County;
    'coverage': Coverage;
    'contactPerson': ContactPerson;
    'siteDetails': SiteDetails;
    'mailingAddress': MatchedAddress;
}

export class Parcel {
    'id': string;
    'censusCode': string;
    'pbkey': string;
    'address': MatchedAddress;
}

export class ParcelBoundary {
    'objectId': string;
    'apn': string;
    'pid': string;
    'center': Center;
    'countyfips': string;
    'geometry': CommonGeometry;
    'parcelList': Array<Parcel>;
    'adjacentParcelBoundary': Array<ParcelBoundary>;
    'matchedAddress': MatchedAddress;
}

export class ParentBusiness {
    'name': string;
    'address': Address;
}

export class PbKey {
    'objectId': string;
    'key': string;
    'matchedAddress': MatchedAddress;
}

export class PhoneVerification {
    'phoneNumber': string;
    'locatable': string;
    'network': DeviceStatusNetwork;
    'privacyConsentRequired': string;
}

export class Photo {
    'label': string;
    'value': string;
}

export class PlaceByLocations {
    'location': Array<PlaceByLocationsLocation>;
}

export class PlaceByLocationsLocation {
    'place': PlaceLocation;
}

export class PlaceLocation {
    'level': string;
    'levelName': string;
    'name': Array<PlaceLocationName>;
}

export class PlaceLocationName {
    'langType': string;
    'langISOCode': string;
    'value': string;
}

export class Poi {
    'id': string;
    'name': string;
    'brandName': string;
    'tradeName': string;
    'franchiseName': string;
    'open24Hours': string;
    'contactDetails': ContactDetails;
    'poiClassification': PoiClassification;
    'employeeCount': EmployeeCount;
    'organizationStatusCode': string;
    'organizationStatusCodeDescription': string;
    'parentBusiness': ParentBusiness;
    'tickerSymbol': string;
    'exchangeName': string;
}

export class PoiBoundary {
    'objectId': string;
    'center': GeoZoneGeometry;
    'countyfips': string;
    'geometry': CommonGeometry;
    'poiList': Array<Poi>;
    'matchedAddress': MatchedAddress;
    'id': string;
}

export class PoiBoundaryPreferences {
    'categoryCode': string;
    'sicCode': string;
    'naicsCode': string;
}

export class PoiClassification {
    'sic': Sic;
    'category': Category;
    'alternateIndustryCode': string;
}

export class PoiContactDetails {
    'address': Address;
    'phone': string;
    'fax': string;
    'countryAccessCode': string;
    'email': string;
    'url': string;
}

export class PoiCount {
    'totalPoisFound': number;
}

export class PoiCountRequest {
    'name': string;
    'type': string;
    'categoryCode': string;
    'sicCode': string;
    'fuzzyOnName': string;
    'geometry': CommonGeometry;
    'geometryAsText': string;
}

export class Points {
    'objectId': string;
    'country': string;
    'geometry': GeoPos;
}

export class Pois {
    'page': string;
    'candidates': string;
    'totalMatchingCandidates': string;
    'poi': Array<Poi>;
    'matchedAddress': MatchedAddress;
}

export class PolygonGeometry {
    'type': string;
    'coordinates': Array<Array<Array<number>>>;
}

export class PopulationTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class PreferencTimeZone {
    'matchMode': string;
}

export class Preferences {
    'fallbackToGeographic': string;
    'useGeoTaxAuxiliaryFile': string;
    'matchMode': string;
    'latLongOffset': string;
    'squeeze': string;
    'latLongFormat': string;
    'defaultBufferWidth': string;
    'distanceUnits': string;
    'outputCasing': string;
    'returnCensusFields': string;
    'returnLatLongFields': string;
    'customPreferences': CustomPreferences;
}

export class PrimaryZone {
    'code': string;
    'description': string;
}

export class Profile {
    'username': string;
    'userid': string;
    'url': string;
    'bio': string;
    'service': string;
    'followers': number;
    'following': number;
}

export class Profiles {
    'twitter': Profile;
    'linkedin': Profile;
}

export class Properties {
    'name': string;
}

export class PropertyAttributes {
    'pbKey': string;
    'propApn': string;
    'propType': string;
    'propSqFt': string;
    'buildgSqFt': string;
    'buildgSqSource': BuildingSqftSource;
    'landUse': LandUse;
    'construction': Construction;
    'roofCoverType': RoofCoverType;
    'subdivision': string;
    'geometry': Geometry;
    'builtYear': string;
    'bedrooms': string;
    'baths': string;
    'pool': string;
    'firePlace': string;
    'mobileHome': string;
    'heatingType': HeatingType;
    'coolingType': CoolingType;
    'assessedValue': string;
    'marketValue': string;
    'appraisedValue': string;
    'taxAmount': string;
    'taxExemptions': Array<TaxExemption>;
    'caExemptions': CaExemptions;
    'stories': Stories;
    'salesDate': string;
    'priorSaleDate': string;
    'priorSalesPrice': string;
    'livingSqft': string;
    'roofFrameType': RoofFrameType;
    'foundation': Foundation;
    'buildgCondition': BuildgCondition;
    'buildgCount': string;
    'buildgUnitNo': string;
    'buildgFeaturesSqft': Array<BuildgFeaturesSqft>;
    'businessName': string;
    'taxAddress': string;
    'vacancy': Vacancy;
    'owners': Array<Owners>;
    'appraisedValueImp': string;
    'assessedValueImp': string;
    'buildgType': BuildgType;
    'basementType': BasementType;
    'effectiveBuiltYear': string;
    'exteriorWalls': ExteriorWalls;
    'garageType': GarageType;
    'lastUpdated': string;
    'marketValueImp': string;
    'absenteeOwner': AbsenteeOwner;
    'parkingSqFt': string;
    'replacementCost': string;
    'roofShapeType': RoofShapeType;
    'buildgStyle': BuildgStyle;
    'basementSqFt': string;
}

export class PropertyInfoAddressRequest {
    'preferences': PropertyInfoPreferences;
    'addresses': Array<MatchedAddress>;
}

export class PropertyInfoPreferences {
    'attributes': string;
}

export class PropertyInfoResponse {
    'objectId': string;
    'propertyAttributes': PropertyAttributes;
    'matchedAddress': MatchedAddress;
}

export class PropertyInfoResponses {
    'propertyInfoResponses': Array<PropertyInfoResponse>;
}

export class Proxy {
    'anonymizerStatus': string;
    'level': string;
    'lastDetected': string;
    'type': string;
}

export class PurchasingBehaviorTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class RaceAndEthnicityTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class RaceTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class RangeVariable {
    'count': string;
    'order': string;
    'name': string;
    'description': string;
    'field': Array<Field>;
}

export class RangeVariableV2 {
    'count': string;
    'order': string;
    'name': string;
    'alias': string;
    'description': string;
    'baseVariable': string;
    'year': string;
    'field': Array<FieldV2>;
}

export class Rate {
    'name': string;
    'format': string;
    'formatDescription': string;
    'value': string;
}

export class RateCenterResponse {
    'id': string;
    'name': string;
    'alternateName': string;
    'areaName1': string;
    'geometry': Geometry;
    'areaCodeInfoList': Array<AreaCodeInfo>;
    'matchedAddress': MatchedAddress;
    'match': Match;
    'county': County;
    'count': number;
    'productCode': string;
}

export class ReturnFieldsDescriptor {
    'returnAllCustomFields': boolean;
    'returnMatchDescriptor': boolean;
    'returnStreetAddressFields': boolean;
    'returnUnitInformation': boolean;
    'returnedCustomFieldKeys': Array<string>;
}

export class ReverseGeocodeRequest {
    'preferences': Preferences;
    'points': Array<Points>;
}

export class Risk {
    'type': string;
    'description': string;
    'risk50Rating': number;
    'frequency': number;
    'nonburn': string;
    'pastFires': number;
    'severity': number;
    'continuity': string;
    'adjustment': string;
    'aspect': string;
    'crownFire': string;
    'vegetation': string;
    'foehn': string;
    'golfCourse': string;
    'roadDist': string;
    'slope': string;
    'waterDist': string;
    'tier': string;
    'tierDescription': string;
    'distanceToFireStation': number;
}

export class RiskAddress {
    'objectId': string;
    'formattedAddress': string;
    'mainAddressLine': string;
    'addressLastLine': string;
    'placeName': string;
    'areaName1': string;
    'areaName2': string;
    'areaName3': string;
    'areaName4': string;
    'postCode': string;
    'postCodeExt': string;
    'country': string;
    'addressNumber': string;
    'streetName': string;
    'unitType': string;
    'unitValue': string;
}

export class Road {
    'roadClass': string;
    'name': string;
    'type': string;
}

export class RoofCoverType {
    'code': string;
    'value': string;
}

export class RoofFrameType {
    'code': string;
    'value': string;
}

export class RoofShapeType {
    'code': string;
    'value': string;
}

export class RoofType {
    'code': string;
    'value': string;
}

export class RouteBoundary {
    'id': string;
    'type': string;
    'ref': string;
    'geometry': GeoPostGeometry;
}

export class RouteDelivery {
    'individualValueVariable': Array<IndividualValueVariable>;
}

export class RouteDirection {
    'distance': number;
    'distanceUnit': string;
    'timeUnit': string;
    'time': number;
    'instruction': string;
    'directionGeometry': RouteGeometry;
}

export class RouteDirections extends Array<RouteDirection> {
}

export class RouteGeometry {
    'type': string;
    'coordinates': Array<Array<number>>;
}

export class SalesTax {
    'totalTax': number;
    'totalTaxRate': number;
    'totalTaxAmount': number;
    'stateTax': number;
    'stateTaxRate': number;
    'stateTaxAmount': number;
    'countyTax': number;
    'countyTaxRate': number;
    'countyTaxAmount': number;
    'municipalTax': number;
    'municipalTaxRate': number;
    'municipalTaxAmount': number;
    'spdsTax': Array<SpecialPurposeDistrictTaxRate>;
    'specialTaxRulesApplied': boolean;
    'specialTaxRulesDescriptor': string;
}

export class SalesTaxRate {
    'totalTaxRate': number;
    'stateTaxRate': number;
    'countyTaxRate': number;
    'municipalTaxRate': number;
    'spdsTax': Array<SpecialPurposeDistrictTaxRate>;
}

export class SalesVolume {
    'currencyCode': string;
    'worldBaseCurrencyCode': string;
    'value': string;
}

export class School {
    'id': string;
    'name': string;
    'assigned': string;
    'phone': string;
    'website': string;
    'addressType': string;
    'address': Address;
    'lowestGrade': string;
    'highestGrade': string;
    'schoolType': string;
    'schoolTypeDesc': string;
    'schoolSubType': string;
    'schoolSubTypeDesc': string;
    'gender': string;
    'genderDesc': string;
    'educationLevel': string;
    'educationLevelDesc': string;
    'greatschools': Greatschools;
    'ncesSchoolId': string;
    'ncesDistrictId': string;
    'ncesDataYear': string;
    'schoolRanking': Array<SchoolRanking>;
    'students': string;
    'teachers': string;
    'status': string;
    'studentTeacherRatio': string;
    'choice': string;
    'coextensiv': string;
    'schoolDistricts': SchoolDistrict;
    'schoolProfile': SchoolProfile;
    'gradeLevelsTaught': GradeLevelsTaught;
    'distance': Distance;
    'geometry': Geometry;
}

export class SchoolDistrict {
    'ncesDistrictId': string;
    'name': string;
    'totalSchools': string;
    'districtType': string;
    'metro': string;
    'areaInSqM': string;
    'supervisoryUnionId': string;
    'districtEnrollment': string;
    'districtUrl': string;
}

export class SchoolProfile {
    'blueRibbon': string;
    'internationalBaccalaureate': string;
    'titleI': string;
    'expensePerStudent': string;
    'studentBelowPovertyPct': string;
    'advancePlacementClasses': string;
    'freeOrReducedPriceLunches': FreeOrReducedPriceLunches;
    'studentEthnicity': StudentEthnicity;
}

export class SchoolRanking {
    'current': string;
    'rankYear': string;
    'stateRank': string;
    'numberOfSchools': string;
    'avgMathScore': string;
    'avgReadingScore': string;
    'statePercentileScore': string;
}

export class SchoolsNearByResponse {
    'matchedAddress': Address;
    'school': Array<School>;
}

export class Segmentation {
    'boundaries': Boundaries;
    'themes': SegmentationThemes;
}

export class SegmentationThemes {
    'lifeStyleTheme': LifeStyleTheme;
}

export class ShoreLineDistance {
    'unit': string;
    'value': string;
}

export class Sic {
    'businessLine': string;
    'sicCode': string;
    'sicCodeDescription': string;
    'primarySicCode': string;
    'secondarySicCode': string;
}

export class SicMetadata {
    'code': string;
    'categoryCode': string;
    'tradeDivision': string;
    'tradeGroup': string;
    'class': string;
    'subClass': string;
    'description': string;
}

export class SiteDetails {
    'phone': string;
    'fax': string;
    'contactName': string;
    'email': string;
    'address': MatchedAddress;
}

export class SpecialPurposeDistrict {
    'districtName': string;
    'districtCode': string;
    'districtNumber': string;
    'versionDate': string;
    'effectiveDate': string;
    'compiledDate': string;
    'updateDate': string;
}

export class SpecialPurposeDistrictTax {
    'districtNumber': string;
    'taxRate': number;
    'taxAmount': number;
}

export class SpecialPurposeDistrictTaxRate {
    'districtNumber': string;
    'taxRate': number;
    'taxAmount': number;
}

export class SpeedLimit {
    'maxSpeed': string;
    'speedUnit': string;
    'speedVerification': string;
    'amPeakAvgSpeed': string;
    'pmPeakAvgSpeed': string;
    'offPeakAvgSpeed': string;
    'nightAvgSpeed': string;
    'weekAvgSpeed': string;
    'road': SpeedRoad;
}

export class SpeedRoad {
    'id': string;
    'name': string;
    'altName': string;
    'roadClass': string;
    'type': string;
    'lengthInMeters': string;
    'routeNumber': string;
    'surfaceType': string;
    'trafficFlow': string;
    'isToll': string;
    'beginningLevel': string;
    'endingLevel': string;
}

export class Start {
    'year': number;
    'month': number;
    'day': number;
}

export class StartEndPoint {
    'type': string;
    'coordinates': Array<number>;
}

export class Status {
    'code': string;
    'description': string;
}

export class Stories {
    'value': string;
    'description': string;
}

export class StudentEthnicity {
    'indianAlaskaNative': string;
    'asian': string;
    'hispanic': string;
    'black': string;
    'white': string;
    'hawaiianPacificlslander': string;
    'twoOrMoreRaces': string;
}

export class SupplyAndDemandTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class SupportLevel {
    'supportedDataLevel': number;
    'countries': Array<string>;
    'updatedRequiredInputs': Array<InputParameter>;
    'updatedOptionalInputs': Array<InputParameter>;
    'updatedOptionalOutputs': Array<OutputParameter>;
}

export class TaxAddress {
    'objectId': string;
    'mainAddressLine': string;
    'placeName': string;
    'areaName1': string;
    'areaName3': string;
    'postCode1': string;
    'country': string;
    'purchaseAmount': string;
}

export class TaxAddressRequest {
    'preferences': Preferences;
    'taxAddresses': Array<TaxAddress>;
}

export class TaxBatchLocationResponse {
    'objectId': string;
    'confidence': number;
    'jurisdiction': TaxJurisdiction;
    'matchedAddress': MatchedAddress;
    'salesTax': SalesTax;
    'useTax': UseTax;
    'census': Census;
    'latLongFields': LatLongFields;
}

export class TaxBatchResponse {
    'objectId': string;
    'confidence': number;
    'jurisdiction': TaxJurisdiction;
    'matchedAddress': MatchedAddress;
    'salesTax': SalesTax;
    'useTax': UseTax;
    'census': Census;
    'latLongFields': LatLongFields;
}

export class TaxCounty {
    'code': string;
    'name': string;
}

export class TaxDistrictResponse {
    'objectId': string;
    'confidence': number;
    'jurisdiction': IPDTaxJurisdiction;
    'numOfIpdsFound': number;
    'ipds': Array<Ipd>;
    'matchedAddress': MatchedAddress;
}

export class TaxDistrictResponseList {
    'taxDistrictResponse': Array<TaxDistrictResponse>;
}

export class TaxExemption {
    'code': string;
    'value': string;
}

export class TaxJurisdiction {
    'state': TaxState;
    'county': TaxCounty;
    'place': TaxPlace;
    'spds': Array<SpecialPurposeDistrict>;
}

export class TaxLocationPreferences {
    'defaultBufferWidth': string;
    'distanceUnits': string;
    'outputCasing': string;
    'returnCensusFields': string;
    'returnLatLongFields': string;
}

export class TaxLocationRequest {
    'preferences': TaxLocationPreferences;
    'locations': Array<GeoTaxLocations>;
}

export class TaxLocationResponses {
    'taxResponses': Array<TaxBatchLocationResponse>;
}

export class TaxPlace {
    'name': string;
    'code': string;
    'gnisCode': string;
    'selfCollected': boolean;
    'classCode': string;
    'incorporatedFlag': string;
    'lastAnnexedDate': string;
    'lastUpdatedDate': string;
    'lastVerifiedDate': string;
}

export class TaxRateAddress {
    'objectId': string;
    'mainAddressLine': string;
    'placeName': string;
    'areaName1': string;
    'areaName3': string;
    'postCode1': string;
    'country': string;
}

export class TaxRateAddressRequest {
    'preferences': Preferences;
    'taxRateAddresses': Array<TaxRateAddress>;
}

export class TaxRateBatchLocationResponse {
    'objectId': string;
    'confidence': number;
    'jurisdiction': TaxJurisdiction;
    'matchedAddress': MatchedAddress;
    'salesTax': SalesTaxRate;
    'useTax': UseTaxRate;
    'census': Census;
    'latLongFields': LatLongFields;
}

export class TaxRateBatchResponse {
    'objectId': string;
    'confidence': number;
    'jurisdiction': TaxJurisdiction;
    'matchedAddress': MatchedAddress;
    'salesTax': SalesTaxRate;
    'useTax': UseTaxRate;
    'census': Census;
    'latLongFields': LatLongFields;
}

export class TaxRateLocationRequest {
    'preferences': TaxLocationPreferences;
    'locations': Array<GeoTaxRateLocations>;
}

export class TaxRateLocationResponses {
    'taxResponses': Array<TaxRateBatchLocationResponse>;
}

export class TaxRateResponse {
    'objectId': string;
    'confidence': number;
    'jurisdiction': TaxJurisdiction;
    'matchedAddress': MatchedAddress;
    'salesTax': SalesTaxRate;
    'useTax': UseTaxRate;
    'latLongFields': LatLongFields;
}

export class TaxRateResponses {
    'taxResponses': Array<TaxRateBatchResponse>;
}

export class TaxResponse {
    'objectId': string;
    'confidence': number;
    'jurisdiction': TaxJurisdiction;
    'matchedAddress': MatchedAddress;
    'salesTax': SalesTax;
    'useTax': UseTax;
    'latLongFields': LatLongFields;
}

export class TaxResponses {
    'taxResponses': Array<TaxBatchResponse>;
}

export class TaxState {
    'code': string;
    'name': string;
}

export class Time {
    'value': string;
    'unit': string;
}

export class Timezone {
    'objectId': string;
    'timezoneName': string;
    'zoneType': string;
    'utcOffset': number;
    'dstOffset': number;
    'timestamp': number;
    'matchedAddress': MatchedAddress;
}

export class TimezoneAddressRequest {
    'preferences': PreferencTimeZone;
    'addressTime': Array<AddressTime>;
}

export class TimezoneLocation {
    'objectId': string;
    'timezoneName': string;
    'zoneType': string;
    'utcOffset': number;
    'dstOffset': number;
    'timestamp': number;
}

export class TimezoneLocationRequest {
    'locationTime': Array<LocationTime>;
}

export class TimezoneLocationResponse {
    'timezone': Array<TimezoneLocation>;
}

export class TimezoneResponse {
    'timezone': Array<Timezone>;
}

export class Topic {
    'name': string;
}

export class TravelBoundaries {
    'travelBoundary': TravelBoundary;
}

export class TravelBoundary {
    'costs': Costs;
}

export class TravelCostMatrixResponse {
    'matrix': Array<Matrix>;
}

export class Type {
    'code': string;
    'value': string;
}

export class TypeaheadRange {
    'placeName': string;
    'units': Array<TypeaheadUnit>;
}

export class TypeaheadUnit {
    'unitInfo': string;
    'formattedUnitAddress': string;
}

export class Unit {
    'value': number;
    'unit': string;
}

export class Url {
    'value': string;
}

export class UseTax {
    'totalTaxRate': number;
    'totalTaxAmount': number;
    'stateTaxRate': number;
    'stateTaxAmount': number;
    'countyTaxRate': number;
    'countyTaxAmount': number;
    'municipalTaxRate': number;
    'municipalTaxAmount': number;
    'spdsTax': Array<SpecialPurposeDistrictTax>;
    'specialTaxRulesApplied': boolean;
    'specialTaxRulesDescriptor': string;
}

export class UseTaxRate {
    'totalTaxRate': number;
    'stateTaxRate': number;
    'countyTaxRate': number;
    'municipalTaxRate': number;
    'spdsTax': Array<SpecialPurposeDistrictTaxRate>;
}

export class Vacancy {
    'code': string;
    'value': string;
}

export class ValidateEmailAddressAPIRequest {
    'options': ValidateEmailAddressOptions;
    'input': ValidateEmailAddressInput;
}

export class ValidateEmailAddressAPIResponse {
    'output': Array<ValidateEmailAddressOutput>;
}

export class ValidateEmailAddressInput {
    'row': Array<ValidateEmailAddressInputRow>;
}

export class ValidateEmailAddressInputRow {
    /**
    * These fields are returned, unmodified, in the user_fields section of the response.
    */
    'userFields': Array<ValidateMailingAddressInputRowUserFields>;
    /**
    * Enables or disables real-time confirmation. If the deliverability of an email address cannot be determined via our knowledge base, a real-time confirmation can be attempted.
    */
    'rtc': string;
    /**
    * Specifies whether to check if the email address is fictitious. For example, bgates@microsoft.com.
    */
    'bogus': string;
    /**
    * Specifies whether to check if the email address has a non-personal handle, such as info@, sales@, or webmaster@. For example, sales@example.com.
    */
    'role': string;
    /**
    * Specifies whether to check if the email address appears on the Direct Marketing Association's Do Not Email list (Electronic Mail Preference Service).
    */
    'emps': string;
    /**
    * Specifies whether to check if the email address is associated with a domain that has restrictions on commercial email per the FCC.
    */
    'fccwireless': string;
    /**
    * Specifies whether to check if the email address handle contains derogatory words.
    */
    'language': string;
    /**
    * Specifies whether to check if the owner of the email address is known to submit spam complaints.
    */
    'complain': string;
    /**
    * Specifies whether to check if the email address originates from a website that provides temporary email addresses, or if the email address appears to be temporary
    */
    'disposable': string;
    /**
    * One character code controlling the advanced suggestion behavior.The possible values are: a, c, and n
    */
    'atc': string;
    /**
    * The email address you want to validate.
    */
    'emailAddress': string;
    /**
    * Specifies the timeout for real-time confirmation. See the description of the rtc parameter. Specify the timeout value in milliseconds. Valid values are 0 to 4000. By default, the system allows 1200 milliseconds for this check.
    */
    'rtcTimeout': string;
}

export class ValidateEmailAddressOptions {
}

export class ValidateEmailAddressOutput {
    /**
    * These fields are returned, unmodified, in the user_fields section of the response.
    */
    'userFields': Array<ValidateMailingAddressInputRowUserFields>;
    /**
    * The email address submitted for verification.
    */
    'eMAIL': string;
    /**
    * One character code indicating the validity of the submitted email address.
    */
    'fINDING': string;
    /**
    * The comment string pertaining to the result of the submitted email address.
    */
    'cOMMENT': string;
    /**
    * A short code which maps to each returned COMMENT field value.
    */
    'cOMMENTCODE': string;
    /**
    * Suggested correction for submitted email address, if found. A suggestion will only be provided if it is valid and SafeToDeliver.
    */
    'sUGGEMAIL': string;
    /**
    * This field contains suggestion not SafeToDeliver when ValidateEmailAddress corrected the address and the corrected version of the email address failed one or more SafeToDeliver process checks.
    */
    'sUGGCOMMENT': string;
    /**
    * Pre-formatted response intended to be provided to user.
    */
    'eRRORRESPONSE': string;
    /**
    * Field reserved for special features only.
    */
    'eRROR': string;
    /**
    * 
    */
    'status': string;
    /**
    * 
    */
    'statusCode': string;
    /**
    * 
    */
    'statusDescription': string;
}

export class ValidateMailingAddressInput {
    'row': Array<ValidateMailingAddressInputRow>;
}

export class ValidateMailingAddressInputRow {
    /**
    * These fields are returned, unmodified, in the user_fields section of the response.
    */
    'userFields': Array<ValidateMailingAddressInputRowUserFields>;
    /**
    * The first address line.
    */
    'addressLine1': string;
    /**
    * The second address line.
    */
    'addressLine2': string;
    /**
    * The company or firm name.
    */
    'firmName': string;
    /**
    * The city name.
    */
    'city': string;
    /**
    * The state or province.
    */
    'stateProvince': string;
    /**
    * The country code or name.
    */
    'country': string;
    /**
    * The postal code for the address.
    */
    'postalCode': string;
}

export class ValidateMailingAddressInputRowUserFields {
    /**
    * 
    */
    'name': string;
    /**
    * 
    */
    'value': string;
}

export class ValidateMailingAddressOptions {
    /**
    * Specify the casing of the output data.
    */
    'outputCasing': string;
}

export class ValidateMailingAddressOutput {
    /**
    * These fields are returned, unmodified, in the user_fields section of the response.
    */
    'userFields': Array<ValidateMailingAddressInputRowUserFields>;
    /**
    * The first line of the validated address.
    */
    'addressLine1': string;
    /**
    * The second line of the validated address.
    */
    'addressLine2': string;
    /**
    * The validated firm or company name.
    */
    'firmName': string;
    /**
    * The validated city name.
    */
    'city': string;
    /**
    * The validated ZIP Code or postal code.
    */
    'postalCode': string;
    /**
    * The country name in English.
    */
    'country': string;
    /**
    * The validated state or province abbreviation.
    */
    'stateProvince': string;
    /**
    * The formatted address, as it would appear on a physical mail piece.
    */
    'blockAddress': string;
    /**
    * Input data not used by the address validation process.
    */
    'additionalInputData': string;
    /**
    * The 5-digit ZIP Code.
    */
    'postalCodeBase': string;
    /**
    * The 4-digit add-on part of the ZIP Code.
    */
    'postalCodeAddOn': string;
    /**
    * Reports the success or failure of the match attempt.
    */
    'status': string;
    /**
    * Reason for failure, if there is one.
    */
    'statusCode': string;
    /**
    * Description of the problem, if there is one.
    */
    'statusDescription': string;
}

export class ValidateMailingAddressPremiumInput {
    'row': Array<ValidateMailingAddressPremiumInputRow>;
}

export class ValidateMailingAddressPremiumInputRow {
    /**
    * These fields are returned, unmodified, in the user_fields section of the response.
    */
    'userFields': Array<ValidateMailingAddressInputRowUserFields>;
    /**
    * The first address line.
    */
    'addressLine1': string;
    /**
    * The second address line.
    */
    'addressLine2': string;
    /**
    * The third address line.
    */
    'addressLine3': string;
    /**
    * The fourth address line.
    */
    'addressLine4': string;
    /**
    * The fifth address line.
    */
    'addressLine5': string;
    /**
    * The company or firm name.
    */
    'firmName': string;
    /**
    * The city name.
    */
    'city': string;
    /**
    * The state or province.
    */
    'stateProvince': string;
    /**
    * The country code or name.
    */
    'country': string;
    /**
    * The postal code for the address.
    */
    'postalCode': string;
}

export class ValidateMailingAddressPremiumOptions {
    /**
    * Specifies whether to return a formatted version of the address as it would be printed on a physical mail piece.
    */
    'outputAddressBlocks': string;
    /**
    * Specifies whether to return multiple address for those input addresses that have more than one possible match.
    */
    'keepMultimatch': string;
    /**
    * Specifies the format to use for the country name returned in the Country output field.
    */
    'outputCountryFormat': string;
    /**
    * Specifies the type of output record you get.
    */
    'outputRecordType': string;
    /**
    * Specifies whether to include field-level result indicators.
    */
    'outputFieldLevelReturnCodes': string;
    /**
    * Specifies the alphabet or script in which the output should be returned.
    */
    'outputScript': string;
    /**
    * Specify the casing of the output data.
    */
    'outputCasing': string;
    /**
    * A number between 1 and 10 that indicates the maximum number of addresses to return.
    */
    'maximumResults': string;
}

export class ValidateMailingAddressPremiumOutput {
    /**
    * These fields are returned, unmodified, in the user_fields section of the response.
    */
    'userFields': Array<ValidateMailingAddressInputRowUserFields>;
    /**
    * Reports the success or failure of the match attempt.
    */
    'status': string;
    /**
    * Reason for failure, if there is one.
    */
    'statusCode': string;
    /**
    * Description of the problem, if there is one.
    */
    'statusDescription': string;
    /**
    * The level of confidence assigned to the address being returned.
    */
    'confidence': string;
    /**
    * Type of address record.
    */
    'recordType': string;
    /**
    * Code indicating the default match.
    */
    'recordTypeDefault': string;
    /**
    * Indicates which address component had multiple matches.
    */
    'multipleMatches': string;
    /**
    * Mentions the address component that could not be validated, in case no match is found.
    */
    'couldNotValidate': string;
    /**
    * The category of address matching available.
    */
    'countryLevel': string;
    /**
    * The type of address data being returned.
    */
    'addressFormat': string;
    /**
    * The first line of the validated address.
    */
    'addressLine1': string;
    /**
    * The second line of the validated address.
    */
    'addressLine2': string;
    /**
    * The third line of the validated address.
    */
    'addressLine3': string;
    /**
    * The fourth line of the validated address.
    */
    'addressLine4': string;
    /**
    * The validated city name.
    */
    'city': string;
    /**
    * The validated state or province abbreviation.
    */
    'stateProvince': string;
    /**
    * The validated ZIP Code or postal code.
    */
    'postalCode': string;
    /**
    * The 5-digit ZIP Code.
    */
    'postalCodeBase': string;
    /**
    * The 4-digit add-on part of the ZIP Code.
    */
    'postalCodeAddOn': string;
    /**
    * The country in the format determined by what you selected.
    */
    'country': string;
    /**
    * Input data that could not be matched to a particular address component.
    */
    'additionalInputData': string;
    /**
    * The validated firm or company name.
    */
    'firmName': string;
    /**
    * House number.
    */
    'houseNumber': string;
    /**
    * Leading directional.
    */
    'leadingDirectional': string;
    /**
    * Street name.
    */
    'streetName': string;
    /**
    * Street suffix.
    */
    'streetSuffix': string;
    /**
    * Trailing directional.
    */
    'trailingDirectional': string;
    /**
    * Apartment designator (such as STE or APT).
    */
    'apartmentLabel': string;
    /**
    * Apartment number.
    */
    'apartmentNumber': string;
    /**
    * Secondary apartment designator.
    */
    'apartmentLabel2': string;
    /**
    * Secondary apartment number.
    */
    'apartmentNumber2': string;
    /**
    * Rural Route/Highway Contract indicator.
    */
    'rRHC': string;
    /**
    * Post office box number.
    */
    'pOBox': string;
    /**
    * Private mailbox indicator.
    */
    'privateMailbox': string;
    /**
    * The type of private mailbox.
    */
    'privateMailboxType': string;
    /**
    * House number.
    */
    'houseNumberInput': string;
    /**
    * Leading directional.
    */
    'leadingDirectionalInput': string;
    /**
    * Street name.
    */
    'streetNameInput': string;
    /**
    * Street suffix.
    */
    'streetSuffixInput': string;
    /**
    * Trailing directional.
    */
    'trailingDirectionalInput': string;
    /**
    * Apartment designator (such as STE or APT).
    */
    'apartmentLabelInput': string;
    /**
    * Apartment number.
    */
    'apartmentNumberInput': string;
    /**
    * Rural Route/Highway Contract indicator.
    */
    'rRHCInput': string;
    /**
    * Post office box number.
    */
    'pOBoxInput': string;
    /**
    * Private mailbox indicator.
    */
    'privateMailboxInput': string;
    /**
    * The type of private mailbox.
    */
    'privateMailboxTypeInput': string;
    /**
    * Validated city name.
    */
    'cityInput': string;
    /**
    * Validated state or province name.
    */
    'stateProvinceInput': string;
    /**
    * Validated postal code.
    */
    'postalCodeInput': string;
    /**
    * Country. Format is determined by what you selected in OutputCountryFormat.
    */
    'countryInput': string;
    /**
    * The validated firm or company name.
    */
    'firmNameInput': string;
    /**
    * The field-level result indicator for HouseNumber.
    */
    'houseNumberResult': string;
    /**
    * The field-level result indicator for LeadingDirectional.
    */
    'leadingDirectionalResult': string;
    /**
    * The field-level result indicator for Street.
    */
    'streetResult': string;
    /**
    * The field-level result indicator for StreetName.
    */
    'streetNameResult': string;
    /**
    * The field-level result indicator for StreetName Alias.
    */
    'streetNameAliasType': string;
    /**
    * The field-level result indicator for StreetSuffix.
    */
    'streetSuffixResult': string;
    /**
    * The field-level result indicator for TrailingDirectional.
    */
    'trailingDirectionalResult': string;
    /**
    * The field-level result indicator for ApartmentLabel.
    */
    'apartmentLabelResult': string;
    /**
    * The field-level result indicator for ApartmentNumber.
    */
    'apartmentNumberResult': string;
    /**
    * The field-level result indicator for ApartmentLabel2.
    */
    'apartmentLabel2Result': string;
    /**
    * The field-level result indicator for ApartmentNumber2.
    */
    'apartmentNumber2Result': string;
    /**
    * The field-level result indicator for RRHC.
    */
    'rRHCResult': string;
    /**
    * The field-level result indicator for RRHC Type.
    */
    'rRHCType': string;
    /**
    * The field-level result indicator for POBox.
    */
    'pOBoxResult': string;
    /**
    * The field-level result indicator for City.
    */
    'cityResult': string;
    /**
    * The field-level result indicator for StateProvince.
    */
    'stateProvinceResult': string;
    /**
    * The field-level result indicator for PostalCode.
    */
    'postalCodeResult': string;
    /**
    * The field-level result indicator for PostalCodeCity.
    */
    'postalCodeCityResult': string;
    /**
    * The field-level result indicator for AddressRecord.
    */
    'addressRecordResult': string;
    /**
    * The field-level result indicator for PostalCode Source.
    */
    'postalCodeSource': string;
    /**
    * Indicates the type of postal code returned.
    */
    'postalCodeType': string;
    /**
    * The validated firm or company name.
    */
    'countryResult': string;
    /**
    * Indicates if the firm name got validated.
    */
    'firmNameResult': string;
    /**
    * Indicates the result of preferred alias processing.
    */
    'streetNamePreferredAliasResult': string;
    /**
    * Indicates the result of abbreviated alias processing.
    */
    'streetNameAbbreviatedAliasResult': string;
    /**
    * The fifth line of the validated address.
    */
    'addressLine5': string;
    /**
    * A two character code indicating overall quality of the resulting address.
    */
    'addressQuality': string;
    /**
    * An estimate of confidence that an item mailed or shipped to this address would be successfully delivered.
    */
    'deliverability': string;
    /**
    * A single letter code that indicates the type of address.
    */
    'addressType': string;
    /**
    * A locality is a village in rural areas or it may be a suburb in urban areas.
    */
    'locality': string;
    /**
    * A value of 0 and 100 that reflects how much the address has changed to make it valid.
    */
    'changeScore': string;
    /**
    * The validated firm or company name.
    */
    'suburb': string;
    /**
    * It is the formatted address, as it would appear on a physical mail piece.
    */
    'blockAddress': string;
    /**
    * Seven-digit number in degrees, calculated to four decimal places.
    */
    'latitude': string;
    /**
    * Seven-digit number in degrees, calculated to four decimal places.
    */
    'longitude': string;
}

export class ValidateMailingAddressPremiumRequest {
    'options': ValidateMailingAddressPremiumOptions;
    'input': ValidateMailingAddressPremiumInput;
}

export class ValidateMailingAddressPremiumResponse {
    'output': Array<ValidateMailingAddressPremiumOutput>;
}

export class ValidateMailingAddressProInput {
    'row': Array<ValidateMailingAddressProInputRow>;
}

export class ValidateMailingAddressProInputRow {
    /**
    * These fields are returned, unmodified, in the user_fields section of the response.
    */
    'userFields': Array<ValidateMailingAddressInputRowUserFields>;
    /**
    * The first address line.
    */
    'addressLine1': string;
    /**
    * The second address line.
    */
    'addressLine2': string;
    /**
    * The company or firm name.
    */
    'firmName': string;
    /**
    * The city name.
    */
    'city': string;
    /**
    * The state or province.
    */
    'stateProvince': string;
    /**
    * The country code or name.
    */
    'country': string;
    /**
    * The postal code for the address.
    */
    'postalCode': string;
}

export class ValidateMailingAddressProOptions {
    /**
    * Specifies whether to return a formatted version of the address as it would be printed on a physical mail piece.
    */
    'outputAddressBlocks': string;
    /**
    * Specifies whether to return multiple address for those input addresses that have more than one possible match.
    */
    'keepMultimatch': string;
    /**
    * Specifies the format to use for the country name returned in the Country output field.
    */
    'outputCountryFormat': string;
    /**
    * Specifies the alphabet or script in which the output should be returned.
    */
    'outputScript': string;
    /**
    * Specify the casing of the output data.
    */
    'outputCasing': string;
    /**
    * A number between 1 and 10 that indicates the maximum number of addresses to return.
    */
    'maximumResults': string;
}

export class ValidateMailingAddressProOutput {
    /**
    * These fields are returned, unmodified, in the user_fields section of the response.
    */
    'userFields': Array<ValidateMailingAddressInputRowUserFields>;
    /**
    * The first line of the validated address.
    */
    'addressLine1': string;
    /**
    * The second line of the validated address.
    */
    'addressLine2': string;
    /**
    * The validated firm or company name.
    */
    'firmName': string;
    /**
    * A value of 0 and 100 that reflects how much the address has changed to make it valid.
    */
    'changeScore': string;
    /**
    * Generally a locality is a village in rural areas or it may be a suburb in urban areas.
    */
    'locality': string;
    /**
    * The suburb name.
    */
    'suburb': string;
    /**
    * A single letter code that indicates the type of address.
    */
    'addressType': string;
    /**
    * An estimate of confidence that an item mailed or shipped to this address would be successfully delivered.
    */
    'deliverability': string;
    /**
    * A two character code indicating overall quality of the resulting address.
    */
    'addressQuality': string;
    /**
    * Mentions the address component that could not be validated, in case no match is found.
    */
    'couldNotValidate': string;
    /**
    * The validated city name.
    */
    'city': string;
    /**
    * The validated ZIP Code or postal code.
    */
    'postalCode': string;
    /**
    * The country in the format determined by what you selected.
    */
    'country': string;
    /**
    * The validated state or province abbreviation.
    */
    'stateProvince': string;
    /**
    * The formatted address, as it would appear on a physical mail piece.
    */
    'blockAddress': string;
    /**
    * Input data that could not be matched to a particular address component.
    */
    'additionalInputData': string;
    /**
    * The 5-digit ZIP Code.
    */
    'postalCodeBase': string;
    /**
    * The 4-digit add-on part of the ZIP Code.
    */
    'postalCodeAddOn': string;
    /**
    * Reports the success or failure of the match attempt.
    */
    'status': string;
    /**
    * Reason for failure, if there is one.
    */
    'statusCode': string;
    /**
    * Description of the problem, if there is one.
    */
    'statusDescription': string;
}

export class ValidateMailingAddressProRequest {
    'options': ValidateMailingAddressProOptions;
    'input': ValidateMailingAddressProInput;
}

export class ValidateMailingAddressProResponse {
    'output': Array<ValidateMailingAddressProOutput>;
}

export class ValidateMailingAddressRequest {
    'options': ValidateMailingAddressOptions;
    'input': ValidateMailingAddressInput;
}

export class ValidateMailingAddressResponse {
    'output': Array<ValidateMailingAddressOutput>;
}

export class ValidateMailingAddressUSCANAPIInput {
    'row': Array<ValidateMailingAddressUSCANAPIInputRow>;
}

export class ValidateMailingAddressUSCANAPIInputRow {
    /**
    * These fields are returned, unmodified, in the user_fields section of the response.
    */
    'userFields': Array<ValidateMailingAddressInputRowUserFields>;
    /**
    * The first address line.
    */
    'addressLine1': string;
    /**
    * The second address line.
    */
    'addressLine2': string;
    /**
    * The third address line.
    */
    'addressLine3': string;
    /**
    * The fourth address line.
    */
    'addressLine4': string;
    /**
    * The company or firm name.
    */
    'firmName': string;
    /**
    * The city name.
    */
    'city': string;
    /**
    * The state or province.
    */
    'stateProvince': string;
    /**
    * The country code or name.
    */
    'country': string;
    /**
    * The postal code for the address.
    */
    'postalCode': string;
    /**
    * U.S. address urbanization name. Used primarily for Puerto Rico addresses.
    */
    'uSUrbanName': string;
    /**
    * Canadian language.
    */
    'canLanguage': string;
}

export class ValidateMailingAddressUSCANAPIOptions {
    /**
    * Specifies whether to return a formatted version of the address.
    */
    'outputAddressBlocks': string;
    /**
    * Specifies whether or not to process U.S. addresses.
    */
    'performUSProcessing': string;
    /**
    * Delivery Point Validation (DPV®) validates that a specific address exists
    */
    'performDPV': string;
    /**
    * Specifies whether to return a formatted address when an address cannot be validated.
    */
    'outputFormattedOnFail': string;
    /**
    * Specifies whether to use separators (spaces or hyphens) in ZIP™ Codes or Canadian postal codes.
    */
    'outputPostalCodeSeparator': string;
    /**
    * Specifies the format to use for the country name returned in the Country output field.
    */
    'outputCountryFormat': string;
    /**
    * Indicates whether to return multiple address for input addresses that have more than one possible matches.
    */
    'keepMultimatch': string;
    /**
    * Specifies the casing of the output address. M for mixed case and U for upper case.
    */
    'outputCasing': string;
    /**
    * Specifies a number between 1 and 10 that indicates the maximum number of addresses to be returned.
    */
    'maximumResults': string;
    /**
    * Specifies the type of the output record.
    */
    'outputRecordType': string;
    /**
    * Identifies which output addresses are candidate addresses as value if Y for OutputFieldLevelReturnCodes.
    */
    'outputFieldLevelReturnCodes': string;
    /**
    * Determines the no stat status of an address which means it exists but cannot receive mails.
    */
    'dPVDetermineNoStat': string;
    /**
    * Specifies the algorithm to determe if an input address matches in the postal database.
    */
    'streetMatchingStrictness': string;
    /**
    * Specifies the default apartment label for the output if there is no apartment label in the input address. This is specific to French address. 
    */
    'canFrenchApartmentLabel': string;
    /**
    * Specifies whether to use a street's abbreviated alias in the output if the output address line is longer than 31 characters.
    */
    'outputAbbreviatedAlias': string;
    /**
    * Selecting the match condition where a DPV result does NOT cause a record to fail.
    */
    'dPVSuccessfulStatusCondition': string;
    /**
    * Specifies where Private Mailbox (PMB) information is placed.
    */
    'standardAddressPMBLine': string;
    /**
    * Specifies the algorithm to determining if an input address matches in the postal database.
    */
    'firmMatchingStrictness': string;
    /**
    * Specifies where to place rural route delivery information.
    */
    'canRuralRouteFormat': string;
    /**
    * Specifies whether to select a house number of postal code in case of conflict.
    */
    'canPreferHouseNum': string;
    /**
    * Specifies whether to use a street's preferred alias in the output.
    */
    'outputPreferredAlias': string;
    /**
    * Specifies the algorithm to determine if an input address matches in the postal database.
    */
    'directionalMatchingStrictness': string;
    /**
    * Specifies whether to extract the firm name from AddressLine1 through AddressLine4 and place it in the FirmName output field.
    */
    'extractFirm': string;
    /**
    * Specifies whether to consider Treat Commercial Mail Receiving Agency (CMRA) matches as failures?
    */
    'failOnCMRAMatch': string;
    /**
    * Specifies whether or not non-civic keywords are abbreviated in the output. 
    */
    'canNonCivicFormat': string;
    /**
    * Changes the civic and/or suite information to match the LVR or single-single record.
    */
    'canSSLVRFlg': string;
    /**
    * Specifies how to handle street name aliases used in the input. This is specific to US.
    */
    'outputStreetNameAlias': string;
    /**
    * Specifies the Early Warning System (EWS) that uses the USPS EWS File to validate addresses that are not in the ZIP + 4 database.
    */
    'performEWS': string;
    /**
    * Specifies whether to use the long, medium, or short version of the city if the city has a long name.
    */
    'canOutputCityFormat': string;
    /**
    * Specifies how to return a match if multiple non-blank address lines are present or multiple address types are on the same address line. (U.S. addresses only.)
    */
    'dualAddressLogic': string;
    /**
    * Specifies whether to perform SuiteLink processing.
    */
    'performSuiteLink': string;
    /**
    * Specifies where to place secondary address information in the output address.
    */
    'canStandardAddressFormat': string;
    /**
    * Specifies whether the preferred last line city name should be stored.
    */
    'outputPreferredCity': string;
    /**
    * Specifies whether to return multinational characters, including diacritical marks such as umlauts or accents.
    */
    'outputMultinationalCharacters': string;
    /**
    * Specifies where to place station information.
    */
    'canDeliveryOfficeFormat': string;
    /**
    * Facilitates the conversion of rural route address converting into street-style address using the LACS.
    */
    'performLACSLink': string;
    /**
    * Specifies whether ValidateMailingAddressUSCAN should return a street match or a PO Box/non-civic match when the address contains both civic and non-civic information.
    */
    'canDualAddressLogic': string;
    /**
    * Specifies whether to extract the urbanization name from AddressLine1 through AddressLine4 and place it in the USUrbanName output field. 
    */
    'extractUrb': string;
    /**
    * Specifies where to place secondary address information for U.S. addresses.
    */
    'standardAddressFormat': string;
    /**
    * Specifies how to determine the language (English or French) to use to format the address and directional.
    */
    'canFrenchFormat': string;
    /**
    * Determines if the location has been unoccupied for at least 90 days.
    */
    'dPVDetermineVacancy': string;
    /**
    * Specifies the default apartment label to use in the output if there is no apartment label in the input address. rhis is specific to English addresses.
    */
    'canEnglishApartmentLabel': string;
    /**
    * Specifies whether to supress addresses with Carrier Route R777.
    */
    'suppressZplusPhantomCarrierR777': string;
    /**
    * Specifies whether or not to return the city alias when the alias is in the input address.
    */
    'canOutputCityAlias': string;
    /**
    * Specifies how to format city names that have short city name or non-mailing city name alternatives.
    */
    'outputShortCityName': string;
}

export class ValidateMailingAddressUSCANAPIOutput {
    /**
    * These fields are returned, unmodified, in the user_fields section of the response.
    */
    'userFields': Array<ValidateMailingAddressInputRowUserFields>;
    /**
    * Reports the success or failure of the match attempt.
    */
    'status': string;
    /**
    * Reason for failure, if there is one.
    */
    'statusCode': string;
    /**
    * Specifies the description of the problem, if there is one.
    */
    'statusDescription': string;
    /**
    * Specifies the first line of the validated and standardized address.
    */
    'addressLine1': string;
    /**
    * Specifies the second line of the validated and standardized address.
    */
    'addressLine2': string;
    /**
    * Specifies the validated city name.
    */
    'city': string;
    /**
    * Specifies the validated state or province abbreviation.
    */
    'stateProvince': string;
    /**
    * Specifies the validated ZIP Code or postal code.
    */
    'postalCode': string;
    /**
    * Specifies the country in the format determined by the selection from ISO or UPO or English.
    */
    'country': string;
    /**
    * Specifies the validated firm or company name.
    */
    'firmName': string;
    /**
    * Specifies the formatted address, as it would appear on a physical mail piece. 
    */
    'blockAddress': string;
    /**
    * Specifies the 5-digit ZIP Code.
    */
    'postalCodeBase': string;
    /**
    * Specifies the 4-digit add-on part of the ZIP Code.
    */
    'postalCodeAddOn': string;
    /**
    * Specifies input data not used by the address validation process.
    */
    'additionalInputData': string;
    /**
    * Specifies the address component that could not be validated, in case no match is found. 
    */
    'couldNotValidate': string;
    /**
    * Specifies the type of address data being returned.
    */
    'addressFormat': string;
    /**
    * Specifies the third line of the validated and standardized address. If the address could not be validated, the third line of the input address without any changes.
    */
    'addressLine3': string;
    /**
    * Specifies the fourth line of the validated and standardized address. If the address could not be validated, the fourth line of the input address without any changes.
    */
    'addressLine4': string;
    /**
    * Specifies the result codes that apply to international addresses only.
    */
    'addressRecordResult': string;
    /**
    * Specifies the apartment designator such as STE or APT.
    */
    'apartmentLabel': string;
    /**
    * Specifies the apartment designator such as STE or APT.
    */
    'apartmentLabelInput': string;
    /**
    * Specifies the result of apartment label.
    */
    'apartmentLabelResult': string;
    /**
    * Specifies the apartment number.
    */
    'apartmentNumber': string;
    /**
    * Specifies the apartment number.
    */
    'apartmentNumberInput': string;
    /**
    * Specifies the result of apartment number.
    */
    'apartmentNumberResult': string;
    /**
    * Specifies the validated city name.
    */
    'cityInput': string;
    /**
    * Specifies the result of the validated city name.
    */
    'cityResult': string;
    /**
    * Specifies the the level of confidence assigned to the address being returned.
    */
    'confidence': string;
    /**
    * Specifies the name of the country.
    */
    'countryInput': string;
    /**
    * Specifies the result code for the country.
    */
    'countryResult': string;
    /**
    * Specifies the category of address matching available.
    */
    'countryLevel': string;
    /**
    * Specifies the validated firm or company name.
    */
    'firmNameInput': string;
    /**
    * Specifies if the firm name got validated.
    */
    'firmNameResult': string;
    /**
    * Specifies the house number.
    */
    'houseNumber': string;
    /**
    * Specifies the house number.
    */
    'houseNumberInput': string;
    /**
    * Specifies the result for house number.
    */
    'houseNumberResult': string;
    /**
    * Specifies the leading directional.
    */
    'leadingDirectional': string;
    /**
    * Specifies the leading directional.
    */
    'leadingDirectionalInput': string;
    /**
    * Specifies the result of leading directional.
    */
    'leadingDirectionalResult': string;
    /**
    * Specifies the address component with multiple matches, if multiple matches were found: 
    */
    'multipleMatches': string;
    /**
    * Specifies the post office box number.
    */
    'pOBox': string;
    /**
    * Specifies the post office box number.
    */
    'pOBoxInput': string;
    /**
    * Specifies the result of post office box number.
    */
    'pOBoxResult': string;
    /**
    * Specifies the validated postal code. For U.S. addresses, this is the ZIP code.
    */
    'postalCodeInput': string;
    /**
    * Specifies the result of validated postal code.
    */
    'postalCodeResult': string;
    /**
    * Specifies the result code.
    */
    'postalCodeSource': string;
    /**
    * Specifies the type of postal code returned.
    */
    'postalCodeType': string;
    /**
    * Specifies the international result code.
    */
    'postalCodeCityResult': string;
    /**
    * Specifies the private mailbox indicator.
    */
    'privateMailbox': string;
    /**
    * Specifies the private mailbox indicator.
    */
    'privateMailboxInput': string;
    /**
    * Specifies the type of private mailbox.
    */
    'privateMailboxType': string;
    /**
    * Specifies the type of private mailbox.
    */
    'privateMailboxTypeInput': string;
    /**
    * Specifies the type of address record, as defined by U.S. and Canadian postal authorities.
    */
    'recordType': string;
    /**
    * Specifies the code indicating the default match.
    */
    'recordTypeDefault': string;
    /**
    * Specifies the Rural Route/Highway Contract indicator.
    */
    'rRHC': string;
    /**
    * Specifies the Rural Route/Highway Contract indicator.
    */
    'rRHCInput': string;
    /**
    * Specifies the result for Rural Route/Highway Contract indicator.
    */
    'rRHCResult': string;
    /**
    * Specifies the result code for Rural Route/Highway Contract indicator.
    */
    'rRHCType': string;
    /**
    * Specifies the validated state or province abbreviation.
    */
    'stateProvinceInput': string;
    /**
    * Specifies the result of validated state or province abbreviation.
    */
    'stateProvinceResult': string;
    /**
    * Specifies the result codes for international addresses.
    */
    'streetResult': string;
    /**
    * Specifies the street name.
    */
    'streetName': string;
    /**
    * Specifies result code that applies to U.S. addresses only.
    */
    'streetNameAliasType': string;
    /**
    * Specifies the street name.
    */
    'streetNameInput': string;
    /**
    * Specifies the result of the street name.
    */
    'streetNameResult': string;
    /**
    * Indicates the result of abbreviated alias processing.
    */
    'streetNameAbbreviatedAliasResult': string;
    /**
    * Specifies the result of preferred alias processing.
    */
    'streetNamePreferredAliasResult': string;
    /**
    * Specifies the street suffix.
    */
    'streetSuffix': string;
    /**
    * Specifies the street suffix.
    */
    'streetSuffixInput': string;
    /**
    * Specifies the result of the street suffix.
    */
    'streetSuffixResult': string;
    /**
    * Specifies the trailing directional.
    */
    'trailingDirectional': string;
    /**
    * Specifies the trailing directional.
    */
    'trailingDirectionalInput': string;
    /**
    * Specifies the result of the trailing directional.
    */
    'trailingDirectionalResult': string;
    /**
    * Specifies an indication of the degree to which the output address is correct.
    */
    'matchScore': string;
    /**
    * Specifies whether the address is a candidate for LACS conversion. This is for U.S. addresses only).
    */
    'uSLACS': string;
    /**
    * Specifies the the success or failure of LACS processing. This is for U.S. addresses only).
    */
    'uSLACSReturnCode': string;
    /**
    * Specifies the values indicating address type.
    */
    'rDI': string;
    /**
    * Specifies if the address is a Commercial Mail Receiving Agency (CMRA).
    */
    'cMRA': string;
    /**
    * Specifies the results of Delivery Point Validation (DPV) processing.
    */
    'dPV': string;
    /**
    * Specifies the DPV footnote codes.
    */
    'dPVFootnote': string;
    /**
    * Indicates whether or not API corrected the secondary address information (U.S. addresses only). 
    */
    'suiteLinkReturnCode': string;
    /**
    * Provides additional information on the SuiteLink match attempt. (U.S. addresses only)
    */
    'suiteLinkMatchCode': string;
    /**
    * Indicates how well ValidateAddress matched the firm name to the firm names in the SuiteLink database.
    */
    'suiteLinkFidelity': string;
    /**
    * Specifies the check-digit portion of the 11-digit delivery point barcode.
    */
    'uSBCCheckDigit': string;
    /**
    * Specifies the delivery point portion of the delivery point barcode.
    */
    'postalBarCode': string;
    /**
    * Specifies carrier route code.
    */
    'uSCarrierRouteCode': string;
    /**
    * Specifies FIPS (Federal Information Processing Standards) county number (U.S. addresses only).
    */
    'uSFIPSCountyNumber': string;
    /**
    * Specifies the county name (U.S. addresses only).
    */
    'uSCountyName': string;
    /**
    * Specifies congressional district (U.S. addresses only).
    */
    'uSCongressionalDistrict': string;
    /**
    * Specifies whether the alternate address matching logic was used, and if so which logic was used (U.S. addresses only).
    */
    'uSAltAddr': string;
    /**
    * Specifies a six-character alphanumeric value that groups together ZIP Codes that share the same primary city.
    */
    'uSLastLineNumber': string;
    /**
    * Specifies the finance number in which the address resides (U.S. addresses only).
    */
    'uSFinanceNumber': string;
    /**
    * U.S. address urbanization name. Used primarily for Puerto Rico addresses.
    */
    'uSUrbanName': string;
    /**
    * U.S. address urbanization name. Used primarily for Puerto Rico addresses.
    */
    'uSUrbanNameInput': string;
    /**
    * U.S. address urbanization name. Used primarily for Puerto Rico addresses.
    */
    'uSUrbanNameResult': string;
    /**
    * If the address was matched to multiple candidate addresses in the reference data, this field contains the number of candidate matches found.
    */
    'multimatchCount': string;
    /**
    * AddressBlock1
    */
    'addressBlock1': string;
    /**
    * AddressBlock2
    */
    'addressBlock2': string;
    /**
    * AddressBlock3
    */
    'addressBlock3': string;
    /**
    * AddressBlock4
    */
    'addressBlock4': string;
    /**
    * AddressBlock5
    */
    'addressBlock5': string;
    /**
    * AddressBlock6
    */
    'addressBlock6': string;
    /**
    * AddressBlock7
    */
    'addressBlock7': string;
    /**
    * AddressBlock8
    */
    'addressBlock8': string;
    /**
    * AddressBlock9
    */
    'addressBlock9': string;
    /**
    * Specifies whether the address is in English or French. This is for Canadian address only.
    */
    'canLanguage': string;
    /**
    * Specifies whether the building is a no stat building and therefore unable to receive mail.
    */
    'dPVNoStat': string;
    /**
    * Specifies whether the building is vacant, unoccupied for 90 days.
    */
    'dPVVacant': string;
}

export class ValidateMailingAddressUSCANAPIRequest {
    'options': ValidateMailingAddressUSCANAPIOptions;
    'input': ValidateMailingAddressUSCANAPIInput;
}

export class ValidateMailingAddressUSCANAPIResponse {
    'output': Array<ValidateMailingAddressUSCANAPIOutput>;
}

export class WaterBody {
    'name': string;
    'distance': ShoreLineDistance;
    'type': Type;
}

export class WaterBodyLocationResponse {
    'waterBody': Array<WaterBody>;
}

export class WaterBodyResponse {
    'waterBody': Array<WaterBody>;
    'matchedAddress': MatchedAddress;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    getOAuthCredentials(requestOptions: request.Options): Promise<{body: oAuthCredInfo;  }>;
}

/*export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}*/

/*export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}*/

    export class OAuth implements Authentication {
    public objOAuthCredInfo: oAuthCredInfo;

    public oAuthApiKey : string;
    public oAuthSecret : string;
    public oAuthUrl :string;
    public oAuthToken :string;

    constructor()
    constructor(oAuthApiKey?: string, oAuthSecret?: string) {
    this.oAuthApiKey=oAuthApiKey;
    this.oAuthSecret=oAuthSecret;
    }


    public getOAuthCredentials(): Promise<{ response: http.IncomingMessage; body: oAuthCredInfo; }> {

    if (this.oAuthApiKey === undefined || this.oAuthSecret === undefined ) {
    Promise.reject({response: "Validation Error", body: "oAuthApiKey or oAuthSecret missing"})
    }

    if ((this.objOAuthCredInfo === null || this.objOAuthCredInfo === undefined)) {

    return this.refreshToken();

    }
    else {

    if((Number(this.objOAuthCredInfo.issuedAt) + Number(this.objOAuthCredInfo.expiresIn)) < (moment().valueOf()+ 10000))
    {
    return this.refreshToken();
    }
    return Promise.resolve({response: null, body: this.objOAuthCredInfo})
    }

    }

    private refreshToken():Promise<{ response: http.IncomingMessage; body: oAuthCredInfo; }>{
    this.oAuthToken = "Basic " + new Buffer(this.oAuthApiKey + ":" + this.oAuthSecret).toString('base64')
    //.toString('base64');
    if (this.oAuthUrl === undefined || this.oAuthUrl === null) {
    this.oAuthUrl = "https://api.precisely.com/oauth/token";
    }

    let requestOptions: request.Options = {
    method: 'POST',
    url: this.oAuthUrl,
    headers:
    {
    'cache-control': 'no-cache',
    authorization: this.oAuthToken
    },
    body: 'grant_type=client_credentials'
    };

    return new Promise<{ response: http.IncomingMessage; body: oAuthCredInfo; }>((resolve, reject) => {
    request(requestOptions, (error, response, body) => {
    if (error) {
    reject({response: response, body: JSON.parse(error)});
    } else {
    if (response.statusCode >= 200 && response.statusCode <= 299) {
    this.objOAuthCredInfo = JSON.parse(body);
    resolve({response: response, body: JSON.parse(body)});
    } else {
    reject({response: response, body: JSON.parse(body)});
    }
    }
    });
    });
    }
    }

/*export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}*/

export enum AddressVerificationServiceApiApiKeys {
}

export class AddressVerificationServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AddressVerificationServiceApiApiKeys, value: string) {
        this.authentications[AddressVerificationServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * GetCityStateProvince
     * GetCityStateProvince returns a city and state/province for a given input postal code for U.S. and Canadian addresses.
     * @param inputAddress 
     */
    public getCityStateProvince (inputAddress: GetCityStateProvinceAPIRequest) : Promise<{ response: http.IncomingMessage; body: GetCityStateProvinceAPIResponse;  }> {
        const localVarPath = this.basePath + '/addressverification/v1/getcitystateprovince/results.json';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'inputAddress' is not null or undefined
        if (inputAddress === null || inputAddress === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter inputAddress was null or undefined when calling getCityStateProvince."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: inputAddress,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GetCityStateProvinceAPIResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * GetPostalCodes
     * GetPostalCodes takes a city and state as input for U.S. addresses and returns the postal codes for that city.
     * @param inputAddress 
     */
    public getPostalCodes (inputAddress: GetPostalCodesAPIRequest) : Promise<{ response: http.IncomingMessage; body: GetPostalCodesAPIResponse;  }> {
        const localVarPath = this.basePath + '/addressverification/v1/getpostalcodes/results.json';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'inputAddress' is not null or undefined
        if (inputAddress === null || inputAddress === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter inputAddress was null or undefined when calling getPostalCodes."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: inputAddress,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GetPostalCodesAPIResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * ValidateMailingAddress
     * ValidateMailingAddress analyses and compares the input addresses against the known address databases around the world to output a standardized detail.
     * @param inputAddress 
     */
    public validateMailingAddress (inputAddress: ValidateMailingAddressRequest) : Promise<{ response: http.IncomingMessage; body: ValidateMailingAddressResponse;  }> {
        const localVarPath = this.basePath + '/addressverification/v1/validatemailingaddress/results.json';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'inputAddress' is not null or undefined
        if (inputAddress === null || inputAddress === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter inputAddress was null or undefined when calling validateMailingAddress."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: inputAddress,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: ValidateMailingAddressResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * ValidateMailingAddressPremium
     * ValidateMailing AddressPremium expands on the ValidateMailingAddressPro service by adding premium address data sources to get the best address validation result possible.
     * @param inputAddress 
     */
    public validateMailingAddressPremium (inputAddress: ValidateMailingAddressPremiumRequest) : Promise<{ response: http.IncomingMessage; body: ValidateMailingAddressPremiumResponse;  }> {
        const localVarPath = this.basePath + '/addressverification/v1/validatemailingaddresspremium/results.json';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'inputAddress' is not null or undefined
        if (inputAddress === null || inputAddress === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter inputAddress was null or undefined when calling validateMailingAddressPremium."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: inputAddress,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: ValidateMailingAddressPremiumResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * ValidateMailingAddressPro
     * ValidateMailingAddressPro builds upon the ValidateMailingAddress service by using additional address databases so it can provide enhanced detail.
     * @param inputAddress 
     */
    public validateMailingAddressPro (inputAddress: ValidateMailingAddressProRequest) : Promise<{ response: http.IncomingMessage; body: ValidateMailingAddressProResponse;  }> {
        const localVarPath = this.basePath + '/addressverification/v1/validatemailingaddresspro/results.json';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'inputAddress' is not null or undefined
        if (inputAddress === null || inputAddress === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter inputAddress was null or undefined when calling validateMailingAddressPro."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: inputAddress,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: ValidateMailingAddressProResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * ValidateMailingAddressUSCAN
     * ValidateMailingAddressUSCAN analyses and compares the input addresses against the known address databases around the world to output a standardized detail for US and CANADAIt gives RDI and DPV also along with other US/CAN specific functionalities.
     * @param inputAddress 
     */
    public validateMailingAddressUSCAN (inputAddress: ValidateMailingAddressUSCANAPIRequest) : Promise<{ response: http.IncomingMessage; body: ValidateMailingAddressUSCANAPIResponse;  }> {
        const localVarPath = this.basePath + '/addressverification/v1/validatemailingaddressuscan/results.json';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'inputAddress' is not null or undefined
        if (inputAddress === null || inputAddress === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter inputAddress was null or undefined when calling validateMailingAddressUSCAN."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: inputAddress,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: ValidateMailingAddressUSCANAPIResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum AddressesAPIServiceApiApiKeys {
}

export class AddressesAPIServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AddressesAPIServiceApiApiKeys, value: string) {
        this.authentications[AddressesAPIServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Addresses By Boundary Area.
     * This service accepts zip code, neighborhood, county, or city names, and returns all known &amp; valid addresses associated with these names.
     * @param country Name of country. Acceptable values are CAN, USA.
     * @param areaName1 Specifies the largest geographical area, typically a state or province.
     * @param areaName2 Specifies the secondary geographic area, typically a county or district.
     * @param areaName3 Specifies a city or town name.
     * @param areaName4 Specifies a city subdivision or locality/neighborhood.
     * @param postCode Specifies the postcode (ZIP code) in the appropriate format for the country.
     * @param maxCandidates Maximum number of addresses to be returned in response. Max. value is 100 for XML/JSON, and 2000 for CSV.
     * @param page Response will indicate the page number.
     */
    public getAddressesByBoundaryName (country: string, areaName1?: string, areaName2?: string, areaName3?: string, areaName4?: string, postCode?: string, maxCandidates?: string, page?: string) : Promise<{ response: http.IncomingMessage; body: AddressesResponse;  }> {
        const localVarPath = this.basePath + '/addresses/v1/address/byboundaryname';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'country' is not null or undefined
        if (country === null || country === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter country was null or undefined when calling getAddressesByBoundaryName."}]}})
        }

        if (areaName1 !== undefined) {
            queryParameters['areaName1'] = areaName1;
        }

        if (areaName2 !== undefined) {
            queryParameters['areaName2'] = areaName2;
        }

        if (areaName3 !== undefined) {
            queryParameters['areaName3'] = areaName3;
        }

        if (areaName4 !== undefined) {
            queryParameters['areaName4'] = areaName4;
        }

        if (postCode !== undefined) {
            queryParameters['postCode'] = postCode;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: AddressesResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Address Counts by Boundary.
     * This service accepts custom geographic boundaries or drivetimes &amp; drive distances, returns the total number of addresses within these boundaries.
     * @param body 
     */
    public getAddressesCountByBoundary (body?: AddressesByBoundaryRequest) : Promise<{ response: http.IncomingMessage; body: AddressesCount;  }> {
        const localVarPath = this.basePath + '/addresses/v1/addresscount/byboundary';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: AddressesCount;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Address Counts by Boundary Name.
     * This service accepts zip code, neighborhood, county, or city names, and returns the total number of addresses associated with these names. 
     * @param country Name of country. Acceptable values are CAN, USA.
     * @param areaName1 Specifies the largest geographical area, typically a state or province.
     * @param areaName2 Specifies the secondary geographic area, typically a county or district.
     * @param areaName3 Specifies a city or town name.
     * @param areaName4 Specifies a city subdivision or locality/neighborhood.
     * @param postCode Specifies the postcode (ZIP code) in the appropriate format for the country.
     */
    public getAddressesCountByBoundaryName (country: string, areaName1?: string, areaName2?: string, areaName3?: string, areaName4?: string, postCode?: string) : Promise<{ response: http.IncomingMessage; body: AddressesCount;  }> {
        const localVarPath = this.basePath + '/addresses/v1/addresscount/byboundaryname';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'country' is not null or undefined
        if (country === null || country === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter country was null or undefined when calling getAddressesCountByBoundaryName."}]}})
        }

        if (areaName1 !== undefined) {
            queryParameters['areaName1'] = areaName1;
        }

        if (areaName2 !== undefined) {
            queryParameters['areaName2'] = areaName2;
        }

        if (areaName3 !== undefined) {
            queryParameters['areaName3'] = areaName3;
        }

        if (areaName4 !== undefined) {
            queryParameters['areaName4'] = areaName4;
        }

        if (postCode !== undefined) {
            queryParameters['postCode'] = postCode;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: AddressesCount;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Addresses by Boundary.
     * This service accepts custom geographic boundaries or drivetimes &amp; drive distances, returns all known &amp; valid addresses within these boundaries.
     * @param body 
     */
    public getAddressesbyBoundary (body?: AddressesByBoundaryRequest) : Promise<{ response: http.IncomingMessage; body: AddressesResponse;  }> {
        const localVarPath = this.basePath + '/addresses/v1/address/byboundary';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: AddressesResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum DemographicsServiceApiApiKeys {
}

export class DemographicsServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: DemographicsServiceApiApiKeys, value: string) {
        this.authentications[DemographicsServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Demographics Advanced Endpoint
     * Demographics Advanced Endpoint will return the aggregated values of the selected demographics variables of the regions falling inside a user provided geometry or travel time/distance boundaries. All the intersecting demographic boundaries will be snapped completely, and user will have option to request these boundaries in response.  
     * @param body 
     */
    public getDemographicsAdvanced (body?: DemographicsAdvancedRequest) : Promise<{ response: http.IncomingMessage; body: Demographics;  }> {
        const localVarPath = this.basePath + '/demographics-segmentation/v1/advanced/demographics';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Demographics;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Demographics Basic
     * Demographics Basic Endpoint will return the aggregated values of the selected demographics variables of the regions falling inside the search radius. All the intersecting demographic boundaries will be snapped completely and user will have option to request these boundaries in response.  
     * @param address Address to be searched
     * @param longitude Longitude of the location
     * @param latitude Latitude of the location
     * @param searchRadius Radius within which demographics details are required. Max. value is 52800 Feet or 10 miles
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters 
     * @param travelTime Travel Time based on ‘travelMode’ within which demographics details are required. Max. value is 1 hour.
     * @param travelTimeUnit minutes,hours,seconds,milliseconds. Default is meters.Default is minutes.
     * @param travelDistance Travel Distance based on ‘travelMode’ within which demographics details are required. Max. value is 10 miles.
     * @param travelDistanceUnit feet,kilometers,miles,meters.  Default is feet.
     * @param travelMode Default is driving.
     * @param country 3 digit ISO country code (Used in case address is mentioned).
     * @param profile Applicable on ranged variables. Returns top sorted result based on the input value.
     * @param filter If Y, demographic boundaries are returned in response.
     * @param includeGeometry 
     */
    public getDemographicsBasic (address?: string, longitude?: string, latitude?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, country?: string, profile?: string, filter?: string, includeGeometry?: string) : Promise<{ response: http.IncomingMessage; body: Demographics;  }> {
        const localVarPath = this.basePath + '/demographics-segmentation/v1/basic/demographics';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (searchRadius !== undefined) {
            queryParameters['searchRadius'] = searchRadius;
        }

        if (searchRadiusUnit !== undefined) {
            queryParameters['searchRadiusUnit'] = searchRadiusUnit;
        }

        if (travelTime !== undefined) {
            queryParameters['travelTime'] = travelTime;
        }

        if (travelTimeUnit !== undefined) {
            queryParameters['travelTimeUnit'] = travelTimeUnit;
        }

        if (travelDistance !== undefined) {
            queryParameters['travelDistance'] = travelDistance;
        }

        if (travelDistanceUnit !== undefined) {
            queryParameters['travelDistanceUnit'] = travelDistanceUnit;
        }

        if (travelMode !== undefined) {
            queryParameters['travelMode'] = travelMode;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (profile !== undefined) {
            queryParameters['profile'] = profile;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (includeGeometry !== undefined) {
            queryParameters['includeGeometry'] = includeGeometry;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Demographics;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Demographics By Address.
     * Provides the demographic details around a specified address. GeoLife &#39;byaddress&#39; service accepts address as an input to return a specific population segment&#39;s age group, ethnicity, income, purchasing behaviour, commuter patterns and more.
     * @param address The address to be searched.
     * @param country 3 letter ISO code of the country to be searched.Allowed values USA,CAN,GBR,AUS.
     * @param profile Retrieves the sorted demographic data on the basis of pre-defined profiles that can display the top 3 or top 5 results (by address) either in ascending or descending order.Allowed values Top5Ascending,Top5Descending,Top3Ascending,Top3Descending
     * @param filter The &#39;filter&#39; parameter retrieves the demographic data based upon specified input themes.
     * @param valueFormat The &#39;valueFormat&#39; parameter is applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
     * @param variableLevel The &#39;variableLevel&#39; retrieves demographic facts in response based on the input value
     */
    public getDemographicsByAddressV2 (address: string, country?: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string) : Promise<{ response: http.IncomingMessage; body: Demographics;  }> {
        const localVarPath = this.basePath + '/demographics-segmentation/v1/demographics/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getDemographicsByAddressV2."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (profile !== undefined) {
            queryParameters['profile'] = profile;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (valueFormat !== undefined) {
            queryParameters['valueFormat'] = valueFormat;
        }

        if (variableLevel !== undefined) {
            queryParameters['variableLevel'] = variableLevel;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Demographics;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Demographics By Boundaryids.
     * This endpoint will allow the user to request demographics details by census boundary id. Multiple comma separated boundary ids will be accepted. 
     * @param boundaryIds Accepts comma separated multiple boundary ids.
     * @param profile Applicable on ranged variables. Returns top sorted result based on the input value.
     * @param filter Accept the comma separated theme names and filter response based on value. Maximum 10 can be provided.
     * @param valueFormat Applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
     * @param variableLevel Retrieves demographic facts in response based on the input value.
     */
    public getDemographicsByBoundaryIds (boundaryIds?: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string) : Promise<{ response: http.IncomingMessage; body: Demographics;  }> {
        const localVarPath = this.basePath + '/demographics-segmentation/v1/demographics/byboundaryids';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        if (boundaryIds !== undefined) {
            queryParameters['boundaryIds'] = boundaryIds;
        }

        if (profile !== undefined) {
            queryParameters['profile'] = profile;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (valueFormat !== undefined) {
            queryParameters['valueFormat'] = valueFormat;
        }

        if (variableLevel !== undefined) {
            queryParameters['variableLevel'] = variableLevel;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Demographics;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Demographics By Location.
     * Provides the demographic details around a specified location. GeoLife &#39;bylocation&#39; service accepts longitude and latitude as an input to return a specific population segment&#39;s age group, ethnicity, income, purchasing behaviour, commuter patterns and more.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     * @param profile Retrieves the sorted demographic data on the basis of pre-defined profiles that can display the top 3 or top 5 results (by location) either in ascending or descending order.Allowed values Top5Ascending,Top5Descending,Top3Ascending,Top3Descending
     * @param filter The &#39;filter&#39; parameter retrieves the demographic data based upon specified input themes.
     * @param valueFormat The &#39;valueFormat&#39; parameter is applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
     * @param variableLevel The &#39;variableLevel&#39; retrieves demographic facts in response based on the input value
     */
    public getDemographicsByLocationV2 (longitude: string, latitude: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string) : Promise<{ response: http.IncomingMessage; body: Demographics;  }> {
        const localVarPath = this.basePath + '/demographics-segmentation/v1/demographics/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getDemographicsByLocationV2."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getDemographicsByLocationV2."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (profile !== undefined) {
            queryParameters['profile'] = profile;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (valueFormat !== undefined) {
            queryParameters['valueFormat'] = valueFormat;
        }

        if (variableLevel !== undefined) {
            queryParameters['variableLevel'] = variableLevel;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Demographics;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Segmentation By Address.
     * Provides the segmentation details around a specified address. GeoLife &#39;Segmentation by Address&#39; service accepts address as an input to return the lifestyle characteristics of households in terms of their family status, children characteristics, income behaviors, financial preferences and interests.
     * @param address The address to be searched.
     * @param country 3 letter ISO code of the country to be searched.Allowed values USA,CAN,GBR,FRA,ITA,AUS,DEU.
     */
    public getSegmentationByAddress (address: string, country?: string) : Promise<{ response: http.IncomingMessage; body: Segmentation;  }> {
        const localVarPath = this.basePath + '/demographics-segmentation/v1/segmentation/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getSegmentationByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Segmentation;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Segmentation By Location.
     * Provides the segmentation details around a specified location. GeoLife &#39;segmentation bylocation&#39; service accepts longitude and latitude as an input to return the lifestyle characteristics of households in terms of their family status, children characteristics, income behaviors, financial preferences and interests.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     */
    public getSegmentationByLocation (longitude: string, latitude: string) : Promise<{ response: http.IncomingMessage; body: Segmentation;  }> {
        const localVarPath = this.basePath + '/demographics-segmentation/v1/segmentation/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getSegmentationByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getSegmentationByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Segmentation;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum EmailVerificationServiceApiApiKeys {
}

export class EmailVerificationServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: EmailVerificationServiceApiApiKeys, value: string) {
        this.authentications[EmailVerificationServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * ValidateEmailAddress
     * Confirm that your customer’s mailing address exists and that mail and packages can be delivered to it.
     * @param inputEmailAddress 
     */
    public validateEmailAddress (inputEmailAddress: ValidateEmailAddressAPIRequest) : Promise<{ response: http.IncomingMessage; body: ValidateEmailAddressAPIResponse;  }> {
        const localVarPath = this.basePath + '/emailverification/v1/validateemailaddress/results.json';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'inputEmailAddress' is not null or undefined
        if (inputEmailAddress === null || inputEmailAddress === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter inputEmailAddress was null or undefined when calling validateEmailAddress."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: inputEmailAddress,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: ValidateEmailAddressAPIResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum GeocodeServiceApiApiKeys {
}

export class GeocodeServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: GeocodeServiceApiApiKeys, value: string) {
        this.authentications[GeocodeServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Get Forward Geocode
     * This service accepts an address and returns the location coordinates corresponding to that address. Premium offers the best accuracy and is a high precision geocoder leveraging Master Location Data - geocodes to Street or building level.
     * @param datapackBundle value of datapackBundle
     * @param country Country name or ISO code.
     * @param placeName Building name, place name, Point of Interest (POI), company or firm name associated with the input address.
     * @param mainAddress Single line input, treated as collection of field elements.
     * @param lastLine The last line of the address.
     * @param areaName1 Specifies the largest geographical area, typically a state or province.
     * @param areaName2 Specifies the secondary geographic area, typically a county or district.
     * @param areaName3 Specifies a city or town name.
     * @param areaName4 Specifies a city subdivision or locality.
     * @param postalCode The postal code in the appropriate format for the country.
     * @param matchMode Match modes determine the leniency used to make a match between the input address and the reference data.
     * @param fallbackGeo Specifies whether to attempt to determine a geographic region centroid when an address-level geocode cannot be determined.
     * @param fallbackPostal Specifies whether to attempt to determine a post code centroid when an address-level geocode cannot be determined.
     * @param maxCands The maximum number of candidates to return.
     * @param streetOffset Indicates the offset distance from the street segments to use in street-level geocoding.
     * @param streetOffsetUnits Specifies the unit of measurement for the street offset.
     * @param cornerOffset Specifies the distance to offset the street end points in street-level matching.
     * @param cornerOffsetUnits Specifies the unit of measurement for the corner offset.
     */
    public geocode (datapackBundle: string, country?: string, placeName?: string, mainAddress?: string, lastLine?: string, areaName1?: string, areaName2?: string, areaName3?: string, areaName4?: string, postalCode?: number, matchMode?: string, fallbackGeo?: boolean, fallbackPostal?: boolean, maxCands?: number, streetOffset?: number, streetOffsetUnits?: string, cornerOffset?: number, cornerOffsetUnits?: string) : Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponse;  }> {
        const localVarPath = this.basePath + '/geocode/v1/{datapackBundle}/geocode'
            .replace('{' + 'datapackBundle' + '}', String(datapackBundle));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'datapackBundle' is not null or undefined
        if (datapackBundle === null || datapackBundle === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter datapackBundle was null or undefined when calling geocode."}]}})
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (placeName !== undefined) {
            queryParameters['placeName'] = placeName;
        }

        if (mainAddress !== undefined) {
            queryParameters['mainAddress'] = mainAddress;
        }

        if (lastLine !== undefined) {
            queryParameters['lastLine'] = lastLine;
        }

        if (areaName1 !== undefined) {
            queryParameters['areaName1'] = areaName1;
        }

        if (areaName2 !== undefined) {
            queryParameters['areaName2'] = areaName2;
        }

        if (areaName3 !== undefined) {
            queryParameters['areaName3'] = areaName3;
        }

        if (areaName4 !== undefined) {
            queryParameters['areaName4'] = areaName4;
        }

        if (postalCode !== undefined) {
            queryParameters['postalCode'] = postalCode;
        }

        if (matchMode !== undefined) {
            queryParameters['matchMode'] = matchMode;
        }

        if (fallbackGeo !== undefined) {
            queryParameters['fallbackGeo'] = fallbackGeo;
        }

        if (fallbackPostal !== undefined) {
            queryParameters['fallbackPostal'] = fallbackPostal;
        }

        if (maxCands !== undefined) {
            queryParameters['maxCands'] = maxCands;
        }

        if (streetOffset !== undefined) {
            queryParameters['streetOffset'] = streetOffset;
        }

        if (streetOffsetUnits !== undefined) {
            queryParameters['streetOffsetUnits'] = streetOffsetUnits;
        }

        if (cornerOffset !== undefined) {
            queryParameters['cornerOffset'] = cornerOffset;
        }

        if (cornerOffsetUnits !== undefined) {
            queryParameters['cornerOffsetUnits'] = cornerOffsetUnits;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Forward Geocode
     * This is a Batch offering for geocode service. It accepts a single address or a list of addresses and returns location coordinates.
     * @param body Geocode Request Object
     * @param datapackBundle value of datapackBundle
     */
    public geocodeBatch (body: GeocodeRequest, datapackBundle: string) : Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponseList;  }> {
        const localVarPath = this.basePath + '/geocode/v1/{datapackBundle}/geocode'
            .replace('{' + 'datapackBundle' + '}', String(datapackBundle));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter body was null or undefined when calling geocodeBatch."}]}})
        }

        // verify required parameter 'datapackBundle' is not null or undefined
        if (datapackBundle === null || datapackBundle === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter datapackBundle was null or undefined when calling geocodeBatch."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Capabilities
     * Get Capabilities  of Geocode API
     * @param datapackBundle value of datapackBundle
     * @param operation Geocode or ReverseGeocode Operation.
     * @param country Country name or ISO code.
     */
    public getCapabilities (datapackBundle: string, operation?: string, country?: string) : Promise<{ response: http.IncomingMessage; body: GeocodeCapabilitiesResponse;  }> {
        const localVarPath = this.basePath + '/geocode/v1/{datapackBundle}/capabilities'
            .replace('{' + 'datapackBundle' + '}', String(datapackBundle));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'datapackBundle' is not null or undefined
        if (datapackBundle === null || datapackBundle === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter datapackBundle was null or undefined when calling getCapabilities."}]}})
        }

        if (operation !== undefined) {
            queryParameters['operation'] = operation;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeocodeCapabilitiesResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get installed Dictionaries
     * Get installed Dictionaries
     * @param datapackBundle value of datapackBundle
     * @param country Three Letter ISO Country code
     */
    public getDictionaries (datapackBundle: string, country?: string) : Promise<{ response: http.IncomingMessage; body: ConfiguredDictionaryResponse;  }> {
        const localVarPath = this.basePath + '/geocode/v1/{datapackBundle}/dictionaries'
            .replace('{' + 'datapackBundle' + '}', String(datapackBundle));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'datapackBundle' is not null or undefined
        if (datapackBundle === null || datapackBundle === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter datapackBundle was null or undefined when calling getDictionaries."}]}})
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: ConfiguredDictionaryResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get PreciselyID By Address
     * This service accepts an address and returns the corresponding PreciselyID.
     * @param address free form address text
     * @param country Country ISO code.
     */
    public getPreciselyID (address: string, country?: string) : Promise<{ response: http.IncomingMessage; body: PBKeyResponse;  }> {
        const localVarPath = this.basePath + '/geocode/v1/key/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getPreciselyID."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PBKeyResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post PreciselyID By Address
     * This is a Batch offering for &#39;PreciselyID By Address&#39; service. It accepts a single address or a list of addresses and returns the corresponding PreciselyID.
     * @param body 
     */
    public getPreciselyIDs (body: PBKeyAddressRequest) : Promise<{ response: http.IncomingMessage; body: PBKeyResponseList;  }> {
        const localVarPath = this.basePath + '/geocode/v1/key/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter body was null or undefined when calling getPreciselyIDs."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PBKeyResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Key Lookup
     * This service accepts a PreciselyID and returns the corresponding address associated with that PreciselyID.
     * @param key free form text
     * @param type 
     * @param country 
     */
    public keyLookup (key: string, type?: string, country?: string) : Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponse;  }> {
        const localVarPath = this.basePath + '/geocode/v1/keylookup';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter key was null or undefined when calling keyLookup."}]}})
        }

        if (key !== undefined) {
            queryParameters['key'] = key;
        }

        if (type !== undefined) {
            queryParameters['type'] = type;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Key Lookup
     * This service accepts batches of PreciselyID&#39;s and returns the corresponding address associated with those PreciselyID&#39;s.
     * @param body 
     */
    public keyLookupBatch (body?: KeyLookupRequest) : Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponseList;  }> {
        const localVarPath = this.basePath + '/geocode/v1/keylookup';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Reverse Geocode
     * It accepts a single location coordinate or a list of location coordinates and returns addresses.
     * @param datapackBundle value of datapackBundle
     * @param body Request for Reverse Geocode
     */
    public reverseGeocodBatch (datapackBundle: string, body?: ReverseGeocodeRequest) : Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponseList;  }> {
        const localVarPath = this.basePath + '/geocode/v1/{datapackBundle}/reverseGeocode'
            .replace('{' + 'datapackBundle' + '}', String(datapackBundle));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'datapackBundle' is not null or undefined
        if (datapackBundle === null || datapackBundle === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter datapackBundle was null or undefined when calling reverseGeocodBatch."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Reverse Geocode
     * This service accepts location coordinate and returns an address.
     * @param datapackBundle value of datapackBundle
     * @param x Longitude of the location.
     * @param y Latitude of the location.
     * @param country Country name or ISO code.
     * @param coordSysName Coordinate system to convert geometry to in format codespace:code.
     * @param distance Radius in which search is performed.
     * @param distanceUnits Unit of measurement.
     */
    public reverseGeocode (datapackBundle: string, x: number, y: number, country?: string, coordSysName?: string, distance?: number, distanceUnits?: string) : Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponse;  }> {
        const localVarPath = this.basePath + '/geocode/v1/{datapackBundle}/reverseGeocode'
            .replace('{' + 'datapackBundle' + '}', String(datapackBundle));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'datapackBundle' is not null or undefined
        if (datapackBundle === null || datapackBundle === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter datapackBundle was null or undefined when calling reverseGeocode."}]}})
        }

        // verify required parameter 'x' is not null or undefined
        if (x === null || x === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter x was null or undefined when calling reverseGeocode."}]}})
        }

        // verify required parameter 'y' is not null or undefined
        if (y === null || y === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter y was null or undefined when calling reverseGeocode."}]}})
        }

        if (x !== undefined) {
            queryParameters['x'] = x;
        }

        if (y !== undefined) {
            queryParameters['y'] = y;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (coordSysName !== undefined) {
            queryParameters['coordSysName'] = coordSysName;
        }

        if (distance !== undefined) {
            queryParameters['distance'] = distance;
        }

        if (distanceUnits !== undefined) {
            queryParameters['distanceUnits'] = distanceUnits;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum GeolocationServiceApiApiKeys {
}

export class GeolocationServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: GeolocationServiceApiApiKeys, value: string) {
        this.authentications[GeolocationServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Location By IP Address.
     * This service accepts an IP address and returns the location coordinates corresponding to that IP address.
     * @param ipAddress This is the ip address of network connected device. It must be a standard IPv4 octet and a valid external address.
     */
    public getLocationByIPAddress (ipAddress: string) : Promise<{ response: http.IncomingMessage; body: GeoLocationIpAddr;  }> {
        const localVarPath = this.basePath + '/geolocation/v1/location/byipaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'ipAddress' is not null or undefined
        if (ipAddress === null || ipAddress === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter ipAddress was null or undefined when calling getLocationByIPAddress."}]}})
        }

        if (ipAddress !== undefined) {
            queryParameters['ipAddress'] = ipAddress;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoLocationIpAddr;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Location by WiFi Access Point.
     * This service accepts a WiFi access point MAC address and returns the location coordinates corresponding to that access point. Only mac or accessPoint are mandatory parameters (one of them has to be provided), rest are optional.
     * @param mac This should be the 48 bit mac address (or BSSID) of wireless access point. Accepted format is Six groups of two hexadecimal digits, separated by hyphens (-) or colons.
     * @param ssid The service set identifier for wi-fi access point. It should be alphanumeric with maximum 32 characters.
     * @param rsid This is the received signal strength indicator from particular wi-fi access point. It should be a number from -113 to 0 and the unit of this strength is dBm.
     * @param speed This is the connection speed for wi-fi. It should be a number from 0 to 6930 and the unit should be Mbps.
     * @param accessPoint This is the JSON based list of wifi access points in the vicinity of device to be located. This parameter is helpful in case, multiple wifi points are visible and we want to make sure that the location of device is best calculated considering all the access points location.
     */
    public getLocationByWiFiAccessPoint (mac?: string, ssid?: string, rsid?: string, speed?: string, accessPoint?: string) : Promise<{ response: http.IncomingMessage; body: GeoLocationAccessPoint;  }> {
        const localVarPath = this.basePath + '/geolocation/v1/location/byaccesspoint';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        if (mac !== undefined) {
            queryParameters['mac'] = mac;
        }

        if (ssid !== undefined) {
            queryParameters['ssid'] = ssid;
        }

        if (rsid !== undefined) {
            queryParameters['rsid'] = rsid;
        }

        if (speed !== undefined) {
            queryParameters['speed'] = speed;
        }

        if (accessPoint !== undefined) {
            queryParameters['accessPoint'] = accessPoint;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoLocationAccessPoint;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum IdentityProfilesServiceApiApiKeys {
}

export class IdentityProfilesServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: IdentityProfilesServiceApiApiKeys, value: string) {
        this.authentications[IdentityProfilesServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Identities By Address
     * Accepts an Address as input and returns rich localized Identity profiles, demographics, lifestyle segmentations, neighborhood names, property ownership &amp; values, and social affinity insights from twitter, linkedin, and more along with education, job history and other identity information.
     * @param address free form address text
     * @param confidence To adjust quality threshold of data returned. Default is HIGH
     * @param maxCandidates Number of identities returned in response
     * @param theme theme parameter for filtering results
     * @param filter filter params
     */
    public getIdentityByAddress (address: string, confidence?: string, maxCandidates?: string, theme?: string, filter?: string) : Promise<{ response: http.IncomingMessage; body: IdentityResponse;  }> {
        const localVarPath = this.basePath + '/identityprofiles/v1/identity/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getIdentityByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (confidence !== undefined) {
            queryParameters['confidence'] = confidence;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (theme !== undefined) {
            queryParameters['theme'] = theme;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: IdentityResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Identity By Email
     * Accepts an Email address as input and returns rich localized Identity profiles and social affinity insights from twitter, linkedin, and more along with education, job history and other identity information.
     * @param email This specifies the email address
     * @param confidence To adjust quality threshold of data returned. Default is HIGH
     * @param theme theme parameter for filtering results
     * @param filter filter params
     */
    public getIdentityByEmail (email: string, confidence?: string, theme?: string, filter?: string) : Promise<{ response: http.IncomingMessage; body: Identity;  }> {
        const localVarPath = this.basePath + '/identityprofiles/v1/identity/byemail';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter email was null or undefined when calling getIdentityByEmail."}]}})
        }

        if (email !== undefined) {
            queryParameters['email'] = email;
        }

        if (confidence !== undefined) {
            queryParameters['confidence'] = confidence;
        }

        if (theme !== undefined) {
            queryParameters['theme'] = theme;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Identity;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Identity By Twitter
     * Accepts a Twiiter handle as input and returns rich localized Identity profiles and social affinity insights from twitter, linkedin, and more along with education, job history and other identity information.
     * @param twitter Twitter handle of the identity.
     * @param confidence To adjust quality threshold of data returned. Default is HIGH
     * @param theme theme parameter for filtering results
     * @param filter filter params
     */
    public getIdentityByTwitter (twitter: string, confidence?: string, theme?: string, filter?: string) : Promise<{ response: http.IncomingMessage; body: Identity;  }> {
        const localVarPath = this.basePath + '/identityprofiles/v1/identity/bytwitter';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'twitter' is not null or undefined
        if (twitter === null || twitter === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter twitter was null or undefined when calling getIdentityByTwitter."}]}})
        }

        if (twitter !== undefined) {
            queryParameters['twitter'] = twitter;
        }

        if (confidence !== undefined) {
            queryParameters['confidence'] = confidence;
        }

        if (theme !== undefined) {
            queryParameters['theme'] = theme;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Identity;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum LocalTaxServiceApiApiKeys {
}

export class LocalTaxServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LocalTaxServiceApiApiKeys, value: string) {
        this.authentications[LocalTaxServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Post Tax By Address
     * This is a Batch offering for &#39;Tax By Address&#39; service. It accepts a single address, purchase amount or a list of addresses, purchase amounts and retrieve applicable taxes.
     * @param taxRateTypeId The tax rate id.
     * @param body TaxAddressRequest Class Object having tax request.
     */
    public getBatchTaxByAddress (taxRateTypeId: string, body: TaxAddressRequest) : Promise<{ response: http.IncomingMessage; body: TaxResponses;  }> {
        const localVarPath = this.basePath + '/localtax/v1/tax/{taxRateTypeId}/byaddress'
            .replace('{' + 'taxRateTypeId' + '}', String(taxRateTypeId));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'taxRateTypeId' is not null or undefined
        if (taxRateTypeId === null || taxRateTypeId === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter taxRateTypeId was null or undefined when calling getBatchTaxByAddress."}]}})
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter body was null or undefined when calling getBatchTaxByAddress."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxResponses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Tax By Location
     * This is a Batch offering for &#39;Tax By Location&#39; service. It accepts a single location coordinate, purchase amount or a list of location coordinates, purchase amounts and retrieve applicable tax.
     * @param taxRateTypeId The tax rate id.
     * @param body TaxAddressRequest Class Object having tax request.
     */
    public getBatchTaxByLocation (taxRateTypeId: string, body: TaxLocationRequest) : Promise<{ response: http.IncomingMessage; body: TaxLocationResponses;  }> {
        const localVarPath = this.basePath + '/localtax/v1/tax/{taxRateTypeId}/bylocation'
            .replace('{' + 'taxRateTypeId' + '}', String(taxRateTypeId));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'taxRateTypeId' is not null or undefined
        if (taxRateTypeId === null || taxRateTypeId === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter taxRateTypeId was null or undefined when calling getBatchTaxByLocation."}]}})
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter body was null or undefined when calling getBatchTaxByLocation."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxLocationResponses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Taxrate By Address
     * This is a Batch offering for &#39;Taxrate By Address&#39; service. It accepts a single address or a list of addresses and retrieve applicable tax rates.
     * @param taxRateTypeId The tax rate id.
     * @param body TaxRateAddressRequest Class Object having tax rate request.
     */
    public getBatchTaxRateByAddress (taxRateTypeId: string, body: TaxRateAddressRequest) : Promise<{ response: http.IncomingMessage; body: TaxRateResponses;  }> {
        const localVarPath = this.basePath + '/localtax/v1/taxrate/{taxRateTypeId}/byaddress'
            .replace('{' + 'taxRateTypeId' + '}', String(taxRateTypeId));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'taxRateTypeId' is not null or undefined
        if (taxRateTypeId === null || taxRateTypeId === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter taxRateTypeId was null or undefined when calling getBatchTaxRateByAddress."}]}})
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter body was null or undefined when calling getBatchTaxRateByAddress."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxRateResponses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Taxrate By Location
     * This is a Batch offering for &#39;Taxrate By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve applicable tax rates.
     * @param taxRateTypeId The tax rate id.
     * @param body TaxRateLocationRequest Class Object having tax rate request.
     */
    public getBatchTaxRateByLocation (taxRateTypeId: string, body: TaxRateLocationRequest) : Promise<{ response: http.IncomingMessage; body: TaxRateLocationResponses;  }> {
        const localVarPath = this.basePath + '/localtax/v1/taxrate/{taxRateTypeId}/bylocation'
            .replace('{' + 'taxRateTypeId' + '}', String(taxRateTypeId));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'taxRateTypeId' is not null or undefined
        if (taxRateTypeId === null || taxRateTypeId === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter taxRateTypeId was null or undefined when calling getBatchTaxRateByLocation."}]}})
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter body was null or undefined when calling getBatchTaxRateByLocation."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxRateLocationResponses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get IPD Tax by Address
     * This will accept &#39;address&#39; as a parameter and will return one or many IPDs details for that region in which address will fall.
     * @param address The address to be searched.
     * @param returnLatLongFields Y or N (default is N) - Returns Latitude Longitude Fields
     * @param latLongFormat (default is Decimal) - Returns Desired Latitude Longitude Format
     */
    public getIPDTaxByAddress (address: string, returnLatLongFields?: string, latLongFormat?: string) : Promise<{ response: http.IncomingMessage; body: TaxDistrictResponse;  }> {
        const localVarPath = this.basePath + '/localtax/v1/taxdistrict/ipd/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getIPDTaxByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (returnLatLongFields !== undefined) {
            queryParameters['returnLatLongFields'] = returnLatLongFields;
        }

        if (latLongFormat !== undefined) {
            queryParameters['latLongFormat'] = latLongFormat;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxDistrictResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get IPD Tax for batch requests
     * Get IPD Tax for batch requests
     * @param body IPDTaxByAddressBatchRequest Class Object having IPD tax request
     */
    public getIPDTaxByAddressBatch (body: IPDTaxByAddressBatchRequest) : Promise<{ response: http.IncomingMessage; body: TaxDistrictResponseList;  }> {
        const localVarPath = this.basePath + '/localtax/v1/taxdistrict/ipd/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter body was null or undefined when calling getIPDTaxByAddressBatch."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxDistrictResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Tax By Address
     * This service calculates and returns taxes applicable at a specific address. Address, purchase amount and supported tax rate type are inputs to the service.
     * @param taxRateTypeId The tax rate id.
     * @param address The address to be searched.
     * @param purchaseAmount The amount on which tax to be calculated.
     */
    public getSpecificTaxByAddress (taxRateTypeId: string, address: string, purchaseAmount: string) : Promise<{ response: http.IncomingMessage; body: TaxResponse;  }> {
        const localVarPath = this.basePath + '/localtax/v1/tax/{taxRateTypeId}/byaddress'
            .replace('{' + 'taxRateTypeId' + '}', String(taxRateTypeId));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'taxRateTypeId' is not null or undefined
        if (taxRateTypeId === null || taxRateTypeId === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter taxRateTypeId was null or undefined when calling getSpecificTaxByAddress."}]}})
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getSpecificTaxByAddress."}]}})
        }

        // verify required parameter 'purchaseAmount' is not null or undefined
        if (purchaseAmount === null || purchaseAmount === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter purchaseAmount was null or undefined when calling getSpecificTaxByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (purchaseAmount !== undefined) {
            queryParameters['purchaseAmount'] = purchaseAmount;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Tax By Location
     * This service calculates and returns tax applicable at a specific location. Longitude, latitude, purchase amount and supported tax rate type are inputs to the service.
     * @param taxRateTypeId The tax rate id.
     * @param latitude Latitude of the location.
     * @param longitude Longitude of the location.
     * @param purchaseAmount The amount on which tax to be calculated.
     */
    public getSpecificTaxByLocation (taxRateTypeId: string, latitude: string, longitude: string, purchaseAmount: string) : Promise<{ response: http.IncomingMessage; body: TaxResponse;  }> {
        const localVarPath = this.basePath + '/localtax/v1/tax/{taxRateTypeId}/bylocation'
            .replace('{' + 'taxRateTypeId' + '}', String(taxRateTypeId));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'taxRateTypeId' is not null or undefined
        if (taxRateTypeId === null || taxRateTypeId === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter taxRateTypeId was null or undefined when calling getSpecificTaxByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getSpecificTaxByLocation."}]}})
        }

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getSpecificTaxByLocation."}]}})
        }

        // verify required parameter 'purchaseAmount' is not null or undefined
        if (purchaseAmount === null || purchaseAmount === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter purchaseAmount was null or undefined when calling getSpecificTaxByLocation."}]}})
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (purchaseAmount !== undefined) {
            queryParameters['purchaseAmount'] = purchaseAmount;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Taxrate By Address
     * Retrieves tax rates applicable to a specific address. This service accepts address and supported tax rate type as inputs to retrieve applicable tax rates.
     * @param taxRateTypeId The tax rate id.
     * @param address The address to be searched.
     */
    public getSpecificTaxRateByAddress (taxRateTypeId: string, address: string) : Promise<{ response: http.IncomingMessage; body: TaxRateResponse;  }> {
        const localVarPath = this.basePath + '/localtax/v1/taxrate/{taxRateTypeId}/byaddress'
            .replace('{' + 'taxRateTypeId' + '}', String(taxRateTypeId));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'taxRateTypeId' is not null or undefined
        if (taxRateTypeId === null || taxRateTypeId === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter taxRateTypeId was null or undefined when calling getSpecificTaxRateByAddress."}]}})
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getSpecificTaxRateByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxRateResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Taxrate By Location
     * Retrieves tax rates applicable to a specific location. This service accepts longitude, latitude and supported tax rate type as inputs to retrieve applicable tax rates.
     * @param taxRateTypeId The tax rate id.
     * @param latitude Latitude of the location.
     * @param longitude Longitude of the location.
     */
    public getSpecificTaxRateByLocation (taxRateTypeId: string, latitude: string, longitude: string) : Promise<{ response: http.IncomingMessage; body: TaxRateResponse;  }> {
        const localVarPath = this.basePath + '/localtax/v1/taxrate/{taxRateTypeId}/bylocation'
            .replace('{' + 'taxRateTypeId' + '}', String(taxRateTypeId));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'taxRateTypeId' is not null or undefined
        if (taxRateTypeId === null || taxRateTypeId === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter taxRateTypeId was null or undefined when calling getSpecificTaxRateByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getSpecificTaxRateByLocation."}]}})
        }

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getSpecificTaxRateByLocation."}]}})
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxRateResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum NeighborhoodsServiceApiApiKeys {
}

export class NeighborhoodsServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: NeighborhoodsServiceApiApiKeys, value: string) {
        this.authentications[NeighborhoodsServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Place By Location.
     * Identifies and retrieves the nearest neighborhood around a specific location. This Places service accepts latitude &amp; longitude as input and returns a place name.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     * @param levelHint Numeric code of geographic hierarchy level which is classified at six levels.Allowed values 1,2,3,4,5,6
     */
    public getPlaceByLocation (longitude: string, latitude: string, levelHint?: string) : Promise<{ response: http.IncomingMessage; body: PlaceByLocations;  }> {
        const localVarPath = this.basePath + '/neighborhoods/v1/place/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getPlaceByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getPlaceByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (levelHint !== undefined) {
            queryParameters['levelHint'] = levelHint;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PlaceByLocations;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum PhoneVerificationServiceApiApiKeys {
}

export class PhoneVerificationServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PhoneVerificationServiceApiApiKeys, value: string) {
        this.authentications[PhoneVerificationServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Phone verification.
     * This service accepts a phone number as input and returns details distinguishing landline and wireless numbers and also checks if a wireless number can be located.
     * @param phoneNumber E.164 formatted phone number. Accepts digits only. Country Code (1) optional for USA &amp; CAN.
     * @param includeNetworkInfo Y or N (default is Y) – if it is N, then network/carrier details will not be added in the response.
     */
    public phoneVerification (phoneNumber: string, includeNetworkInfo?: string) : Promise<{ response: http.IncomingMessage; body: PhoneVerification;  }> {
        const localVarPath = this.basePath + '/phoneverification/v1/phoneverification';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'phoneNumber' is not null or undefined
        if (phoneNumber === null || phoneNumber === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter phoneNumber was null or undefined when calling phoneVerification."}]}})
        }

        if (phoneNumber !== undefined) {
            queryParameters['phoneNumber'] = phoneNumber;
        }

        if (includeNetworkInfo !== undefined) {
            queryParameters['includeNetworkInfo'] = includeNetworkInfo;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PhoneVerification;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum PlacesServiceApiApiKeys {
}

export class PlacesServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PlacesServiceApiApiKeys, value: string) {
        this.authentications[PlacesServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Returns Category Codes with their sub-categories (if exist), descriptions and SIC Codes mapping
     * Accepts first partial digits or full category codes to filter the response
     * @param categoryCode Specify starting digits or full category code to filter the response
     * @param level Allowed values are 1,2,3. If level&#x3D;1, then only 4 digits category codes will be returned, level&#x3D;2 means only 6 digits category codes   will be returned, level&#x3D;3 means only 11 digits category codes will be returned. Multiple comma-separated values will also be accepted. So level&#x3D;&#39;1,2&#39; means return 4 digits and 6 digits category codes.
     */
    public getCategoryCodeMetadata (categoryCode?: string, level?: string) : Promise<{ response: http.IncomingMessage; body: GeoEnrichMetadataResponse;  }> {
        const localVarPath = this.basePath + '/places/v1/metadata/category';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        if (categoryCode !== undefined) {
            queryParameters['categoryCode'] = categoryCode;
        }

        if (level !== undefined) {
            queryParameters['level'] = level;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoEnrichMetadataResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Points Of Interest Details By Id
     * This service returns complete details of a chosen point of interest by an identifier. The identifier could be selected from Autocomplete API response.
     * @param id POI unique Identifier. Accepts only numbers.
     */
    public getPOIById (id: string) : Promise<{ response: http.IncomingMessage; body: POIPlaces;  }> {
        const localVarPath = this.basePath + '/places/v1/poi/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter id was null or undefined when calling getPOIById."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: POIPlaces;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Points of Interest By Address.
     * Accepts address as an input to retrieve nearby points of interest.
     * @param address Address
     * @param country Country
     * @param name Matched against Name, BrandName and Trade Name. Partial terms are also matched with fuzziness (max edit distance is 1)
     * @param type Matched against the content which defines the type of the poi. 
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. https://developer.precisely.com/download?CategoryCodes.xlsx 
     * @param sicCode Specific SIC Codes/Codes for the desired POIs. Accepts a mix of 4 digit (Top Category) and 8 digit (Low-Level Category) SIC Codes.
     * @param maxCandidates Maximum number of POIs that can be retrieved.
     * @param searchRadius Radius range within which search is performed.
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters.
     * @param travelTime Specifies the travel time within which method searches for results (POIs which can be reached within travel time)the search boundary in terms of time mentioned in &#39;travelTimeUnit&#39;. The results are retrieved from the polygon formed based on the travel time specified. This means search can be done in the mentioned time results be from the mentioned time.
     * @param travelTimeUnit Specifies acceptable time units.Allowed values Minutes,Hours,Seconds and Milliseconds
     * @param travelDistance Specifies the search boundary in terms of distance mentioned in &#39;travelDistanceUnit&#39;. The results are retrieved from the polygon formed based on the travel distance specified.
     * @param travelDistanceUnit Specifies acceptable time units.Allowed values Feet,Kilometers,Miles and Meters
     * @param travelMode Specifies the available mode of commute. This is required when u r trying to do search by travel distance or travel time. Allowed values driving and walking
     * @param sortBy Specifies the order in which POIs are retrieved.
     * @param fuzzyOnName Allowed values are Y/N. If N, the search on name will not allow fuzziness.
     * @param page Will support pagination, by default 1st page with maxCandidates results are returned.
     * @param matchMode 
     * @param specificMatchOn 
     */
    public getPOIsByAddress (address: string, country?: string, name?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, sortBy?: string, fuzzyOnName?: string, page?: string, matchMode?: string, specificMatchOn?: string) : Promise<{ response: http.IncomingMessage; body: GeoEnrichResponse;  }> {
        const localVarPath = this.basePath + '/places/v1/poi/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getPOIsByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (type !== undefined) {
            queryParameters['type'] = type;
        }

        if (categoryCode !== undefined) {
            queryParameters['categoryCode'] = categoryCode;
        }

        if (sicCode !== undefined) {
            queryParameters['sicCode'] = sicCode;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (searchRadius !== undefined) {
            queryParameters['searchRadius'] = searchRadius;
        }

        if (searchRadiusUnit !== undefined) {
            queryParameters['searchRadiusUnit'] = searchRadiusUnit;
        }

        if (travelTime !== undefined) {
            queryParameters['travelTime'] = travelTime;
        }

        if (travelTimeUnit !== undefined) {
            queryParameters['travelTimeUnit'] = travelTimeUnit;
        }

        if (travelDistance !== undefined) {
            queryParameters['travelDistance'] = travelDistance;
        }

        if (travelDistanceUnit !== undefined) {
            queryParameters['travelDistanceUnit'] = travelDistanceUnit;
        }

        if (travelMode !== undefined) {
            queryParameters['travelMode'] = travelMode;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (fuzzyOnName !== undefined) {
            queryParameters['fuzzyOnName'] = fuzzyOnName;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (matchMode !== undefined) {
            queryParameters['matchMode'] = matchMode;
        }

        if (specificMatchOn !== undefined) {
            queryParameters['specificMatchOn'] = specificMatchOn;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoEnrichResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Points of Interest By Area.
     * Accepts postcode or city as an input to retrieve nearby points of interest.
     * @param country Country
     * @param areaName3 Either areaName3 or postcode is required
     * @param postcode1 Either areaName3 or postcode is required
     * @param postcode2 postcode extension
     * @param name Matched against Name, BrandName and Trade Name. Partial terms are also matched with fuzziness (max edit distance is 1)
     * @param type Matched against the content which defines the type of the poi. 
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. https://developer.precisely.com/download?CategoryCodes.xlsx 
     * @param sicCode Specific SIC Codes/Codes for the desired POIs. Accepts a mix of 4 digit (Top Category) and 8 digit (Low-Level Category) SIC Codes.
     * @param maxCandidates Maximum number of POIs that can be retrieved.
     * @param fuzzyOnName Allowed values are Y/N. If N, the search on name will not allow fuzziness.
     * @param page Will support pagination, by default 1st page with maxCandidates results are returned.
     * @param matchMode 
     * @param specificMatchOn 
     */
    public getPOIsByArea (country: string, areaName3?: string, postcode1?: string, postcode2?: string, name?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, fuzzyOnName?: string, page?: string, matchMode?: string, specificMatchOn?: string) : Promise<{ response: http.IncomingMessage; body: GeoEnrichResponse;  }> {
        const localVarPath = this.basePath + '/places/v1/poi/byarea';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'country' is not null or undefined
        if (country === null || country === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter country was null or undefined when calling getPOIsByArea."}]}})
        }

        if (areaName3 !== undefined) {
            queryParameters['areaName3'] = areaName3;
        }

        if (postcode1 !== undefined) {
            queryParameters['postcode1'] = postcode1;
        }

        if (postcode2 !== undefined) {
            queryParameters['postcode2'] = postcode2;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (type !== undefined) {
            queryParameters['type'] = type;
        }

        if (categoryCode !== undefined) {
            queryParameters['categoryCode'] = categoryCode;
        }

        if (sicCode !== undefined) {
            queryParameters['sicCode'] = sicCode;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (fuzzyOnName !== undefined) {
            queryParameters['fuzzyOnName'] = fuzzyOnName;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (matchMode !== undefined) {
            queryParameters['matchMode'] = matchMode;
        }

        if (specificMatchOn !== undefined) {
            queryParameters['specificMatchOn'] = specificMatchOn;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoEnrichResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Points Of Interest By Boundary
     * Accepts a user-defined boundary as input and returns all Points of Interest within the boundary. Additionally, user can filter the response by name, type, standard industrial classifications and category codes.
     * @param accept 
     * @param contentType 
     * @param body 
     */
    public getPOIsByBoundary (accept?: string, contentType?: string, body?: POIByGeometryRequest) : Promise<{ response: http.IncomingMessage; body: Pois;  }> {
        const localVarPath = this.basePath + '/places/v1/poi/byboundary';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        headerParams['Accept'] = accept;

        headerParams['Content-Type'] = contentType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Pois;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Points of Interest By Location.
     * Accepts longitude and latitude as an input to retrieve nearby points of interest.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     * @param searchText Matched against Name, BrandName and Trade Name. Partial terms are also matched with fuzziness (max edit distance is 1)
     * @param type Matched against the content which defines the type of the poi. 
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. https://developer.precisely.com/download?CategoryCodes.xlsx 
     * @param sicCode Specific SIC Codes/Codes for the desired POIs. Accepts a mix of 4 digit (Top Category) and 8 digit (Low-Level Category) SIC Codes.
     * @param maxCandidates Maximum number of POIs that can be retrieved.
     * @param searchRadius Radius range within which search is performed.
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters.
     * @param travelTime Specifies the travel time within which method searches for results (POIs which can be reached within travel time)the search boundary in terms of time mentioned in &#39;travelTimeUnit&#39;. The results are retrieved from the polygon formed based on the travel time specified. This means search can be done in the mentioned time results be from the mentioned time.
     * @param travelTimeUnit Specifies acceptable time units.Allowed values Minutes,Hours,Seconds and Milliseconds
     * @param travelDistance Specifies the search boundary in terms of distance mentioned in &#39;travelDistanceUnit&#39;. The results are retrieved from the polygon formed based on the travel distance specified.
     * @param travelDistanceUnit Specifies acceptable time units.Allowed values Feet,Kilometers,Miles and Meters
     * @param travelMode Specifies the available mode of commute. This is required when u r trying to do search by travel distance or travel time. Allowed values driving and walking
     * @param sortBy Specifies the order in which POIs are retrieved.
     * @param fuzzyOnName Allowed values are Y/N. If N, the search on name will not allow fuzziness.
     * @param page Will support pagination, by default 1st page with maxCandidates results are returned.
     * @param searchOnNameOnly search name description
     * @param matchMode 
     * @param specificMatchOn 
     */
    public getPOIsByLocation (longitude: string, latitude: string, searchText?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, sortBy?: string, fuzzyOnName?: string, page?: string, searchOnNameOnly?: string, matchMode?: string, specificMatchOn?: string) : Promise<{ response: http.IncomingMessage; body: GeoEnrichResponse;  }> {
        const localVarPath = this.basePath + '/places/v1/poi/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getPOIsByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getPOIsByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (searchText !== undefined) {
            queryParameters['searchText'] = searchText;
        }

        if (type !== undefined) {
            queryParameters['type'] = type;
        }

        if (categoryCode !== undefined) {
            queryParameters['categoryCode'] = categoryCode;
        }

        if (sicCode !== undefined) {
            queryParameters['sicCode'] = sicCode;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (searchRadius !== undefined) {
            queryParameters['searchRadius'] = searchRadius;
        }

        if (searchRadiusUnit !== undefined) {
            queryParameters['searchRadiusUnit'] = searchRadiusUnit;
        }

        if (travelTime !== undefined) {
            queryParameters['travelTime'] = travelTime;
        }

        if (travelTimeUnit !== undefined) {
            queryParameters['travelTimeUnit'] = travelTimeUnit;
        }

        if (travelDistance !== undefined) {
            queryParameters['travelDistance'] = travelDistance;
        }

        if (travelDistanceUnit !== undefined) {
            queryParameters['travelDistanceUnit'] = travelDistanceUnit;
        }

        if (travelMode !== undefined) {
            queryParameters['travelMode'] = travelMode;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (fuzzyOnName !== undefined) {
            queryParameters['fuzzyOnName'] = fuzzyOnName;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (searchOnNameOnly !== undefined) {
            queryParameters['searchOnNameOnly'] = searchOnNameOnly;
        }

        if (matchMode !== undefined) {
            queryParameters['matchMode'] = matchMode;
        }

        if (specificMatchOn !== undefined) {
            queryParameters['specificMatchOn'] = specificMatchOn;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoEnrichResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Point of Interests count By Geometry.
     * Accepts geometry/loc/address as an input to count nearby point of interests.
     * @param contentType 
     * @param body 
     */
    public getPOIsCount (contentType?: string, body?: PoiCountRequest) : Promise<{ response: http.IncomingMessage; body: PoiCount;  }> {
        const localVarPath = this.basePath + '/places/v1/poicount';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        headerParams['Content-Type'] = contentType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PoiCount;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Returns SIC Codes with their Industry Titles and Category Codes mapping
     * Accepts first few partial digits or full SIC codes to filter the response
     * @param sicCode Specify starting digits or full sic code to filter the response
     * @param level Allowed values are 1,2. If level&#x3D;1, then only 4 digits sic codes will be returned, level&#x3D;2 means only 8 digits sic codes will be returned. Multiple comma-separated values will also be accepted. So level&#x3D;&#39;1,2&#39; means return both 4 digits and 8 digits sic codes.
     */
    public getSICMetadata (sicCode?: string, level?: string) : Promise<{ response: http.IncomingMessage; body: GeoEnrichMetadataResponse;  }> {
        const localVarPath = this.basePath + '/places/v1/metadata/sic';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        if (sicCode !== undefined) {
            queryParameters['sicCode'] = sicCode;
        }

        if (level !== undefined) {
            queryParameters['level'] = level;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoEnrichMetadataResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Points of Interest Autocomplete.
     * POIs-Autocomplete will return POIs predictions based on the full or partial words specified in the search.The search can then be narrowed based on Location, IP Address or Country along with other supporting filters.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     * @param searchText Matched against Name, BrandName and Trade Name. Partial terms are also matched with fuzziness (max edit distance is 1)
     * @param searchRadius Radius range within which search is performed.
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters.
     * @param travelTime Specifies the travel time within which method searches for results (POIs which can be reached within travel time)the search boundary in terms of time mentioned in &#39;travelTimeUnit&#39;. The results are retrieved from the polygon formed based on the travel time specified. This means search can be done in the mentioned time results be from the mentioned time.
     * @param travelTimeUnit Specifies acceptable time units.Allowed values Minutes,Hours,Seconds and Milliseconds
     * @param travelDistance Specifies the search boundary in terms of distance mentioned in &#39;travelDistanceUnit&#39;. The results are retrieved from the polygon formed based on the travel distance specified.
     * @param travelDistanceUnit Specifies acceptable time units.Allowed values Feet,Kilometers,Miles and Meters
     * @param travelMode Specifies the available mode of commute. This is required when u r trying to do search by travel distance or travel time. Allowed values driving and walking
     * @param country Country
     * @param areaName1 Specifies the largest geographical area, typically a state or province.
     * @param areaName3 Specifies the name of the city or town. 
     * @param postcode1 Postal Code of the input to be searched
     * @param postcode2 Postcode2
     * @param ipAddress IP address of network connected device in standard IPv4 octet and a valid external address.
     * @param autoDetectLocation Specifies whether to auto-detect location from IP address. If &#39;True&#39; is set, the location is detected from the specified ip address. If &#39;False&#39; is set. the search will happen according to country or location.
     * @param type Matched against the content which defines the type of the poi. 
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. https://developer.precisely.com/download?CategoryCodes.xlsx 
     * @param sicCode Specific SIC Codes/Codes for the desired POIs. Accepts a mix of 4 digit (Top Category) and 8 digit (Low-Level Category) SIC Codes.
     * @param maxCandidates Maximum number of POIs that can be retrieved.
     * @param sortBy Specifies the order in which POIs are retrieved.
     * @param searchOnNameOnly specifies search on name
     * @param matchMode 
     * @param specificMatchOn 
     */
    public poisAutocomplete (longitude?: string, latitude?: string, searchText?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, country?: string, areaName1?: string, areaName3?: string, postcode1?: string, postcode2?: string, ipAddress?: string, autoDetectLocation?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, sortBy?: string, searchOnNameOnly?: string, matchMode?: string, specificMatchOn?: string) : Promise<{ response: http.IncomingMessage; body: GeoEnrichResponse;  }> {
        const localVarPath = this.basePath + '/places/v1/poi/autocomplete';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (searchText !== undefined) {
            queryParameters['searchText'] = searchText;
        }

        if (searchRadius !== undefined) {
            queryParameters['searchRadius'] = searchRadius;
        }

        if (searchRadiusUnit !== undefined) {
            queryParameters['searchRadiusUnit'] = searchRadiusUnit;
        }

        if (travelTime !== undefined) {
            queryParameters['travelTime'] = travelTime;
        }

        if (travelTimeUnit !== undefined) {
            queryParameters['travelTimeUnit'] = travelTimeUnit;
        }

        if (travelDistance !== undefined) {
            queryParameters['travelDistance'] = travelDistance;
        }

        if (travelDistanceUnit !== undefined) {
            queryParameters['travelDistanceUnit'] = travelDistanceUnit;
        }

        if (travelMode !== undefined) {
            queryParameters['travelMode'] = travelMode;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (areaName1 !== undefined) {
            queryParameters['areaName1'] = areaName1;
        }

        if (areaName3 !== undefined) {
            queryParameters['areaName3'] = areaName3;
        }

        if (postcode1 !== undefined) {
            queryParameters['postcode1'] = postcode1;
        }

        if (postcode2 !== undefined) {
            queryParameters['postcode2'] = postcode2;
        }

        if (ipAddress !== undefined) {
            queryParameters['ipAddress'] = ipAddress;
        }

        if (autoDetectLocation !== undefined) {
            queryParameters['autoDetectLocation'] = autoDetectLocation;
        }

        if (type !== undefined) {
            queryParameters['type'] = type;
        }

        if (categoryCode !== undefined) {
            queryParameters['categoryCode'] = categoryCode;
        }

        if (sicCode !== undefined) {
            queryParameters['sicCode'] = sicCode;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (searchOnNameOnly !== undefined) {
            queryParameters['searchOnNameOnly'] = searchOnNameOnly;
        }

        if (matchMode !== undefined) {
            queryParameters['matchMode'] = matchMode;
        }

        if (specificMatchOn !== undefined) {
            queryParameters['specificMatchOn'] = specificMatchOn;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoEnrichResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum PropertyInformationServiceApiApiKeys {
}

export class PropertyInformationServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PropertyInformationServiceApiApiKeys, value: string) {
        this.authentications[PropertyInformationServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Get Parcel Boundary By Address
     * Accepts address as input and returns property parcel boundary around that address.
     * @param address free form address text
     * @param accept 
     */
    public getParcelBoundaryByAddress (address: string, accept?: string) : Promise<{ response: http.IncomingMessage; body: ParcelBoundary;  }> {
        const localVarPath = this.basePath + '/property/v1/parcelboundary/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getParcelBoundaryByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        headerParams['Accept'] = accept;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: ParcelBoundary;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Parcel Boundary By Location
     * Accepts latitude/longitude as input and returns property parcel boundary around that location.
     * @param longitude Longitude of Location
     * @param latitude Latitude of Location
     * @param accept 
     */
    public getParcelBoundaryByLocation (longitude: string, latitude: string, accept?: string) : Promise<{ response: http.IncomingMessage; body: ParcelBoundary;  }> {
        const localVarPath = this.basePath + '/property/v1/parcelboundary/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getParcelBoundaryByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getParcelBoundaryByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        headerParams['Accept'] = accept;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: ParcelBoundary;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * PropertyV2 Attributes By Address.
     * GetPropertyAttributesbyAddress Endpoint will take address as an input and will return key property attributes in response. Optionally user will have the option to filter the attributes and will pay for only returned attributes.
     * @param address free form address text
     * @param attributes Case-insensitive comma separated values of property attributes. Response will contain only the input attributes.
     */
    public getPropertyAttributesByAddress (address?: string, attributes?: string) : Promise<{ response: http.IncomingMessage; body: PropertyInfoResponse;  }> {
        const localVarPath = this.basePath + '/property/v2/attributes/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (attributes !== undefined) {
            queryParameters['attributes'] = attributes;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PropertyInfoResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * PropertyV2 Attributes By Address Batch.
     * GetPropertyAttributesbyAddressBatch Endpoint will take the list of addresses as an input and will return key property attributes for the given addresses in response. Optionally user will have the option to filter the attributes and will pay for only returned attributes.
     * @param body 
     */
    public getPropertyAttributesByAddressBatch (body?: PropertyInfoAddressRequest) : Promise<{ response: http.IncomingMessage; body: PropertyInfoResponses;  }> {
        const localVarPath = this.basePath + '/property/v2/attributes/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PropertyInfoResponses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum RisksServiceApiApiKeys {
}

export class RisksServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: RisksServiceApiApiKeys, value: string) {
        this.authentications[RisksServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Get Crime Risk By Address
     * Accepts addresses as input and Returns local crime indexes.
     * @param address Free-form address text.
     * @param type Type of crime like violent crime, property crime, etc., multiple crime type indexes could be requested as comma separated values with &#39;all&#39; as default.)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response
     */
    public getCrimeRiskByAddress (address: string, type?: string, includeGeometry?: string) : Promise<{ response: http.IncomingMessage; body: CrimeRiskResponse;  }> {
        const localVarPath = this.basePath + '/risks/v1/crime/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getCrimeRiskByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (type !== undefined) {
            queryParameters['type'] = type;
        }

        if (includeGeometry !== undefined) {
            queryParameters['includeGeometry'] = includeGeometry;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: CrimeRiskResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Crime Risk By Address
     * This is a Batch offering for &#39;Crime Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve local crime indexes.
     * @param body 
     */
    public getCrimeRiskByAddressBatch (body?: CrimeRiskByAddressRequest) : Promise<{ response: http.IncomingMessage; body: CrimeRiskResponseList;  }> {
        const localVarPath = this.basePath + '/risks/v1/crime/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: CrimeRiskResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Crime Risk By Location
     * Returns the crime data or crime indexes for a given location.
     * @param longitude The longitude of the location
     * @param latitude The latitude of the location
     * @param type Refers to crime type. Valid values are following 11 crime types with &#39;all&#39; as default (more than one can also be given as comma separated types)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response
     */
    public getCrimeRiskByLocation (longitude: string, latitude: string, type?: string, includeGeometry?: string) : Promise<{ response: http.IncomingMessage; body: CrimeRiskLocationResponse;  }> {
        const localVarPath = this.basePath + '/risks/v1/crime/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getCrimeRiskByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getCrimeRiskByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (type !== undefined) {
            queryParameters['type'] = type;
        }

        if (includeGeometry !== undefined) {
            queryParameters['includeGeometry'] = includeGeometry;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: CrimeRiskLocationResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Crime Risk By Location
     * This is a Batch offering for &#39;Crime Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve local crime indexes.
     * @param body 
     */
    public getCrimeRiskByLocationBatch (body?: CrimeRiskByLocationRequest) : Promise<{ response: http.IncomingMessage; body: CrimeRiskLocationResponseList;  }> {
        const localVarPath = this.basePath + '/risks/v1/crime/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: CrimeRiskLocationResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Distance To Flood Hazard By Address
     * Accepts addresses as input and Returns the distance from nearest water bodies along with body name and location.
     * @param address The address of the location
     * @param maxCandidates This specifies the value of maxCandidates
     * @param waterBodyType all (default value), oceanandsea,lake,others,unknown,intermittent
     * @param searchDistance This specifies the search distance
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters
     */
    public getDistanceToFloodHazardByAddress (address: string, maxCandidates?: string, waterBodyType?: string, searchDistance?: string, searchDistanceUnit?: string) : Promise<{ response: http.IncomingMessage; body: WaterBodyResponse;  }> {
        const localVarPath = this.basePath + '/risks/v1/shoreline/distancetofloodhazard/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getDistanceToFloodHazardByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (waterBodyType !== undefined) {
            queryParameters['waterBodyType'] = waterBodyType;
        }

        if (searchDistance !== undefined) {
            queryParameters['searchDistance'] = searchDistance;
        }

        if (searchDistanceUnit !== undefined) {
            queryParameters['searchDistanceUnit'] = searchDistanceUnit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: WaterBodyResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Distance To Flood Hazard By Address
     * This is a Batch offering for &#39;Distance To Flood Hazard By Address&#39; service. It accepts a single address or a list of addresses and retrieve the distance from nearest water bodies along with body name and location.
     * @param body 
     */
    public getDistanceToFloodHazardByAddressBatch (body?: DistanceToFloodHazardAddressRequest) : Promise<{ response: http.IncomingMessage; body: DistanceToFloodHazardResponse;  }> {
        const localVarPath = this.basePath + '/risks/v1/shoreline/distancetofloodhazard/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: DistanceToFloodHazardResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Distance To Flood Hazard By Location
     * Accepts latitude &amp; longitude as input and Returns the distance from nearest water bodies along with body name and location.
     * @param longitude The longitude of the location
     * @param latitude The latitude of the location
     * @param maxCandidates This specifies the value of maxCandidates
     * @param waterBodyType all (default value), oceanandsea,lake,others,unknown,intermittent
     * @param searchDistance This specifies the search distance
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters
     */
    public getDistanceToFloodHazardByLocation (longitude: string, latitude: string, maxCandidates?: string, waterBodyType?: string, searchDistance?: string, searchDistanceUnit?: string) : Promise<{ response: http.IncomingMessage; body: WaterBodyLocationResponse;  }> {
        const localVarPath = this.basePath + '/risks/v1/shoreline/distancetofloodhazard/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getDistanceToFloodHazardByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getDistanceToFloodHazardByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (waterBodyType !== undefined) {
            queryParameters['waterBodyType'] = waterBodyType;
        }

        if (searchDistance !== undefined) {
            queryParameters['searchDistance'] = searchDistance;
        }

        if (searchDistanceUnit !== undefined) {
            queryParameters['searchDistanceUnit'] = searchDistanceUnit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: WaterBodyLocationResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Distance To Flood Hazard By Location
     * This is a Batch offering for &#39;Distance To Flood Hazard By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve the distance from nearest water bodies along with body name and location.
     * @param body 
     */
    public getDistanceToFloodHazardByLocationBatch (body?: DistanceToFloodHazardLocationRequest) : Promise<{ response: http.IncomingMessage; body: DistanceToFloodHazardLocationResponse;  }> {
        const localVarPath = this.basePath + '/risks/v1/shoreline/distancetofloodhazard/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: DistanceToFloodHazardLocationResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Earthquake History
     * Accepts postcode as input and Returns historical earthquake details for a particular postcode.
     * @param postCode 5 digit Postal code to search
     * @param startDate Start time in milliseconds(UTC)
     * @param endDate End time in milliseconds(UTC)
     * @param minMagnitude Minimum richter scale magnitude
     * @param maxMagnitude Maximum Richter scale magnitude
     * @param maxCandidates Maximum response events
     */
    public getEarthquakeHistory (postCode: string, startDate?: string, endDate?: string, minMagnitude?: string, maxMagnitude?: string, maxCandidates?: string) : Promise<{ response: http.IncomingMessage; body: EarthquakeHistory;  }> {
        const localVarPath = this.basePath + '/risks/v1/earthquakehistory';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'postCode' is not null or undefined
        if (postCode === null || postCode === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter postCode was null or undefined when calling getEarthquakeHistory."}]}})
        }

        if (postCode !== undefined) {
            queryParameters['postCode'] = postCode;
        }

        if (startDate !== undefined) {
            queryParameters['startDate'] = startDate;
        }

        if (endDate !== undefined) {
            queryParameters['endDate'] = endDate;
        }

        if (minMagnitude !== undefined) {
            queryParameters['minMagnitude'] = minMagnitude;
        }

        if (maxMagnitude !== undefined) {
            queryParameters['maxMagnitude'] = maxMagnitude;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: EarthquakeHistory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Earthquake Risk By Address
     * Accepts addresses as input and Returns counts of earthquakes for various richter measurements and values.
     * @param address Free-form address text
     * @param richterValue Richter values like R5 (count of richter scale 5 events), R7 (count of richter scale 7 events), R6_GE (count of events &gt;&#x3D; richter scale 6), etc., multiple richter scales could be requested as comma separated values with &#39;all&#39; as default. Valid values: All (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response
     */
    public getEarthquakeRiskByAddress (address: string, richterValue?: string, includeGeometry?: string) : Promise<{ response: http.IncomingMessage; body: EarthquakeRiskResponse;  }> {
        const localVarPath = this.basePath + '/risks/v1/earthquake/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getEarthquakeRiskByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (richterValue !== undefined) {
            queryParameters['richterValue'] = richterValue;
        }

        if (includeGeometry !== undefined) {
            queryParameters['includeGeometry'] = includeGeometry;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: EarthquakeRiskResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Earthquake Risk By Address
     * This is a Batch offering for &#39;Earthquake Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve counts of earthquakes for various richter measurements and values.
     * @param body 
     */
    public getEarthquakeRiskByAddressBatch (body?: EarthquakeRiskByAddressRequest) : Promise<{ response: http.IncomingMessage; body: EarthquakeRiskResponseList;  }> {
        const localVarPath = this.basePath + '/risks/v1/earthquake/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: EarthquakeRiskResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Earthquake Risk By Location
     * Accepts latitude &amp; longitude as input and Returns counts of earthquakes for various richter measurements and values.
     * @param longitude The longitude of the location
     * @param latitude The latitude of the location
     * @param richterValue Richter values like R5 (count of richter scale 5 events), R7 (count of richter scale 7 events), R6_GE (count of events &gt;&#x3D; richter scale 6), etc., multiple richter scales could be requested as comma separated values with &#39;all&#39; as default. Valid values: All (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response
     */
    public getEarthquakeRiskByLocation (longitude: string, latitude: string, richterValue?: string, includeGeometry?: string) : Promise<{ response: http.IncomingMessage; body: EarthquakeRiskLocationResponse;  }> {
        const localVarPath = this.basePath + '/risks/v1/earthquake/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getEarthquakeRiskByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getEarthquakeRiskByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (richterValue !== undefined) {
            queryParameters['richterValue'] = richterValue;
        }

        if (includeGeometry !== undefined) {
            queryParameters['includeGeometry'] = includeGeometry;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: EarthquakeRiskLocationResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Earthquake Risk By Location
     * This is a Batch offering for &#39;Earthquake Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve counts of earthquakes for various richter measurements and values.
     * @param body 
     */
    public getEarthquakeRiskByLocationBatch (body?: EarthquakeRiskByLocationRequest) : Promise<{ response: http.IncomingMessage; body: EarthquakeRiskLocationResponseList;  }> {
        const localVarPath = this.basePath + '/risks/v1/earthquake/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: EarthquakeRiskLocationResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Fire History
     * Accepts postcode as input and Returns fire event details for a particular postcode.
     * @param postCode 5 digit Postal code to search
     * @param startDate Start time in milliseconds(UTC)
     * @param endDate End time in milliseconds(UTC)
     * @param maxCandidates Maximum response events
     */
    public getFireHistory (postCode: string, startDate?: string, endDate?: string, maxCandidates?: string) : Promise<{ response: http.IncomingMessage; body: FireHistory;  }> {
        const localVarPath = this.basePath + '/risks/v1/firehistory';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'postCode' is not null or undefined
        if (postCode === null || postCode === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter postCode was null or undefined when calling getFireHistory."}]}})
        }

        if (postCode !== undefined) {
            queryParameters['postCode'] = postCode;
        }

        if (startDate !== undefined) {
            queryParameters['startDate'] = startDate;
        }

        if (endDate !== undefined) {
            queryParameters['endDate'] = endDate;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireHistory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Fire Risk By Address
     * Accepts addresses as input and Returns fire risk data by risk types.
     * @param address Free-form address text
     */
    public getFireRiskByAddress (address: string) : Promise<{ response: http.IncomingMessage; body: FireRiskResponse;  }> {
        const localVarPath = this.basePath + '/risks/v1/fire/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getFireRiskByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireRiskResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Fire Risk By Address
     * This is a Batch offering for &#39;Fire Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve fire risk data by risk types.
     * @param body 
     */
    public getFireRiskByAddressBatch (body?: FireRiskByAddressRequest) : Promise<{ response: http.IncomingMessage; body: FireRiskResponseList;  }> {
        const localVarPath = this.basePath + '/risks/v1/fire/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireRiskResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Fire Risk By Location
     * Accepts latitude &amp; longitude as input and Returns fire risk data by risk types.
     * @param longitude Longitude of Location
     * @param latitude Latitude of Location
     */
    public getFireRiskByLocation (longitude: string, latitude: string) : Promise<{ response: http.IncomingMessage; body: FireRiskLocationResponse;  }> {
        const localVarPath = this.basePath + '/risks/v1/fire/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getFireRiskByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getFireRiskByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireRiskLocationResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Fire Risk By Location
     * This is a Batch offering for &#39;Fire Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve fire risk data by risk types.
     * @param body 
     */
    public getFireRiskByLocationBatch (body?: FireRiskByLocationRequest) : Promise<{ response: http.IncomingMessage; body: FireRiskLocationResponseList;  }> {
        const localVarPath = this.basePath + '/risks/v1/fire/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireRiskLocationResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Fire Station By Address
     * Accepts addresses as input and Returns nearest fire stations.
     * @param address The address to be searched.
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location.
     * @param travelTime Max travel time from input location to fire station. Maximum allowed is 2 hours
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds.
     * @param travelDistance Maximum travel distance from input location to fire station. Maximum allowed is 50 miles
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
     * @param sortBy Sort the fire stations results by either travel time or travel distance (nearest first). Default sorting is by travel time.
     * @param historicTrafficTimeBucket Historic traffic time slab
     */
    public getFireStationByAddress (address: string, maxCandidates?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, sortBy?: string, historicTrafficTimeBucket?: string) : Promise<{ response: http.IncomingMessage; body: FireStations;  }> {
        const localVarPath = this.basePath + '/risks/v1/firestation/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getFireStationByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (travelTime !== undefined) {
            queryParameters['travelTime'] = travelTime;
        }

        if (travelTimeUnit !== undefined) {
            queryParameters['travelTimeUnit'] = travelTimeUnit;
        }

        if (travelDistance !== undefined) {
            queryParameters['travelDistance'] = travelDistance;
        }

        if (travelDistanceUnit !== undefined) {
            queryParameters['travelDistanceUnit'] = travelDistanceUnit;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (historicTrafficTimeBucket !== undefined) {
            queryParameters['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireStations;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Fire Station By Location
     * Accepts latitude &amp; longitude as input and Returns nearest fire stations.
     * @param longitude Longitude of Location
     * @param latitude Latitude of Location
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3. The retrieved fire stations are distance ordered from the specified location. Maximum of 5 fire stations can be retrieved.
     * @param travelTime Maximum travel time from input location to fire station. Maximum allowed is 2 hours
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds.
     * @param travelDistance Maximum travel distance from input location to fire station. Maximum allowed is 50 miles
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
     * @param sortBy Sorting of fire stations in result by travel time/distance (nearest first from input location).
     * @param historicTrafficTimeBucket Historic traffic time slab
     */
    public getFireStationByLocation (longitude: string, latitude: string, maxCandidates?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, sortBy?: string, historicTrafficTimeBucket?: string) : Promise<{ response: http.IncomingMessage; body: FireStationsLocation;  }> {
        const localVarPath = this.basePath + '/risks/v1/firestation/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getFireStationByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getFireStationByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (travelTime !== undefined) {
            queryParameters['travelTime'] = travelTime;
        }

        if (travelTimeUnit !== undefined) {
            queryParameters['travelTimeUnit'] = travelTimeUnit;
        }

        if (travelDistance !== undefined) {
            queryParameters['travelDistance'] = travelDistance;
        }

        if (travelDistanceUnit !== undefined) {
            queryParameters['travelDistanceUnit'] = travelDistanceUnit;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (historicTrafficTimeBucket !== undefined) {
            queryParameters['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireStationsLocation;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Flood Risk By Address
     * Accepts addresses as input and Returns flood risk data for flood zones and base flood elevation values.
     * @param address Free-text Address
     * @param includeZoneDesc Specifies primary zone description. Valid Values: &#39;Y&#39; or &#39;N&#39;.
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response
     */
    public getFloodRiskByAddress (address: string, includeZoneDesc?: string, includeGeometry?: string) : Promise<{ response: http.IncomingMessage; body: FloodRiskResponse;  }> {
        const localVarPath = this.basePath + '/risks/v1/flood/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getFloodRiskByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (includeZoneDesc !== undefined) {
            queryParameters['includeZoneDesc'] = includeZoneDesc;
        }

        if (includeGeometry !== undefined) {
            queryParameters['includeGeometry'] = includeGeometry;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FloodRiskResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Flood Risk By Address
     * This is a Batch offering for &#39;Flood Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve flood risk data for flood zones and base flood elevation values.
     * @param body 
     */
    public getFloodRiskByAddressBatch (body?: FloodRiskByAddressRequest) : Promise<{ response: http.IncomingMessage; body: FloodRiskResponseList;  }> {
        const localVarPath = this.basePath + '/risks/v1/flood/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FloodRiskResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Flood Risk By Location
     * Accepts latitude &amp; longitude as input and Returns flood risk data for flood zones and base flood elevation values.
     * @param longitude Longitude of Location
     * @param latitude Latitude of Location
     * @param includeZoneDesc Specifies primary zone description. Valid Values: &#39;Y&#39; or &#39;N&#39;. Default: &#39;Y&#39;
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response
     */
    public getFloodRiskByLocation (longitude: string, latitude: string, includeZoneDesc?: string, includeGeometry?: string) : Promise<{ response: http.IncomingMessage; body: FloodRiskLocationResponse;  }> {
        const localVarPath = this.basePath + '/risks/v1/flood/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getFloodRiskByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getFloodRiskByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (includeZoneDesc !== undefined) {
            queryParameters['includeZoneDesc'] = includeZoneDesc;
        }

        if (includeGeometry !== undefined) {
            queryParameters['includeGeometry'] = includeGeometry;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FloodRiskLocationResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Flood Risk By Location
     * This is a Batch offering for &#39;Flood Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve flood risk data for flood zones and base flood elevation values.
     * @param body 
     */
    public getFloodRiskByLocationBatch (body?: FloodRiskByLocationRequest) : Promise<{ response: http.IncomingMessage; body: FloodRiskLocationResponseList;  }> {
        const localVarPath = this.basePath + '/risks/v1/flood/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FloodRiskLocationResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum RoutingServiceApiApiKeys {
}

export class RoutingServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: RoutingServiceApiApiKeys, value: string) {
        this.authentications[RoutingServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Gets Route by Address
     * Routing Directions for Single and Multiple Origin &amp; Destination Inputs. Accepts addresses as input and Returns Point-to-Point and Multi-Point travel directions by various travel modes.
     * @param startAddress Starting address of the route.
     * @param endAddress Ending address of the route.
     * @param db Mode of commute.
     * @param country Three digit ISO country code
     * @param intermediateAddresses List of intermediate addresses of the route.
     * @param oip Specifies whether waypoints need to be optimized.
     * @param destinationSrs Specifies the desired coordinate system of the returned route.
     * @param optimizeBy Specifies whether the route should be optimized by time or distance.
     * @param returnDistance Specifies whether distance needs to be part of direction information in response.
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param returnTime Specifies whether time needs to be part of direction information in response.
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
     * @param language Language of travel directions.
     * @param directionsStyle Specifies whether route directions text is to be returned in the response and in what detail (Normal or Terse).
     * @param segmentGeometryStyle Specifies whether the route geometry is to be returned in the response and in what detail (End or All).
     * @param primaryNameOnly If true then only the primary street name is returned otherwise all the names for a street.
     * @param majorRoads Whether to include all roads in route calculation or just major roads.
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds.
     * @param returnDirectionGeometry Whether to include geometry associated with each route instruction in response.
     * @param useCvr This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs
     * @param looseningBarrierRestrictions Specifies that barriers will be removed when determining the route
     * @param vehicleType vehicle type
     * @param weight Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param weightUnit The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton)
     * @param height Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param heightUnit The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile)
     * @param length Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param lengthUnit The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile)
     * @param width Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param widthUnit The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile)
     * @param returnIntermediatePoints Specifies whether Intermediate points needs to be part of response.
     */
    public getRouteByAddress (startAddress: string, endAddress: string, db?: string, country?: string, intermediateAddresses?: string, oip?: string, destinationSrs?: string, optimizeBy?: string, returnDistance?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, language?: string, directionsStyle?: string, segmentGeometryStyle?: string, primaryNameOnly?: string, majorRoads?: string, historicTrafficTimeBucket?: string, returnDirectionGeometry?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string, returnIntermediatePoints?: string) : Promise<{ response: http.IncomingMessage; body: GeoRouteResponse;  }> {
        const localVarPath = this.basePath + '/routing/v1/route/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'startAddress' is not null or undefined
        if (startAddress === null || startAddress === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter startAddress was null or undefined when calling getRouteByAddress."}]}})
        }

        // verify required parameter 'endAddress' is not null or undefined
        if (endAddress === null || endAddress === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter endAddress was null or undefined when calling getRouteByAddress."}]}})
        }

        if (startAddress !== undefined) {
            queryParameters['startAddress'] = startAddress;
        }

        if (endAddress !== undefined) {
            queryParameters['endAddress'] = endAddress;
        }

        if (db !== undefined) {
            queryParameters['db'] = db;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (intermediateAddresses !== undefined) {
            queryParameters['intermediateAddresses'] = intermediateAddresses;
        }

        if (oip !== undefined) {
            queryParameters['oip'] = oip;
        }

        if (destinationSrs !== undefined) {
            queryParameters['destinationSrs'] = destinationSrs;
        }

        if (optimizeBy !== undefined) {
            queryParameters['optimizeBy'] = optimizeBy;
        }

        if (returnDistance !== undefined) {
            queryParameters['returnDistance'] = returnDistance;
        }

        if (distanceUnit !== undefined) {
            queryParameters['distanceUnit'] = distanceUnit;
        }

        if (returnTime !== undefined) {
            queryParameters['returnTime'] = returnTime;
        }

        if (timeUnit !== undefined) {
            queryParameters['timeUnit'] = timeUnit;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (directionsStyle !== undefined) {
            queryParameters['directionsStyle'] = directionsStyle;
        }

        if (segmentGeometryStyle !== undefined) {
            queryParameters['segmentGeometryStyle'] = segmentGeometryStyle;
        }

        if (primaryNameOnly !== undefined) {
            queryParameters['primaryNameOnly'] = primaryNameOnly;
        }

        if (majorRoads !== undefined) {
            queryParameters['majorRoads'] = majorRoads;
        }

        if (historicTrafficTimeBucket !== undefined) {
            queryParameters['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
        }

        if (returnDirectionGeometry !== undefined) {
            queryParameters['returnDirectionGeometry'] = returnDirectionGeometry;
        }

        if (useCvr !== undefined) {
            queryParameters['useCvr'] = useCvr;
        }

        if (looseningBarrierRestrictions !== undefined) {
            queryParameters['looseningBarrierRestrictions'] = looseningBarrierRestrictions;
        }

        if (vehicleType !== undefined) {
            queryParameters['vehicleType'] = vehicleType;
        }

        if (weight !== undefined) {
            queryParameters['weight'] = weight;
        }

        if (weightUnit !== undefined) {
            queryParameters['weightUnit'] = weightUnit;
        }

        if (height !== undefined) {
            queryParameters['height'] = height;
        }

        if (heightUnit !== undefined) {
            queryParameters['heightUnit'] = heightUnit;
        }

        if (length !== undefined) {
            queryParameters['length'] = length;
        }

        if (lengthUnit !== undefined) {
            queryParameters['lengthUnit'] = lengthUnit;
        }

        if (width !== undefined) {
            queryParameters['width'] = width;
        }

        if (widthUnit !== undefined) {
            queryParameters['widthUnit'] = widthUnit;
        }

        if (returnIntermediatePoints !== undefined) {
            queryParameters['returnIntermediatePoints'] = returnIntermediatePoints;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoRouteResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets Route by Location
     * Returns the fastest or shortest route based on a starting and ending location with optional intermediate points as input.
     * @param startPoint Start Point in &#39;Lat,Long,coordsys&#39; format
     * @param endPoint End Point in &#39;Lat,Long,coordsys&#39; format
     * @param db Mode of commute.
     * @param intermediatePoints List of intermediate points of the route.
     * @param oip Specifies whether waypoints need to be optimized.
     * @param destinationSrs Specifies the desired coordinate system of the returned route.
     * @param optimizeBy Specifies whether the route should be optimized by time or distance.
     * @param returnDistance Specifies whether distance needs to be part of direction information in response.
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param returnTime Specifies whether time needs to be part of direction information in response.
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
     * @param language Specifies the language of travel directions.
     * @param directionsStyle Specifies whether route directions text is to be returned in the response and in what detail (Normal or Terse).
     * @param segmentGeometryStyle Specifies whether the route geometry is to be returned in the response and in what detail (End or All).
     * @param primaryNameOnly If true then only the primary street name is returned otherwise all the names for a street.
     * @param majorRoads Whether to include all roads in route calculation or just major roads.
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds.
     * @param returnDirectionGeometry Whether to include geometry associated with each route instruction in response.
     * @param useCvr This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs
     * @param looseningBarrierRestrictions Specifies that barriers will be removed when determining the route
     * @param vehicleType vehicle type
     * @param weight Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param weightUnit The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton)
     * @param height Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param heightUnit The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile)
     * @param length Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param lengthUnit The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile)
     * @param width Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param widthUnit The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile)
     * @param returnIntermediatePoints Specifies whether Intermediate points needs to be part of response.
     */
    public getRouteByLocation (startPoint: string, endPoint: string, db?: string, intermediatePoints?: string, oip?: string, destinationSrs?: string, optimizeBy?: string, returnDistance?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, language?: string, directionsStyle?: string, segmentGeometryStyle?: string, primaryNameOnly?: string, majorRoads?: string, historicTrafficTimeBucket?: string, returnDirectionGeometry?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string, returnIntermediatePoints?: string) : Promise<{ response: http.IncomingMessage; body: GeoRouteResponse;  }> {
        const localVarPath = this.basePath + '/routing/v1/route/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'startPoint' is not null or undefined
        if (startPoint === null || startPoint === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter startPoint was null or undefined when calling getRouteByLocation."}]}})
        }

        // verify required parameter 'endPoint' is not null or undefined
        if (endPoint === null || endPoint === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter endPoint was null or undefined when calling getRouteByLocation."}]}})
        }

        if (startPoint !== undefined) {
            queryParameters['startPoint'] = startPoint;
        }

        if (endPoint !== undefined) {
            queryParameters['endPoint'] = endPoint;
        }

        if (db !== undefined) {
            queryParameters['db'] = db;
        }

        if (intermediatePoints !== undefined) {
            queryParameters['intermediatePoints'] = intermediatePoints;
        }

        if (oip !== undefined) {
            queryParameters['oip'] = oip;
        }

        if (destinationSrs !== undefined) {
            queryParameters['destinationSrs'] = destinationSrs;
        }

        if (optimizeBy !== undefined) {
            queryParameters['optimizeBy'] = optimizeBy;
        }

        if (returnDistance !== undefined) {
            queryParameters['returnDistance'] = returnDistance;
        }

        if (distanceUnit !== undefined) {
            queryParameters['distanceUnit'] = distanceUnit;
        }

        if (returnTime !== undefined) {
            queryParameters['returnTime'] = returnTime;
        }

        if (timeUnit !== undefined) {
            queryParameters['timeUnit'] = timeUnit;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (directionsStyle !== undefined) {
            queryParameters['directionsStyle'] = directionsStyle;
        }

        if (segmentGeometryStyle !== undefined) {
            queryParameters['segmentGeometryStyle'] = segmentGeometryStyle;
        }

        if (primaryNameOnly !== undefined) {
            queryParameters['primaryNameOnly'] = primaryNameOnly;
        }

        if (majorRoads !== undefined) {
            queryParameters['majorRoads'] = majorRoads;
        }

        if (historicTrafficTimeBucket !== undefined) {
            queryParameters['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
        }

        if (returnDirectionGeometry !== undefined) {
            queryParameters['returnDirectionGeometry'] = returnDirectionGeometry;
        }

        if (useCvr !== undefined) {
            queryParameters['useCvr'] = useCvr;
        }

        if (looseningBarrierRestrictions !== undefined) {
            queryParameters['looseningBarrierRestrictions'] = looseningBarrierRestrictions;
        }

        if (vehicleType !== undefined) {
            queryParameters['vehicleType'] = vehicleType;
        }

        if (weight !== undefined) {
            queryParameters['weight'] = weight;
        }

        if (weightUnit !== undefined) {
            queryParameters['weightUnit'] = weightUnit;
        }

        if (height !== undefined) {
            queryParameters['height'] = height;
        }

        if (heightUnit !== undefined) {
            queryParameters['heightUnit'] = heightUnit;
        }

        if (length !== undefined) {
            queryParameters['length'] = length;
        }

        if (lengthUnit !== undefined) {
            queryParameters['lengthUnit'] = lengthUnit;
        }

        if (width !== undefined) {
            queryParameters['width'] = width;
        }

        if (widthUnit !== undefined) {
            queryParameters['widthUnit'] = widthUnit;
        }

        if (returnIntermediatePoints !== undefined) {
            queryParameters['returnIntermediatePoints'] = returnIntermediatePoints;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoRouteResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets Cost Matrix by Address
     * Calculates the travel time and distances between an array of start and end addresses.
     * @param startAddresses Start locations in text based addresses.
     * @param endAddresses End locations in text based addresses.
     * @param db Mode of commute.
     * @param country 3 Digit ISO country code.
     * @param optimizeBy Specifies the type of optimizing to use for the route (time/distance).
     * @param returnDistance Specifies whether to return the travel distance in the response or not.
     * @param destinationSrs Coordinate system used for the returned routes.
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param returnTime Specifies whether to return the travel time in the response or not.
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
     * @param majorRoads Whether to include all roads in routes calculation or just major roads.
     * @param returnOptimalRoutesOnly Specifies whether to return only the optimized route for each start and end point combination.
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds.
     * @param useCvr This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs
     * @param looseningBarrierRestrictions Specifies that barriers will be removed when determining the route
     * @param vehicleType vehicle type
     * @param weight Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param weightUnit The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton)
     * @param height Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param heightUnit The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile)
     * @param length Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param lengthUnit The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile)
     * @param width Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param widthUnit The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile)
     */
    public getTravelCostMatrixByAddress (startAddresses: string, endAddresses: string, db?: string, country?: string, optimizeBy?: string, returnDistance?: string, destinationSrs?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, majorRoads?: string, returnOptimalRoutesOnly?: string, historicTrafficTimeBucket?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string) : Promise<{ response: http.IncomingMessage; body: TravelCostMatrixResponse;  }> {
        const localVarPath = this.basePath + '/routing/v1/travelcostmatrix/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'startAddresses' is not null or undefined
        if (startAddresses === null || startAddresses === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter startAddresses was null or undefined when calling getTravelCostMatrixByAddress."}]}})
        }

        // verify required parameter 'endAddresses' is not null or undefined
        if (endAddresses === null || endAddresses === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter endAddresses was null or undefined when calling getTravelCostMatrixByAddress."}]}})
        }

        if (startAddresses !== undefined) {
            queryParameters['startAddresses'] = startAddresses;
        }

        if (endAddresses !== undefined) {
            queryParameters['endAddresses'] = endAddresses;
        }

        if (db !== undefined) {
            queryParameters['db'] = db;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (optimizeBy !== undefined) {
            queryParameters['optimizeBy'] = optimizeBy;
        }

        if (returnDistance !== undefined) {
            queryParameters['returnDistance'] = returnDistance;
        }

        if (destinationSrs !== undefined) {
            queryParameters['destinationSrs'] = destinationSrs;
        }

        if (distanceUnit !== undefined) {
            queryParameters['distanceUnit'] = distanceUnit;
        }

        if (returnTime !== undefined) {
            queryParameters['returnTime'] = returnTime;
        }

        if (timeUnit !== undefined) {
            queryParameters['timeUnit'] = timeUnit;
        }

        if (majorRoads !== undefined) {
            queryParameters['majorRoads'] = majorRoads;
        }

        if (returnOptimalRoutesOnly !== undefined) {
            queryParameters['returnOptimalRoutesOnly'] = returnOptimalRoutesOnly;
        }

        if (historicTrafficTimeBucket !== undefined) {
            queryParameters['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
        }

        if (useCvr !== undefined) {
            queryParameters['useCvr'] = useCvr;
        }

        if (looseningBarrierRestrictions !== undefined) {
            queryParameters['looseningBarrierRestrictions'] = looseningBarrierRestrictions;
        }

        if (vehicleType !== undefined) {
            queryParameters['vehicleType'] = vehicleType;
        }

        if (weight !== undefined) {
            queryParameters['weight'] = weight;
        }

        if (weightUnit !== undefined) {
            queryParameters['weightUnit'] = weightUnit;
        }

        if (height !== undefined) {
            queryParameters['height'] = height;
        }

        if (heightUnit !== undefined) {
            queryParameters['heightUnit'] = heightUnit;
        }

        if (length !== undefined) {
            queryParameters['length'] = length;
        }

        if (lengthUnit !== undefined) {
            queryParameters['lengthUnit'] = lengthUnit;
        }

        if (width !== undefined) {
            queryParameters['width'] = width;
        }

        if (widthUnit !== undefined) {
            queryParameters['widthUnit'] = widthUnit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TravelCostMatrixResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets Cost Matrix by Location
     * GeoRoute&#39;s &#39;Travel Cost Matrix By Location&#39; service calculates the travel time and distances between an array of start and end points based on location coordinates.
     * @param startPoints The address to be searched.
     * @param endPoints The address to be searched.
     * @param db Mode of commute.
     * @param optimizeBy Specifies whether routes should be optimized by time or distance.
     * @param returnDistance Specifies whether distance needs to be returned in response.
     * @param destinationSrs Specifies the desired coordinate system of returned routes.
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param returnTime Specifies whether time needs to be returned in response.
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
     * @param majorRoads Whether to include all roads in routes calculation or just major roads.
     * @param returnOptimalRoutesOnly Specifies whether to return only the optimized route for each start and end point combination.
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds.
     * @param useCvr This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs
     * @param looseningBarrierRestrictions Specifies that barriers will be removed when determining the route
     * @param vehicleType vehicle type
     * @param weight Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param weightUnit The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton)
     * @param height Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param heightUnit The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile)
     * @param length Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param lengthUnit The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile)
     * @param width Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param widthUnit The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile)
     */
    public getTravelCostMatrixByLocation (startPoints: string, endPoints: string, db?: string, optimizeBy?: string, returnDistance?: string, destinationSrs?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, majorRoads?: string, returnOptimalRoutesOnly?: string, historicTrafficTimeBucket?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string) : Promise<{ response: http.IncomingMessage; body: TravelCostMatrixResponse;  }> {
        const localVarPath = this.basePath + '/routing/v1/travelcostmatrix/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'startPoints' is not null or undefined
        if (startPoints === null || startPoints === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter startPoints was null or undefined when calling getTravelCostMatrixByLocation."}]}})
        }

        // verify required parameter 'endPoints' is not null or undefined
        if (endPoints === null || endPoints === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter endPoints was null or undefined when calling getTravelCostMatrixByLocation."}]}})
        }

        if (startPoints !== undefined) {
            queryParameters['startPoints'] = startPoints;
        }

        if (endPoints !== undefined) {
            queryParameters['endPoints'] = endPoints;
        }

        if (db !== undefined) {
            queryParameters['db'] = db;
        }

        if (optimizeBy !== undefined) {
            queryParameters['optimizeBy'] = optimizeBy;
        }

        if (returnDistance !== undefined) {
            queryParameters['returnDistance'] = returnDistance;
        }

        if (destinationSrs !== undefined) {
            queryParameters['destinationSrs'] = destinationSrs;
        }

        if (distanceUnit !== undefined) {
            queryParameters['distanceUnit'] = distanceUnit;
        }

        if (returnTime !== undefined) {
            queryParameters['returnTime'] = returnTime;
        }

        if (timeUnit !== undefined) {
            queryParameters['timeUnit'] = timeUnit;
        }

        if (majorRoads !== undefined) {
            queryParameters['majorRoads'] = majorRoads;
        }

        if (returnOptimalRoutesOnly !== undefined) {
            queryParameters['returnOptimalRoutesOnly'] = returnOptimalRoutesOnly;
        }

        if (historicTrafficTimeBucket !== undefined) {
            queryParameters['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
        }

        if (useCvr !== undefined) {
            queryParameters['useCvr'] = useCvr;
        }

        if (looseningBarrierRestrictions !== undefined) {
            queryParameters['looseningBarrierRestrictions'] = looseningBarrierRestrictions;
        }

        if (vehicleType !== undefined) {
            queryParameters['vehicleType'] = vehicleType;
        }

        if (weight !== undefined) {
            queryParameters['weight'] = weight;
        }

        if (weightUnit !== undefined) {
            queryParameters['weightUnit'] = weightUnit;
        }

        if (height !== undefined) {
            queryParameters['height'] = height;
        }

        if (heightUnit !== undefined) {
            queryParameters['heightUnit'] = heightUnit;
        }

        if (length !== undefined) {
            queryParameters['length'] = length;
        }

        if (lengthUnit !== undefined) {
            queryParameters['lengthUnit'] = lengthUnit;
        }

        if (width !== undefined) {
            queryParameters['width'] = width;
        }

        if (widthUnit !== undefined) {
            queryParameters['widthUnit'] = widthUnit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TravelCostMatrixResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum SchoolsServiceApiApiKeys {
}

export class SchoolsServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: SchoolsServiceApiApiKeys, value: string) {
        this.authentications[SchoolsServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Search Nearby Schools by Address
     * Search Nearby Schools by Address
     * @param address free form address text
     * @param edLevel Single digit code for education level applicable values are P -&gt; primary, M -&gt; Middle, H -&gt; High, O -&gt; Mixed Grades for public school type andE -&gt; Elementary , S -&gt; Secondary , O -&gt; Others mixed grades for private schools 
     * @param schoolType Single digit code for schoolTypes applicable values are PRI and PUB
     * @param schoolSubType Single digit code for schoolSubType Applicable values are C, M, A, R, I, L, P, V, U, S (i.e. Charter, Magnet, Alternative, Regular, Indian, Military, Reportable Program, Vocational, Unknown, Special Education)
     * @param gender Single digit code for gender Applicable values are C, F, M (Coed, All Females, All Males)
     * @param assignedSchoolsOnly Single digit code for assignedSchoolOnly applicable values are  Y/N 
     * @param districtSchoolsOnly Single digit code for districtSchoolOnly applicable values are Y/N 
     * @param searchRadius Search Radius within which schools are searched
     * @param searchRadiusUnit Search Radius unit applicable values are feet,kilometers,miles,meters
     * @param travelTime Travel Time based on ‘travelMode’ within which schools are searched.
     * @param travelTimeUnit Travel Time unit applicable values are minutes,hours,seconds,milliseconds 
     * @param travelDistance Travel Distance based on ‘travelMode’ within which schools are searched.
     * @param travelDistanceUnit Travel distanceUnit applicable values are feet,kilometers,miles,meters
     * @param travelMode Travel mode Required when travelDistance or travelTime is specified. Accepted values are walking,driving
     * @param maxCandidates Max result to search 
     */
    public getSchoolsByAddress (address: string, edLevel?: string, schoolType?: string, schoolSubType?: string, gender?: string, assignedSchoolsOnly?: string, districtSchoolsOnly?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, maxCandidates?: string) : Promise<{ response: http.IncomingMessage; body: SchoolsNearByResponse;  }> {
        const localVarPath = this.basePath + '/schools/v1/school/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getSchoolsByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (edLevel !== undefined) {
            queryParameters['edLevel'] = edLevel;
        }

        if (schoolType !== undefined) {
            queryParameters['schoolType'] = schoolType;
        }

        if (schoolSubType !== undefined) {
            queryParameters['schoolSubType'] = schoolSubType;
        }

        if (gender !== undefined) {
            queryParameters['gender'] = gender;
        }

        if (assignedSchoolsOnly !== undefined) {
            queryParameters['assignedSchoolsOnly'] = assignedSchoolsOnly;
        }

        if (districtSchoolsOnly !== undefined) {
            queryParameters['districtSchoolsOnly'] = districtSchoolsOnly;
        }

        if (searchRadius !== undefined) {
            queryParameters['searchRadius'] = searchRadius;
        }

        if (searchRadiusUnit !== undefined) {
            queryParameters['searchRadiusUnit'] = searchRadiusUnit;
        }

        if (travelTime !== undefined) {
            queryParameters['travelTime'] = travelTime;
        }

        if (travelTimeUnit !== undefined) {
            queryParameters['travelTimeUnit'] = travelTimeUnit;
        }

        if (travelDistance !== undefined) {
            queryParameters['travelDistance'] = travelDistance;
        }

        if (travelDistanceUnit !== undefined) {
            queryParameters['travelDistanceUnit'] = travelDistanceUnit;
        }

        if (travelMode !== undefined) {
            queryParameters['travelMode'] = travelMode;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: SchoolsNearByResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum StreetsServiceApiApiKeys {
}

export class StreetsServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: StreetsServiceApiApiKeys, value: string) {
        this.authentications[StreetsServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Nearest Intersection By Address
     * This service accepts an address as input and returns the Nearest Intersection.
     * @param address Address
     * @param roadClass Filters roads with specified class, allowed values are (Major, Motorways, Other and All), default is All
     * @param driveTime Returns Intersection in specified drive time
     * @param driveTimeUnit Drive time unit, allowed values are (hours, minutes, seconds and milliseconds), default is minutes
     * @param searchRadius Search radius within which user wants to search, default is 50 miles
     * @param searchRadiusUnit Search radius unit, allowed values are (feet, meter, kilometers and miles)
     * @param historicSpeed Traffic flow in peak time, allowed values are (AMPEAK,PMPEAK,OFFPEAK,NIGHT)
     * @param maxCandidates max candidates to be returned default is 1
     */
    public getIntersectionByAddress (address: string, roadClass?: string, driveTime?: string, driveTimeUnit?: string, searchRadius?: string, searchRadiusUnit?: string, historicSpeed?: string, maxCandidates?: string) : Promise<{ response: http.IncomingMessage; body: IntersectionResponse;  }> {
        const localVarPath = this.basePath + '/streets/v1/intersection/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getIntersectionByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (roadClass !== undefined) {
            queryParameters['roadClass'] = roadClass;
        }

        if (driveTime !== undefined) {
            queryParameters['driveTime'] = driveTime;
        }

        if (driveTimeUnit !== undefined) {
            queryParameters['driveTimeUnit'] = driveTimeUnit;
        }

        if (searchRadius !== undefined) {
            queryParameters['searchRadius'] = searchRadius;
        }

        if (searchRadiusUnit !== undefined) {
            queryParameters['searchRadiusUnit'] = searchRadiusUnit;
        }

        if (historicSpeed !== undefined) {
            queryParameters['historicSpeed'] = historicSpeed;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: IntersectionResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Nearest Intersection By Location
     * This service accepts latitude/longitude as input and returns the Nearest Intersection.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     * @param roadClass Filters roads with specified class, allowed values are (Major, Motorways, Other and All), default is All
     * @param driveTime Returns Intersection in specified drive time
     * @param driveTimeUnit Drive time unit, allowed values are (hours, minutes, seconds and milliseconds), default is minutes
     * @param searchRadius Search radius within which user wants to search, default is 50 miles
     * @param searchRadiusUnit Search radius unit, allowed values are (feet, meter, kilometers and miles)
     * @param historicSpeed Traffic flow in peak time, allowed values are (AMPEAK,PMPEAK,OFFPEAK,NIGHT)
     * @param maxCandidates max candidates to be returned default is 1
     */
    public getIntersectionByLocation (longitude: string, latitude: string, roadClass?: string, driveTime?: string, driveTimeUnit?: string, searchRadius?: string, searchRadiusUnit?: string, historicSpeed?: string, maxCandidates?: string) : Promise<{ response: http.IncomingMessage; body: IntersectionResponse;  }> {
        const localVarPath = this.basePath + '/streets/v1/intersection/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getIntersectionByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getIntersectionByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (roadClass !== undefined) {
            queryParameters['roadClass'] = roadClass;
        }

        if (driveTime !== undefined) {
            queryParameters['driveTime'] = driveTime;
        }

        if (driveTimeUnit !== undefined) {
            queryParameters['driveTimeUnit'] = driveTimeUnit;
        }

        if (searchRadius !== undefined) {
            queryParameters['searchRadius'] = searchRadius;
        }

        if (searchRadiusUnit !== undefined) {
            queryParameters['searchRadiusUnit'] = searchRadiusUnit;
        }

        if (historicSpeed !== undefined) {
            queryParameters['historicSpeed'] = historicSpeed;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: IntersectionResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Nearest Speedlimit
     * This service accepts point coordinates of a path as input and returns the posted speed limit of the road segment on which this path will snap.
     * @param path Accepts multiple points which will be snapped to the nearest road segment. Longitude and Latitude will be comma separated (longitude,latitude) and Point Coordinates will be separated by semi-colon(;)
     */
    public getNearestSpeedLimit (path: string) : Promise<{ response: http.IncomingMessage; body: SpeedLimit;  }> {
        const localVarPath = this.basePath + '/streets/v1/speedlimit';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter path was null or undefined when calling getNearestSpeedLimit."}]}})
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: SpeedLimit;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum TelecommInfoServiceApiApiKeys {
}

export class TelecommInfoServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: TelecommInfoServiceApiApiKeys, value: string) {
        this.authentications[TelecommInfoServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Rate Center By Address.
     * Accepts addresses as input and returns Incumbent Local Exchange Carrier (ILEC) doing-business-as names.
     * @param address The address to be searched.
     * @param country 3 letter ISO code of the country to be searched. Allowed values USA,CAN
     * @param areaCodeInfo Specifies whether area code information will be part of response.Allowed values True,False
     * @param level Level (basic/detail).Allowed values detail,basic.
     */
    public getRateCenterByAddress (address: string, country?: string, areaCodeInfo?: string, level?: string) : Promise<{ response: http.IncomingMessage; body: RateCenterResponse;  }> {
        const localVarPath = this.basePath + '/telecomm/v1/ratecenter/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getRateCenterByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (areaCodeInfo !== undefined) {
            queryParameters['AreaCodeInfo'] = areaCodeInfo;
        }

        if (level !== undefined) {
            queryParameters['level'] = level;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: RateCenterResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Rate Center By Location.
     * Accepts latitude &amp; longitude as input and returns Incumbent Local Exchange Carrier (ILEC) doing-business-as names.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     * @param areaCodeInfo Specifies whether area code information will be part of response.Allowed values True,False.
     * @param level Level (basic/detail).Allowed values detail,basic.
     */
    public getRateCenterByLocation (longitude: string, latitude: string, areaCodeInfo?: string, level?: string) : Promise<{ response: http.IncomingMessage; body: RateCenterResponse;  }> {
        const localVarPath = this.basePath + '/telecomm/v1/ratecenter/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getRateCenterByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getRateCenterByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (areaCodeInfo !== undefined) {
            queryParameters['AreaCodeInfo'] = areaCodeInfo;
        }

        if (level !== undefined) {
            queryParameters['level'] = level;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: RateCenterResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum TimeZoneServiceApiApiKeys {
}

export class TimeZoneServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: TimeZoneServiceApiApiKeys, value: string) {
        this.authentications[TimeZoneServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Timezone Batch by Address
     * Identifies and retrieves the local time of any location in the world for a given address and time. The input and retrieved time format is in milliseconds. 
     * @param body 
     */
    public getBatchTimezoneByAddress (body?: TimezoneAddressRequest) : Promise<{ response: http.IncomingMessage; body: TimezoneResponse;  }> {
        const localVarPath = this.basePath + '/timezone/v1/timezone/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TimezoneResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Timezone Batch by Location
     * Identifies and retrieves the local time of any location in the world for a given latitude, longitude and time. The input and retrieved time format is in milliseconds. 
     * @param body 
     */
    public getBatchTimezoneByLocation (body?: TimezoneLocationRequest) : Promise<{ response: http.IncomingMessage; body: TimezoneLocationResponse;  }> {
        const localVarPath = this.basePath + '/timezone/v1/timezone/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TimezoneLocationResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Timezone By Address.
     * Identifies and retrieves the local time of any location in the world for a given address and time. The input and retrieved time format is in milliseconds.
     * @param timestamp Timestamp in miliseconds.
     * @param address The address to be searched.
     * @param matchMode Match modes determine the leniency used to make a match between the input address and the reference data.
     * @param country Country ISO code.
     */
    public getTimezoneByAddress (timestamp: string, address: string, matchMode?: string, country?: string) : Promise<{ response: http.IncomingMessage; body: Timezone;  }> {
        const localVarPath = this.basePath + '/timezone/v1/timezone/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'timestamp' is not null or undefined
        if (timestamp === null || timestamp === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter timestamp was null or undefined when calling getTimezoneByAddress."}]}})
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getTimezoneByAddress."}]}})
        }

        if (timestamp !== undefined) {
            queryParameters['timestamp'] = timestamp;
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (matchMode !== undefined) {
            queryParameters['matchMode'] = matchMode;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Timezone;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Timezone By Location.
     * Identifies and retrieves the local time of any location in the world for a given latitude, longitude and time. The input and retrieved time format is in milliseconds.
     * @param timestamp Timestamp in miliseconds.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     */
    public getTimezoneByLocation (timestamp: string, longitude: string, latitude: string) : Promise<{ response: http.IncomingMessage; body: TimezoneLocation;  }> {
        const localVarPath = this.basePath + '/timezone/v1/timezone/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'timestamp' is not null or undefined
        if (timestamp === null || timestamp === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter timestamp was null or undefined when calling getTimezoneByLocation."}]}})
        }

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getTimezoneByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getTimezoneByLocation."}]}})
        }

        if (timestamp !== undefined) {
            queryParameters['timestamp'] = timestamp;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TimezoneLocation;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum TypeaheadServiceApiApiKeys {
}

export class TypeaheadServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: TypeaheadServiceApiApiKeys, value: string) {
        this.authentications[TypeaheadServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Typeahead Search
     * Performs search to retrieve list of places by input text and location vicinity.
     * @param searchText The input to be searched.
     * @param latitude Latitude of the location. Either the latitude or the longitude must be provided.
     * @param longitude Longitude of the location. Either the latitude or the longitude must be provided.
     * @param searchRadius Radius range within which search is performed.
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters.
     * @param maxCandidates Maximum number of addresses that can be retrieved.
     * @param country Country ISO code. We need to make sure that either Lat/Lng or Country is provided to API
     * @param matchOnAddressNumber Option so that we force api to match on address number
     * @param autoDetectLocation Option to allow API to detect origin of API request automatically
     * @param ipAddress 
     * @param areaName1 State province of the input to be searched
     * @param areaName3 City of the input to be searched
     * @param postCode Postal Code of the input to be searched
     * @param returnAdminAreasOnly if value set &#39;Y&#39; then it will only do a matching on postcode or areaName1, areaName2, areaName3 and areaName4 fields in the data
     * @param includeRangesDetails if value set &#39;Y&#39; then display all unit info of ranges, if value set &#39;N&#39; then don&#39;t show ranges
     * @param searchType Preference to control search type of interactive requests.
     * @param searchOnAddressNumber if value set &#39;Y&#39; then display searchOnAddressNumber
     */
    public search (searchText: string, latitude?: string, longitude?: string, searchRadius?: string, searchRadiusUnit?: string, maxCandidates?: string, country?: string, matchOnAddressNumber?: string, autoDetectLocation?: string, ipAddress?: string, areaName1?: string, areaName3?: string, postCode?: string, returnAdminAreasOnly?: string, includeRangesDetails?: string, searchType?: string, searchOnAddressNumber?: string) : Promise<{ response: http.IncomingMessage; body: GeosearchLocations;  }> {
        const localVarPath = this.basePath + '/typeahead/v1/locations';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'searchText' is not null or undefined
        if (searchText === null || searchText === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter searchText was null or undefined when calling search."}]}})
        }

        if (searchText !== undefined) {
            queryParameters['searchText'] = searchText;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (searchRadius !== undefined) {
            queryParameters['searchRadius'] = searchRadius;
        }

        if (searchRadiusUnit !== undefined) {
            queryParameters['searchRadiusUnit'] = searchRadiusUnit;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (matchOnAddressNumber !== undefined) {
            queryParameters['matchOnAddressNumber'] = matchOnAddressNumber;
        }

        if (autoDetectLocation !== undefined) {
            queryParameters['autoDetectLocation'] = autoDetectLocation;
        }

        if (ipAddress !== undefined) {
            queryParameters['ipAddress'] = ipAddress;
        }

        if (areaName1 !== undefined) {
            queryParameters['areaName1'] = areaName1;
        }

        if (areaName3 !== undefined) {
            queryParameters['areaName3'] = areaName3;
        }

        if (postCode !== undefined) {
            queryParameters['postCode'] = postCode;
        }

        if (returnAdminAreasOnly !== undefined) {
            queryParameters['returnAdminAreasOnly'] = returnAdminAreasOnly;
        }

        if (includeRangesDetails !== undefined) {
            queryParameters['includeRangesDetails'] = includeRangesDetails;
        }

        if (searchType !== undefined) {
            queryParameters['searchType'] = searchType;
        }

        if (searchOnAddressNumber !== undefined) {
            queryParameters['searchOnAddressNumber'] = searchOnAddressNumber;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeosearchLocations;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum ZonesServiceApiApiKeys {
}

export class ZonesServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ZonesServiceApiApiKeys, value: string) {
        this.authentications[ZonesServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Gets Basic Boundary by Address
     * Gets Basic Boundary by Address
     * @param address Address around which Basic Boundary is requested
     * @param distance This is width of the buffer (in a complete circular buffer, it would be radius of the buffer). This has to be a positive number.
     * @param country Three digit ISO country code
     * @param distanceUnit Longitude around which Basic Boundary is requested
     * @param resolution This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4.
     * @param responseSrs The spatial reference system to express the response in. By default, it would be epsg:4326
     */
    public getBasicBoundaryByAddress (address: string, distance: string, country?: string, distanceUnit?: string, resolution?: string, responseSrs?: string) : Promise<{ response: http.IncomingMessage; body: BasicBoundaryAddress;  }> {
        const localVarPath = this.basePath + '/zones/v1/basicboundary/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getBasicBoundaryByAddress."}]}})
        }

        // verify required parameter 'distance' is not null or undefined
        if (distance === null || distance === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter distance was null or undefined when calling getBasicBoundaryByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (distance !== undefined) {
            queryParameters['distance'] = distance;
        }

        if (distanceUnit !== undefined) {
            queryParameters['distanceUnit'] = distanceUnit;
        }

        if (resolution !== undefined) {
            queryParameters['resolution'] = resolution;
        }

        if (responseSrs !== undefined) {
            queryParameters['responseSrs'] = responseSrs;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: BasicBoundaryAddress;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets Basic Boundary by Location
     * Gets Basic Boundary by Location
     * @param latitude Latitude around which Basic Boundary is requested
     * @param longitude Longitude around which Basic Boundary is requested
     * @param distance This is width of the buffer (in a complete circular buffer, it would be radius of the buffer). This has to be a positive number.
     * @param distanceUnit Longitude around which Basic Boundary is requested
     * @param resolution This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4.
     * @param responseSrs The spatial reference system to express the response in. By default, it would be epsg:4326
     * @param srsName The spatial reference system for input. By default, it would be epsg:4326
     */
    public getBasicBoundaryByLocation (latitude: string, longitude: string, distance: string, distanceUnit?: string, resolution?: string, responseSrs?: string, srsName?: string) : Promise<{ response: http.IncomingMessage; body: BasicBoundary;  }> {
        const localVarPath = this.basePath + '/zones/v1/basicboundary/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getBasicBoundaryByLocation."}]}})
        }

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getBasicBoundaryByLocation."}]}})
        }

        // verify required parameter 'distance' is not null or undefined
        if (distance === null || distance === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter distance was null or undefined when calling getBasicBoundaryByLocation."}]}})
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (distance !== undefined) {
            queryParameters['distance'] = distance;
        }

        if (distanceUnit !== undefined) {
            queryParameters['distanceUnit'] = distanceUnit;
        }

        if (resolution !== undefined) {
            queryParameters['resolution'] = resolution;
        }

        if (responseSrs !== undefined) {
            queryParameters['responseSrs'] = responseSrs;
        }

        if (srsName !== undefined) {
            queryParameters['srsName'] = srsName;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: BasicBoundary;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Point of Interests Boundary by Address
     * Gets Point of Interests Boundary by Address
     * @param address Address around which POI Boundary is requested
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes.
     * @param sicCode Specify starting digits or full sic code to filter the response
     * @param naicsCode Will accept naicsCode to filter POIs in results. Max 10 allowed.
     */
    public getPOIBoundaryByAddress (address: string, categoryCode?: string, sicCode?: string, naicsCode?: string) : Promise<{ response: http.IncomingMessage; body: PoiBoundary;  }> {
        const localVarPath = this.basePath + '/zones/v1/poiboundary/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getPOIBoundaryByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (categoryCode !== undefined) {
            queryParameters['categoryCode'] = categoryCode;
        }

        if (sicCode !== undefined) {
            queryParameters['sicCode'] = sicCode;
        }

        if (naicsCode !== undefined) {
            queryParameters['naicsCode'] = naicsCode;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PoiBoundary;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Batch method for getting Point of Interests Boundary by Address
     * Batch method for getting Point of Interests Boundary by Address
     * @param body 
     */
    public getPOIBoundaryByAddressBatch (body?: POIBoundaryAddressRequest) : Promise<{ response: http.IncomingMessage; body: POIBoundaryResponse;  }> {
        const localVarPath = this.basePath + '/zones/v1/poiboundary/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: POIBoundaryResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Point of Interests Boundary by Location
     * Get Point of Interests Boundary by Location
     * @param latitude Latitude around which POI Boundary is requested
     * @param longitude Longitude around which POI Boundary is requested
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes
     * @param sicCode Specify starting digits or full sic code to filter the response
     * @param naicsCode Will accept naicsCode to filter POIs in results. Max 10 allowed.
     */
    public getPOIBoundaryByLocation (latitude: string, longitude: string, categoryCode?: string, sicCode?: string, naicsCode?: string) : Promise<{ response: http.IncomingMessage; body: PoiBoundary;  }> {
        const localVarPath = this.basePath + '/zones/v1/poiboundary/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getPOIBoundaryByLocation."}]}})
        }

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getPOIBoundaryByLocation."}]}})
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (categoryCode !== undefined) {
            queryParameters['categoryCode'] = categoryCode;
        }

        if (sicCode !== undefined) {
            queryParameters['sicCode'] = sicCode;
        }

        if (naicsCode !== undefined) {
            queryParameters['naicsCode'] = naicsCode;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PoiBoundary;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Batch method for getting Point of Interests Boundary by Location
     * Batch method for getting Point of Interests Boundary by Location
     * @param body 
     */
    public getPOIBoundaryByLocationBatch (body?: POIBoundaryLocationRequest) : Promise<{ response: http.IncomingMessage; body: POIBoundaryResponse;  }> {
        const localVarPath = this.basePath + '/zones/v1/poiboundary/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: POIBoundaryResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets travel Boundary by Distance
     * Returns the travel boundary based on travel distance.
     * @param costs Travel distance(s)
     * @param point Starting point from where the travel boundary is calculated. Point in &#39;Lat,Long,coordsys&#39; format
     * @param address Starting address from where the travel boundary is calculated.
     * @param costUnit Travel distance such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param db Mode of commute.
     * @param country Three digit ISO country code.
     * @param maxOffroadDistance Maximum distance to allow travel off the road network.
     * @param maxOffroadDistanceUnit MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param destinationSrs Desired coordinate system of the travel boundary.
     * @param majorRoads Whether to include all roads in the calculation or just major roads.
     * @param returnHoles Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired distance.
     * @param returnIslands Whether to return islands, which are small areas outside the main boundary that can be reached within the desired distance.
     * @param simplificationFactor Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex.
     * @param bandingStyle Style of banding to be used in the result.
     * @param historicTrafficTimeBucket Whether routing calculation uses the historic traffic speeds.
     * @param defaultAmbientSpeed The speed to travel when going off a network road to find the travel boundary (for all road types).
     * @param ambientSpeedUnit The unit of measure to use to calculate the ambient speed.
     */
    public getTravelBoundaryByDistance (costs: string, point?: string, address?: string, costUnit?: string, db?: string, country?: string, maxOffroadDistance?: string, maxOffroadDistanceUnit?: string, destinationSrs?: string, majorRoads?: string, returnHoles?: string, returnIslands?: string, simplificationFactor?: string, bandingStyle?: string, historicTrafficTimeBucket?: string, defaultAmbientSpeed?: string, ambientSpeedUnit?: string) : Promise<{ response: http.IncomingMessage; body: TravelBoundaries;  }> {
        const localVarPath = this.basePath + '/zones/v1/travelboundary/bydistance';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'costs' is not null or undefined
        if (costs === null || costs === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter costs was null or undefined when calling getTravelBoundaryByDistance."}]}})
        }

        if (point !== undefined) {
            queryParameters['point'] = point;
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (costs !== undefined) {
            queryParameters['costs'] = costs;
        }

        if (costUnit !== undefined) {
            queryParameters['costUnit'] = costUnit;
        }

        if (db !== undefined) {
            queryParameters['db'] = db;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (maxOffroadDistance !== undefined) {
            queryParameters['maxOffroadDistance'] = maxOffroadDistance;
        }

        if (maxOffroadDistanceUnit !== undefined) {
            queryParameters['maxOffroadDistanceUnit'] = maxOffroadDistanceUnit;
        }

        if (destinationSrs !== undefined) {
            queryParameters['destinationSrs'] = destinationSrs;
        }

        if (majorRoads !== undefined) {
            queryParameters['majorRoads'] = majorRoads;
        }

        if (returnHoles !== undefined) {
            queryParameters['returnHoles'] = returnHoles;
        }

        if (returnIslands !== undefined) {
            queryParameters['returnIslands'] = returnIslands;
        }

        if (simplificationFactor !== undefined) {
            queryParameters['simplificationFactor'] = simplificationFactor;
        }

        if (bandingStyle !== undefined) {
            queryParameters['bandingStyle'] = bandingStyle;
        }

        if (historicTrafficTimeBucket !== undefined) {
            queryParameters['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
        }

        if (defaultAmbientSpeed !== undefined) {
            queryParameters['defaultAmbientSpeed'] = defaultAmbientSpeed;
        }

        if (ambientSpeedUnit !== undefined) {
            queryParameters['ambientSpeedUnit'] = ambientSpeedUnit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TravelBoundaries;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets travel Boundary by Time
     * Travel boundary based on travel time.
     * @param costs Travel time used to calculate the travel boundary.
     * @param point Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format
     * @param address Starting address from where the travel boundary is calculated.
     * @param costUnit Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
     * @param db Mode of commute.
     * @param country 3 character ISO code or country name.
     * @param maxOffroadDistance Maximum distance to allow travel off the road network.
     * @param maxOffroadDistanceUnit MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param destinationSrs Desired coordinate system of the travel boundary.
     * @param majorRoads Whether to include all roads in the calculation or just major roads.
     * @param returnHoles Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time.
     * @param returnIslands Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time.
     * @param simplificationFactor Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex.
     * @param bandingStyle Style of banding to be used in the result.
     * @param historicTrafficTimeBucket Whether routing calculation uses the historic traffic speeds.
     * @param defaultAmbientSpeed The speed to travel when going off a network road to find the travel boundary (for all road types).
     * @param ambientSpeedUnit The unit of measure to use to calculate the ambient speed.
     */
    public getTravelBoundaryByTime (costs: string, point?: string, address?: string, costUnit?: string, db?: string, country?: string, maxOffroadDistance?: string, maxOffroadDistanceUnit?: string, destinationSrs?: string, majorRoads?: string, returnHoles?: string, returnIslands?: string, simplificationFactor?: string, bandingStyle?: string, historicTrafficTimeBucket?: string, defaultAmbientSpeed?: string, ambientSpeedUnit?: string) : Promise<{ response: http.IncomingMessage; body: TravelBoundaries;  }> {
        const localVarPath = this.basePath + '/zones/v1/travelboundary/bytime';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'costs' is not null or undefined
        if (costs === null || costs === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter costs was null or undefined when calling getTravelBoundaryByTime."}]}})
        }

        if (point !== undefined) {
            queryParameters['point'] = point;
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (costs !== undefined) {
            queryParameters['costs'] = costs;
        }

        if (costUnit !== undefined) {
            queryParameters['costUnit'] = costUnit;
        }

        if (db !== undefined) {
            queryParameters['db'] = db;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (maxOffroadDistance !== undefined) {
            queryParameters['maxOffroadDistance'] = maxOffroadDistance;
        }

        if (maxOffroadDistanceUnit !== undefined) {
            queryParameters['maxOffroadDistanceUnit'] = maxOffroadDistanceUnit;
        }

        if (destinationSrs !== undefined) {
            queryParameters['destinationSrs'] = destinationSrs;
        }

        if (majorRoads !== undefined) {
            queryParameters['majorRoads'] = majorRoads;
        }

        if (returnHoles !== undefined) {
            queryParameters['returnHoles'] = returnHoles;
        }

        if (returnIslands !== undefined) {
            queryParameters['returnIslands'] = returnIslands;
        }

        if (simplificationFactor !== undefined) {
            queryParameters['simplificationFactor'] = simplificationFactor;
        }

        if (bandingStyle !== undefined) {
            queryParameters['bandingStyle'] = bandingStyle;
        }

        if (historicTrafficTimeBucket !== undefined) {
            queryParameters['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
        }

        if (defaultAmbientSpeed !== undefined) {
            queryParameters['defaultAmbientSpeed'] = defaultAmbientSpeed;
        }

        if (ambientSpeedUnit !== undefined) {
            queryParameters['ambientSpeedUnit'] = ambientSpeedUnit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TravelBoundaries;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum _911PSAPServiceApiApiKeys {
}

export class _911PSAPServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: _911PSAPServiceApiApiKeys, value: string) {
        this.authentications[_911PSAPServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * AHJ &amp; PSAP By Address.
     * Accepts addresses as input and Returns contact details for Authorities Having Jurisdiction (AHJ) on-behalf-of local Public Safety Answering Points (PSAP). Geo911 accepts an address and returns PSAP contact data plus contact data for an AHJ to communicate directly with a PSAP. Details include agency name, phone number, city name, coverage, contact person&#39;s details, site details and mailing addresses for EMS, Fire, and Police PSAP contacts.
     * @param address The address to be searched.
     */
    public getAHJPlusPSAPByAddress (address: string) : Promise<{ response: http.IncomingMessage; body: AHJPlusPSAPResponse;  }> {
        const localVarPath = this.basePath + '/911/v1/ahj-psap/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getAHJPlusPSAPByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: AHJPlusPSAPResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * AHJ &amp; PSAP By Location
     * Accepts latitude &amp; longitude as input and Returns contact details for Authorities Having Jurisdiction (AHJ) on-behalf-of local Public Safety Answering Points (PSAP). Geo911 accepts a location coordinate and returns PSAP contact data plus contact data for an AHJ to communicate directly with a PSAP. Details include agency name, phone number, city name, coverage, contact person&#39;s details, site details and mailing addresses for EMS, Fire, and Police PSAP contacts.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     */
    public getAHJPlusPSAPByLocation (longitude: string, latitude: string) : Promise<{ response: http.IncomingMessage; body: AHJPlusPSAPResponse;  }> {
        const localVarPath = this.basePath + '/911/v1/ahj-psap/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getAHJPlusPSAPByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getAHJPlusPSAPByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: AHJPlusPSAPResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * PSAP By Address.
     * Accepts addresses as input and returns contact details for local Public Safety Answering Points (PSAP). Geo911 accepts an address as input and returns the relevant PSAP address and contact details including agency name, phone number, county name, coverage, contact person&#39;s details, site details and mailing address.
     * @param address The address to be searched.
     */
    public getPSAPByAddress (address: string) : Promise<{ response: http.IncomingMessage; body: PSAPResponse;  }> {
        const localVarPath = this.basePath + '/911/v1/psap/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getPSAPByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PSAPResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * PSAP By Location.
     * Accepts latitude &amp; longitude as input and Returns contact details for local Public Safety Answering Points (PSAP). Geo911 accepts a location coordinate and returns the relevant PSAP address and contact details including dispatch name, phone number, county name, coverage, contact person&#39;s details, site details and mailing address.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     */
    public getPSAPByLocation (longitude: string, latitude: string) : Promise<{ response: http.IncomingMessage; body: PSAPResponse;  }> {
        const localVarPath = this.basePath + '/911/v1/psap/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getPSAPByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getPSAPByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PSAPResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
