/* tslint:disable */
/* eslint-disable */
/**
 * Precisely APIs
 * Enhance & enrich your data, applications, business processes, and workflows with rich location, information, and identify APIs.
 *
 * The version of the OpenAPI document: 17.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration, oAuthCredInfo} from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AHJ
 */
export interface AHJ {
    /**
     * 
     * @type {string}
     * @memberof AHJ
     */
    'ahjType'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJ
     */
    'ahjId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJ
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJ
     */
    'fccId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJ
     */
    'agency'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJ
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJ
     */
    'comments'?: string;
    /**
     * 
     * @type {Coverage}
     * @memberof AHJ
     */
    'coverage'?: Coverage;
    /**
     * 
     * @type {ContactPerson}
     * @memberof AHJ
     */
    'contactPerson'?: ContactPerson;
    /**
     * 
     * @type {AHJmailingAddress}
     * @memberof AHJ
     */
    'mailingAddress'?: AHJmailingAddress;
}
/**
 * 
 * @export
 * @interface AHJList
 */
export interface AHJList {
    /**
     * 
     * @type {Array<AHJ>}
     * @memberof AHJList
     */
    'ahjs'?: Array<AHJ>;
}
/**
 * 
 * @export
 * @interface AHJPlusPSAPResponse
 */
export interface AHJPlusPSAPResponse {
    /**
     * 
     * @type {AHJList}
     * @memberof AHJPlusPSAPResponse
     */
    'ahjs'?: AHJList;
    /**
     * 
     * @type {PSAPResponse}
     * @memberof AHJPlusPSAPResponse
     */
    'psap'?: PSAPResponse;
    /**
     * 
     * @type {number}
     * @memberof AHJPlusPSAPResponse
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface AHJmailingAddress
 */
export interface AHJmailingAddress {
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'streetSide'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'businessName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'addressLine1'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'addressLine2'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'addressLine3'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'stateProvince'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'county'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'latitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'longitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'urbanizationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'formattedAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'mainAddressLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'addressLastLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'placeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'areaName1'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'areaName2'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'areaName3'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'areaName4'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'postCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'postCodeExt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'addressNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'streetName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'unitType'?: string;
    /**
     * 
     * @type {string}
     * @memberof AHJmailingAddress
     */
    'unitValue'?: string;
}
/**
 * 
 * @export
 * @interface AbsenteeOwner
 */
export interface AbsenteeOwner {
    /**
     * 
     * @type {string}
     * @memberof AbsenteeOwner
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof AbsenteeOwner
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface Accuracy
 */
export interface Accuracy {
    /**
     * 
     * @type {string}
     * @memberof Accuracy
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof Accuracy
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'streetSide'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'businessName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'addressLine1'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'addressLine2'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'addressLine3'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'stateProvince'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'county'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'latitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'longitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'urbanizationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'formattedAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'mainAddressLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'addressLastLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'placeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'areaName1'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'areaName2'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'areaName3'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'areaName4'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'postCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'postCodeExt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'addressNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'streetName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'unitType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'unitValue'?: string;
}
/**
 * 
 * @export
 * @interface Address1
 */
export interface Address1 {
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'streetSide'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'businessName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'addressLine1'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'addressLine2'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'addressLine3'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'stateProvince'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'county'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'latitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'longitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'urbanizationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'formattedAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'mainAddressLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'addressLastLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'placeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'areaName1'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'areaName2'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'areaName3'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'areaName4'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'postCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'postCodeExt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'addressNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'streetName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'unitType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'unitValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address1
     */
    'postalVerified'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof Address1
     */
    'customFields'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface AddressTime
 */
export interface AddressTime {
    /**
     * 
     * @type {string}
     * @memberof AddressTime
     */
    'timestamp'?: string;
    /**
     * 
     * @type {Address}
     * @memberof AddressTime
     */
    'address'?: Address;
}
/**
 * 
 * @export
 * @interface AddressType
 */
export interface AddressType {
    /**
     * 
     * @type {string}
     * @memberof AddressType
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressType
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface AddressesByBoundaryRequest
 */
export interface AddressesByBoundaryRequest {
    /**
     * 
     * @type {AddressesPreferences}
     * @memberof AddressesByBoundaryRequest
     */
    'preferences'?: AddressesPreferences;
    /**
     * 
     * @type {Geometry}
     * @memberof AddressesByBoundaryRequest
     */
    'geometry'?: Geometry;
    /**
     * 
     * @type {string}
     * @memberof AddressesByBoundaryRequest
     */
    'geometryAsText'?: string;
    /**
     * 
     * @type {number}
     * @memberof AddressesByBoundaryRequest
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof AddressesByBoundaryRequest
     */
    'longitude'?: number;
    /**
     * 
     * @type {string}
     * @memberof AddressesByBoundaryRequest
     */
    'travelTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesByBoundaryRequest
     */
    'travelTimeUnit'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesByBoundaryRequest
     */
    'travelDistance'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesByBoundaryRequest
     */
    'travelDistanceUnit'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesByBoundaryRequest
     */
    'travelMode'?: string;
}
/**
 * 
 * @export
 * @interface AddressesCount
 */
export interface AddressesCount {
    /**
     * 
     * @type {number}
     * @memberof AddressesCount
     */
    'totalAddressesFound'?: number;
}
/**
 * 
 * @export
 * @interface AddressesDTO
 */
export interface AddressesDTO {
    /**
     * 
     * @type {string}
     * @memberof AddressesDTO
     */
    'pbKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesDTO
     */
    'addressNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesDTO
     */
    'streetName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesDTO
     */
    'unitType'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesDTO
     */
    'unitValue'?: string;
    /**
     * 
     * @type {AddressType}
     * @memberof AddressesDTO
     */
    'type'?: AddressType;
    /**
     * 
     * @type {string}
     * @memberof AddressesDTO
     */
    'areaName1'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesDTO
     */
    'areaName2'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesDTO
     */
    'areaName3'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesDTO
     */
    'areaName4'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesDTO
     */
    'postCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesDTO
     */
    'postCodeExt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesDTO
     */
    'country'?: string;
    /**
     * 
     * @type {Geometry}
     * @memberof AddressesDTO
     */
    'geometry'?: Geometry;
    /**
     * 
     * @type {string}
     * @memberof AddressesDTO
     */
    'propertyType'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesDTO
     */
    'propertyTypeDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesDTO
     */
    'parentPbKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesDTO
     */
    'geoId'?: string;
}
/**
 * 
 * @export
 * @interface AddressesPreferences
 */
export interface AddressesPreferences {
    /**
     * 
     * @type {string}
     * @memberof AddressesPreferences
     */
    'maxCandidates'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesPreferences
     */
    'page'?: string;
}
/**
 * 
 * @export
 * @interface AddressesResponse
 */
export interface AddressesResponse {
    /**
     * 
     * @type {string}
     * @memberof AddressesResponse
     */
    'page'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressesResponse
     */
    'candidates'?: string;
    /**
     * 
     * @type {Array<AddressesDTO>}
     * @memberof AddressesResponse
     */
    'addressList'?: Array<AddressesDTO>;
}
/**
 * 
 * @export
 * @interface Amenities
 */
export interface Amenities {
    /**
     * 
     * @type {string}
     * @memberof Amenities
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Amenities
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface Area
 */
export interface Area {
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface AreaCodeInfo
 */
export interface AreaCodeInfo {
    /**
     * 
     * @type {string}
     * @memberof AreaCodeInfo
     */
    'companyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AreaCodeInfo
     */
    'ocn'?: string;
    /**
     * 
     * @type {string}
     * @memberof AreaCodeInfo
     */
    'ocnCategory'?: string;
    /**
     * 
     * @type {string}
     * @memberof AreaCodeInfo
     */
    'npa'?: string;
    /**
     * 
     * @type {string}
     * @memberof AreaCodeInfo
     */
    'nxx'?: string;
    /**
     * 
     * @type {string}
     * @memberof AreaCodeInfo
     */
    'startRange'?: string;
    /**
     * 
     * @type {string}
     * @memberof AreaCodeInfo
     */
    'endRange'?: string;
    /**
     * 
     * @type {string}
     * @memberof AreaCodeInfo
     */
    'lata'?: string;
    /**
     * 
     * @type {string}
     * @memberof AreaCodeInfo
     */
    'areaName4'?: string;
}
/**
 * 
 * @export
 * @interface AssetsAndWealthTheme
 */
export interface AssetsAndWealthTheme {
    /**
     * 
     * @type {string}
     * @memberof AssetsAndWealthTheme
     */
    'boundaryRef'?: string;
    /**
     * 
     * @type {Array<IndividualValueVariable>}
     * @memberof AssetsAndWealthTheme
     */
    'individualValueVariable'?: Array<IndividualValueVariable>;
    /**
     * 
     * @type {Array<RangeVariable>}
     * @memberof AssetsAndWealthTheme
     */
    'rangeVariable'?: Array<RangeVariable>;
}
/**
 * 
 * @export
 * @interface BaseFloodElevation
 */
export interface BaseFloodElevation {
    /**
     * 
     * @type {string}
     * @memberof BaseFloodElevation
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseFloodElevation
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BasementType
 */
export interface BasementType {
    /**
     * 
     * @type {string}
     * @memberof BasementType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BasementType
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BasicBoundary
 */
export interface BasicBoundary {
    /**
     * 
     * @type {BoundaryPoint}
     * @memberof BasicBoundary
     */
    'center'?: BoundaryPoint;
    /**
     * 
     * @type {Distance}
     * @memberof BasicBoundary
     */
    'distance'?: Distance;
    /**
     * 
     * @type {ZonesBoundaryGeometry}
     * @memberof BasicBoundary
     */
    'geometry'?: ZonesBoundaryGeometry;
    /**
     * 
     * @type {ZonesAddress}
     * @memberof BasicBoundary
     */
    'matchedAddress'?: ZonesAddress;
}
/**
 * 
 * @export
 * @interface Boundaries
 */
export interface Boundaries {
    /**
     * 
     * @type {string}
     * @memberof Boundaries
     */
    'boundaryType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Boundaries
     */
    'boundaryRef'?: string;
    /**
     * 
     * @type {Array<Boundary>}
     * @memberof Boundaries
     */
    'boundary': Array<Boundary>;
}
/**
 * 
 * @export
 * @interface Boundary
 */
export interface Boundary {
    /**
     * 
     * @type {string}
     * @memberof Boundary
     */
    'boundaryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Boundary
     */
    'boundaryType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Boundary
     */
    'boundaryRef'?: string;
    /**
     * 
     * @type {DemographicsGeometry}
     * @memberof Boundary
     */
    'geometry'?: DemographicsGeometry;
    /**
     * 
     * @type {string}
     * @memberof Boundary
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface BoundaryBuffer
 */
export interface BoundaryBuffer {
    /**
     * 
     * @type {BufferRelation}
     * @memberof BoundaryBuffer
     */
    'bufferRelation'?: BufferRelation;
    /**
     * 
     * @type {DistanceToBorder}
     * @memberof BoundaryBuffer
     */
    'distanceToBorder'?: DistanceToBorder;
}
/**
 * 
 * @export
 * @interface BoundaryPoint
 */
export interface BoundaryPoint {
    /**
     * 
     * @type {string}
     * @memberof BoundaryPoint
     */
    'type'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof BoundaryPoint
     */
    'coordinates'?: Array<number>;
}
/**
 * 
 * @export
 * @interface BufferRelation
 */
export interface BufferRelation {
    /**
     * 
     * @type {string}
     * @memberof BufferRelation
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof BufferRelation
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BuildgClass
 */
export interface BuildgClass {
    /**
     * 
     * @type {string}
     * @memberof BuildgClass
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildgClass
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BuildgCondition
 */
export interface BuildgCondition {
    /**
     * 
     * @type {string}
     * @memberof BuildgCondition
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildgCondition
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BuildgFeaturesSqft
 */
export interface BuildgFeaturesSqft {
    /**
     * 
     * @type {string}
     * @memberof BuildgFeaturesSqft
     */
    'featureAreaSqFt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildgFeaturesSqft
     */
    'areaIndicator'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildgFeaturesSqft
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface BuildgImproveArea
 */
export interface BuildgImproveArea {
    /**
     * 
     * @type {string}
     * @memberof BuildgImproveArea
     */
    'improveArea'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildgImproveArea
     */
    'areaIndicator'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildgImproveArea
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface BuildgImproveType
 */
export interface BuildgImproveType {
    /**
     * 
     * @type {string}
     * @memberof BuildgImproveType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildgImproveType
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BuildgQuality
 */
export interface BuildgQuality {
    /**
     * 
     * @type {string}
     * @memberof BuildgQuality
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildgQuality
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BuildgStyle
 */
export interface BuildgStyle {
    /**
     * 
     * @type {string}
     * @memberof BuildgStyle
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildgStyle
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BuildgType
 */
export interface BuildgType {
    /**
     * 
     * @type {string}
     * @memberof BuildgType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildgType
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BuildgView
 */
export interface BuildgView {
    /**
     * 
     * @type {string}
     * @memberof BuildgView
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildgView
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BuildingSqftSource
 */
export interface BuildingSqftSource {
    /**
     * 
     * @type {string}
     * @memberof BuildingSqftSource
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildingSqftSource
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BusinessId
 */
export interface BusinessId {
    /**
     * 
     * @type {string}
     * @memberof BusinessId
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessId
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface CaExemptions
 */
export interface CaExemptions {
    /**
     * 
     * @type {string}
     * @memberof CaExemptions
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaExemptions
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface Candidate
 */
export interface Candidate {
    /**
     * 
     * @type {number}
     * @memberof Candidate
     */
    'precisionLevel'?: number;
    /**
     * 
     * @type {string}
     * @memberof Candidate
     */
    'formattedStreetAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof Candidate
     */
    'formattedLocationAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof Candidate
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof Candidate
     */
    'precisionCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Candidate
     */
    'sourceDictionary'?: string;
    /**
     * 
     * @type {FieldsMatching}
     * @memberof Candidate
     */
    'matching'?: FieldsMatching;
    /**
     * 
     * @type {GeoPos}
     * @memberof Candidate
     */
    'geometry'?: GeoPos;
    /**
     * 
     * @type {GeocodeAddress}
     * @memberof Candidate
     */
    'address'?: GeocodeAddress;
    /**
     * 
     * @type {Array<CandidateRange>}
     * @memberof Candidate
     */
    'ranges'?: Array<CandidateRange>;
}
/**
 * 
 * @export
 * @interface CandidateRange
 */
export interface CandidateRange {
    /**
     * 
     * @type {string}
     * @memberof CandidateRange
     */
    'placeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CandidateRange
     */
    'lowHouse'?: string;
    /**
     * 
     * @type {string}
     * @memberof CandidateRange
     */
    'highHouse'?: string;
    /**
     * 
     * @type {string}
     * @memberof CandidateRange
     */
    'side'?: CandidateRangeSideEnum;
    /**
     * 
     * @type {string}
     * @memberof CandidateRange
     */
    'oddEvenIndicator'?: CandidateRangeOddEvenIndicatorEnum;
    /**
     * 
     * @type {Array<CandidateRangeUnit>}
     * @memberof CandidateRange
     */
    'units'?: Array<CandidateRangeUnit>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof CandidateRange
     */
    'customValues'?: { [key: string]: object; };
}

/**
    * @export
    * @enum {string}
    */
export enum CandidateRangeSideEnum {
    Unknown = 'UNKNOWN',
    Left = 'LEFT',
    Right = 'RIGHT',
    Both = 'BOTH'
}
/**
    * @export
    * @enum {string}
    */
export enum CandidateRangeOddEvenIndicatorEnum {
    Unknown = 'UNKNOWN',
    Both = 'BOTH',
    Odd = 'ODD',
    Even = 'EVEN',
    Irregular = 'IRREGULAR'
}

/**
 * 
 * @export
 * @interface CandidateRangeUnit
 */
export interface CandidateRangeUnit {
    /**
     * 
     * @type {string}
     * @memberof CandidateRangeUnit
     */
    'placeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CandidateRangeUnit
     */
    'unitType'?: string;
    /**
     * 
     * @type {string}
     * @memberof CandidateRangeUnit
     */
    'highUnitValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof CandidateRangeUnit
     */
    'lowUnitValue'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof CandidateRangeUnit
     */
    'customValues'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface Carrier
 */
export interface Carrier {
    /**
     * 
     * @type {string}
     * @memberof Carrier
     */
    'asn'?: string;
    /**
     * 
     * @type {string}
     * @memberof Carrier
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'categoryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'tradeDivision'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'tradeGroup'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'subClass'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'class'?: string;
}
/**
 * 
 * @export
 * @interface CategoryMetadata
 */
export interface CategoryMetadata {
    /**
     * 
     * @type {string}
     * @memberof CategoryMetadata
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryMetadata
     */
    'sic'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryMetadata
     */
    'tradeDivision'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryMetadata
     */
    'tradeGroup'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryMetadata
     */
    'class'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryMetadata
     */
    'subClass'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryMetadata
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface Cbsa
 */
export interface Cbsa {
    /**
     * 
     * @type {string}
     * @memberof Cbsa
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Cbsa
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface Census
 */
export interface Census {
    /**
     * 
     * @type {Cbsa}
     * @memberof Census
     */
    'cbsa'?: Cbsa;
    /**
     * 
     * @type {string}
     * @memberof Census
     */
    'matchLevel'?: string;
    /**
     * 
     * @type {string}
     * @memberof Census
     */
    'matchCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Census
     */
    'tract'?: string;
    /**
     * 
     * @type {Mcd}
     * @memberof Census
     */
    'mcd'?: Mcd;
}
/**
 * 
 * @export
 * @interface Center
 */
export interface Center {
    /**
     * 
     * @type {string}
     * @memberof Center
     */
    'type'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof Center
     */
    'coordinates'?: Array<number>;
}
/**
 * 
 * @export
 * @interface City
 */
export interface City {
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'confidence'?: string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface CommonGeometry
 */
export interface CommonGeometry {
    /**
     * 
     * @type {string}
     * @memberof CommonGeometry
     */
    'type'?: string;
    /**
     * 
     * @type {RisksGeometryCRC}
     * @memberof CommonGeometry
     */
    'crs'?: RisksGeometryCRC;
    /**
     * 
     * @type {object}
     * @memberof CommonGeometry
     */
    'coordinates'?: object;
}
/**
 * 
 * @export
 * @interface Community
 */
export interface Community {
    /**
     * 
     * @type {string}
     * @memberof Community
     */
    'number'?: string;
    /**
     * 
     * @type {Status}
     * @memberof Community
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface ConsistencyCode
 */
export interface ConsistencyCode {
    /**
     * 
     * @type {string}
     * @memberof ConsistencyCode
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsistencyCode
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface Construction
 */
export interface Construction {
    /**
     * 
     * @type {string}
     * @memberof Construction
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Construction
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface ContactDetails
 */
export interface ContactDetails {
    /**
     * 
     * @type {Address}
     * @memberof ContactDetails
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof ContactDetails
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactDetails
     */
    'fax'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactDetails
     */
    'countryAccessCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactDetails
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactDetails
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ContactPerson
 */
export interface ContactPerson {
    /**
     * 
     * @type {string}
     * @memberof ContactPerson
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPerson
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPerson
     */
    'prefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPerson
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPerson
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPerson
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPerson
     */
    'fax'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPerson
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPerson
     */
    'comments'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPerson
     */
    'additionalDetails'?: string;
}
/**
 * 
 * @export
 * @interface CoolingType
 */
export interface CoolingType {
    /**
     * 
     * @type {string}
     * @memberof CoolingType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoolingType
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface Cost
 */
export interface Cost {
    /**
     * 
     * @type {number}
     * @memberof Cost
     */
    'cost'?: number;
    /**
     * 
     * @type {string}
     * @memberof Cost
     */
    'costUnit'?: string;
    /**
     * 
     * @type {DirectionGeometry}
     * @memberof Cost
     */
    'geometry'?: DirectionGeometry;
}
/**
 * 
 * @export
 * @interface County
 */
export interface County {
    /**
     * 
     * @type {string}
     * @memberof County
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof County
     */
    'fips'?: string;
}
/**
 * 
 * @export
 * @interface Coverage
 */
export interface Coverage {
    /**
     * 
     * @type {string}
     * @memberof Coverage
     */
    'area'?: string;
    /**
     * 
     * @type {string}
     * @memberof Coverage
     */
    'comments'?: string;
    /**
     * 
     * @type {string}
     * @memberof Coverage
     */
    'exceptions'?: string;
}
/**
 * 
 * @export
 * @interface CrimeBoundary
 */
export interface CrimeBoundary {
    /**
     * 
     * @type {string}
     * @memberof CrimeBoundary
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CrimeBoundary
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CrimeBoundary
     */
    'ref'?: string;
    /**
     * 
     * @type {CommonGeometry}
     * @memberof CrimeBoundary
     */
    'geometry'?: CommonGeometry;
}
/**
 * 
 * @export
 * @interface CrimeIndexTheme
 */
export interface CrimeIndexTheme {
    /**
     * 
     * @type {string}
     * @memberof CrimeIndexTheme
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof CrimeIndexTheme
     */
    'boundaryRef'?: string;
    /**
     * 
     * @type {Array<IndexVariable>}
     * @memberof CrimeIndexTheme
     */
    'indexVariable'?: Array<IndexVariable>;
}
/**
 * 
 * @export
 * @interface CrimeRiskByAddressBatchRequest
 */
export interface CrimeRiskByAddressBatchRequest {
    /**
     * 
     * @type {Array<RiskAddress>}
     * @memberof CrimeRiskByAddressBatchRequest
     */
    'addresses': Array<RiskAddress>;
    /**
     * 
     * @type {CrimeRiskPreferences}
     * @memberof CrimeRiskByAddressBatchRequest
     */
    'preferences'?: CrimeRiskPreferences;
}
/**
 * 
 * @export
 * @interface CrimeRiskByLocationBatchRequest
 */
export interface CrimeRiskByLocationBatchRequest {
    /**
     * 
     * @type {Array<RiskLocations>}
     * @memberof CrimeRiskByLocationBatchRequest
     */
    'locations': Array<RiskLocations>;
    /**
     * 
     * @type {CrimeRiskPreferences}
     * @memberof CrimeRiskByLocationBatchRequest
     */
    'preferences'?: CrimeRiskPreferences;
}
/**
 * 
 * @export
 * @interface CrimeRiskPreferences
 */
export interface CrimeRiskPreferences {
    /**
     * 
     * @type {string}
     * @memberof CrimeRiskPreferences
     */
    'includeGeometry'?: string;
    /**
     * 
     * @type {string}
     * @memberof CrimeRiskPreferences
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface CrimeRiskResponse
 */
export interface CrimeRiskResponse {
    /**
     * 
     * @type {string}
     * @memberof CrimeRiskResponse
     */
    'objectId'?: string;
    /**
     * 
     * @type {Array<RisksCrimeTheme>}
     * @memberof CrimeRiskResponse
     */
    'themes'?: Array<RisksCrimeTheme>;
    /**
     * 
     * @type {RisksBoundaries}
     * @memberof CrimeRiskResponse
     */
    'boundaries'?: RisksBoundaries;
    /**
     * 
     * @type {RiskAddress}
     * @memberof CrimeRiskResponse
     */
    'matchedAddress'?: RiskAddress;
}
/**
 * 
 * @export
 * @interface CrimeRiskResponseList
 */
export interface CrimeRiskResponseList {
    /**
     * 
     * @type {Array<CrimeRiskResponse>}
     * @memberof CrimeRiskResponseList
     */
    'crimeRisk'?: Array<CrimeRiskResponse>;
}
/**
 * 
 * @export
 * @interface Crs
 */
export interface Crs {
    /**
     * 
     * @type {string}
     * @memberof Crs
     */
    'type': string;
    /**
     * 
     * @type {Properties}
     * @memberof Crs
     */
    'properties': Properties;
}
/**
 * 
 * @export
 * @interface Demographics
 */
export interface Demographics {
    /**
     * 
     * @type {Boundaries}
     * @memberof Demographics
     */
    'boundaries': Boundaries;
    /**
     * 
     * @type {DemographicsThemesV2}
     * @memberof Demographics
     */
    'themes': DemographicsThemesV2;
    /**
     * 
     * @type {Array<DemographicsThemesV2>}
     * @memberof Demographics
     */
    'boundaryThemes'?: Array<DemographicsThemesV2>;
}
/**
 * 
 * @export
 * @interface DemographicsAdvancedPreferences
 */
export interface DemographicsAdvancedPreferences {
    /**
     * 
     * @type {string}
     * @memberof DemographicsAdvancedPreferences
     */
    'profile'?: string;
    /**
     * 
     * @type {string}
     * @memberof DemographicsAdvancedPreferences
     */
    'filter'?: string;
    /**
     * 
     * @type {string}
     * @memberof DemographicsAdvancedPreferences
     */
    'includeGeometry'?: string;
}
/**
 * 
 * @export
 * @interface DemographicsAdvancedRequest
 */
export interface DemographicsAdvancedRequest {
    /**
     * 
     * @type {DemographicsAdvancedPreferences}
     * @memberof DemographicsAdvancedRequest
     */
    'preferences'?: DemographicsAdvancedPreferences;
    /**
     * 
     * @type {DemographicsGeometry}
     * @memberof DemographicsAdvancedRequest
     */
    'geometry'?: DemographicsGeometry;
    /**
     * 
     * @type {string}
     * @memberof DemographicsAdvancedRequest
     */
    'geometryAsText'?: string;
}
/**
 * 
 * @export
 * @interface DemographicsGeometry
 */
export interface DemographicsGeometry {
    /**
     * 
     * @type {string}
     * @memberof DemographicsGeometry
     */
    'type'?: string;
    /**
     * 
     * @type {DemographicsGeometryCRC}
     * @memberof DemographicsGeometry
     */
    'crs'?: DemographicsGeometryCRC;
    /**
     * 
     * @type {object}
     * @memberof DemographicsGeometry
     */
    'coordinates'?: object;
}
/**
 * 
 * @export
 * @interface DemographicsGeometryCRC
 */
export interface DemographicsGeometryCRC {
    /**
     * 
     * @type {string}
     * @memberof DemographicsGeometryCRC
     */
    'type'?: string;
    /**
     * 
     * @type {GeometryProperties}
     * @memberof DemographicsGeometryCRC
     */
    'properties'?: GeometryProperties;
}
/**
 * 
 * @export
 * @interface DemographicsThemesV2
 */
export interface DemographicsThemesV2 {
    /**
     * 
     * @type {string}
     * @memberof DemographicsThemesV2
     */
    'boundaryId'?: string;
    /**
     * 
     * @type {PopulationTheme}
     * @memberof DemographicsThemesV2
     */
    'populationTheme'?: PopulationTheme;
    /**
     * 
     * @type {RaceAndEthnicityTheme}
     * @memberof DemographicsThemesV2
     */
    'raceAndEthnicityTheme'?: RaceAndEthnicityTheme;
    /**
     * 
     * @type {HealthTheme}
     * @memberof DemographicsThemesV2
     */
    'healthTheme'?: HealthTheme;
    /**
     * 
     * @type {EducationTheme}
     * @memberof DemographicsThemesV2
     */
    'educationTheme'?: EducationTheme;
    /**
     * 
     * @type {IncomeTheme}
     * @memberof DemographicsThemesV2
     */
    'incomeTheme'?: IncomeTheme;
    /**
     * 
     * @type {AssetsAndWealthTheme}
     * @memberof DemographicsThemesV2
     */
    'assetsAndWealthTheme'?: AssetsAndWealthTheme;
    /**
     * 
     * @type {HouseholdsTheme}
     * @memberof DemographicsThemesV2
     */
    'householdsTheme'?: HouseholdsTheme;
    /**
     * 
     * @type {HousingTheme}
     * @memberof DemographicsThemesV2
     */
    'housingTheme'?: HousingTheme;
    /**
     * 
     * @type {EmploymentTheme}
     * @memberof DemographicsThemesV2
     */
    'employmentTheme'?: EmploymentTheme;
    /**
     * 
     * @type {ExpenditureTheme}
     * @memberof DemographicsThemesV2
     */
    'expenditureTheme'?: ExpenditureTheme;
    /**
     * 
     * @type {SupplyAndDemandTheme}
     * @memberof DemographicsThemesV2
     */
    'supplyAndDemandTheme'?: SupplyAndDemandTheme;
}
/**
 * 
 * @export
 * @interface Depth
 */
export interface Depth {
    /**
     * 
     * @type {string}
     * @memberof Depth
     */
    'unit'?: string;
    /**
     * 
     * @type {number}
     * @memberof Depth
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface DirectionGeometry
 */
export interface DirectionGeometry {
    /**
     * 
     * @type {string}
     * @memberof DirectionGeometry
     */
    'type'?: string;
    /**
     * 
     * @type {Array<Array<Array<Array<number>>>>}
     * @memberof DirectionGeometry
     */
    'coordinates'?: Array<Array<Array<Array<number>>>>;
}
/**
 * 
 * @export
 * @interface Distance
 */
export interface Distance {
    /**
     * 
     * @type {string}
     * @memberof Distance
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof Distance
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface DistanceToBorder
 */
export interface DistanceToBorder {
    /**
     * 
     * @type {string}
     * @memberof DistanceToBorder
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof DistanceToBorder
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface DistanceToFloodHazardAddressRequest
 */
export interface DistanceToFloodHazardAddressRequest {
    /**
     * 
     * @type {Array<RiskAddress>}
     * @memberof DistanceToFloodHazardAddressRequest
     */
    'addresses': Array<RiskAddress>;
    /**
     * 
     * @type {FloodHazardPreferences}
     * @memberof DistanceToFloodHazardAddressRequest
     */
    'preferences'?: FloodHazardPreferences;
}
/**
 * 
 * @export
 * @interface DistanceToFloodHazardLocationRequest
 */
export interface DistanceToFloodHazardLocationRequest {
    /**
     * 
     * @type {Array<RiskLocations>}
     * @memberof DistanceToFloodHazardLocationRequest
     */
    'locations': Array<RiskLocations>;
    /**
     * 
     * @type {FloodHazardPreferences}
     * @memberof DistanceToFloodHazardLocationRequest
     */
    'preferences'?: FloodHazardPreferences;
}
/**
 * 
 * @export
 * @interface DistanceToFloodHazardResponse
 */
export interface DistanceToFloodHazardResponse {
    /**
     * 
     * @type {Array<WaterBodyResponse>}
     * @memberof DistanceToFloodHazardResponse
     */
    'waterBodies'?: Array<WaterBodyResponse>;
}
/**
 * 
 * @export
 * @interface DistrictType
 */
export interface DistrictType {
    /**
     * 
     * @type {string}
     * @memberof DistrictType
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DistrictType
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface DomesticUltimateBusiness
 */
export interface DomesticUltimateBusiness {
    /**
     * 
     * @type {string}
     * @memberof DomesticUltimateBusiness
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomesticUltimateBusiness
     */
    'name'?: string;
    /**
     * 
     * @type {Address}
     * @memberof DomesticUltimateBusiness
     */
    'address'?: Address;
}
/**
 * 
 * @export
 * @interface EarthquakeDateTime
 */
export interface EarthquakeDateTime {
    /**
     * 
     * @type {string}
     * @memberof EarthquakeDateTime
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof EarthquakeDateTime
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface EarthquakeEvent
 */
export interface EarthquakeEvent {
    /**
     * 
     * @type {EarthquakeDateTime}
     * @memberof EarthquakeEvent
     */
    'dateTime'?: EarthquakeDateTime;
    /**
     * 
     * @type {number}
     * @memberof EarthquakeEvent
     */
    'seismicRegionNumber'?: number;
    /**
     * 
     * @type {Depth}
     * @memberof EarthquakeEvent
     */
    'depth'?: Depth;
    /**
     * 
     * @type {Magnitude}
     * @memberof EarthquakeEvent
     */
    'magnitude'?: Magnitude;
    /**
     * 
     * @type {string}
     * @memberof EarthquakeEvent
     */
    'cause'?: string;
    /**
     * 
     * @type {string}
     * @memberof EarthquakeEvent
     */
    'culturalEffect'?: string;
    /**
     * 
     * @type {number}
     * @memberof EarthquakeEvent
     */
    'intensity'?: number;
    /**
     * 
     * @type {string}
     * @memberof EarthquakeEvent
     */
    'diastrophism'?: string;
    /**
     * 
     * @type {string}
     * @memberof EarthquakeEvent
     */
    'miscPhenomena'?: string;
    /**
     * 
     * @type {EarthquakeLocation}
     * @memberof EarthquakeEvent
     */
    'location'?: EarthquakeLocation;
}
/**
 * 
 * @export
 * @interface EarthquakeEventsResponse
 */
export interface EarthquakeEventsResponse {
    /**
     * 
     * @type {Array<EarthquakeEvent>}
     * @memberof EarthquakeEventsResponse
     */
    'earthuakeEvents'?: Array<EarthquakeEvent>;
    /**
     * 
     * @type {Array<EarthquakeEvent>}
     * @memberof EarthquakeEventsResponse
     */
    'event'?: Array<EarthquakeEvent>;
}
/**
 * 
 * @export
 * @interface EarthquakeHistory
 */
export interface EarthquakeHistory {
    /**
     * 
     * @type {string}
     * @memberof EarthquakeHistory
     */
    'stateCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof EarthquakeHistory
     */
    'county'?: string;
    /**
     * 
     * @type {string}
     * @memberof EarthquakeHistory
     */
    'postCode'?: string;
    /**
     * 
     * @type {EarthquakeEventsResponse}
     * @memberof EarthquakeHistory
     */
    'events'?: EarthquakeEventsResponse;
}
/**
 * 
 * @export
 * @interface EarthquakeLocation
 */
export interface EarthquakeLocation {
    /**
     * 
     * @type {string}
     * @memberof EarthquakeLocation
     */
    'type'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof EarthquakeLocation
     */
    'coordinates'?: Array<number>;
}
/**
 * 
 * @export
 * @interface EarthquakeRiskByAddressRequest
 */
export interface EarthquakeRiskByAddressRequest {
    /**
     * 
     * @type {Array<RiskAddress>}
     * @memberof EarthquakeRiskByAddressRequest
     */
    'addresses': Array<RiskAddress>;
    /**
     * 
     * @type {RiskPreferences}
     * @memberof EarthquakeRiskByAddressRequest
     */
    'preferences'?: RiskPreferences;
}
/**
 * 
 * @export
 * @interface EarthquakeRiskByLocationRequest
 */
export interface EarthquakeRiskByLocationRequest {
    /**
     * 
     * @type {Array<RiskLocations>}
     * @memberof EarthquakeRiskByLocationRequest
     */
    'locations': Array<RiskLocations>;
    /**
     * 
     * @type {RiskPreferences}
     * @memberof EarthquakeRiskByLocationRequest
     */
    'preferences'?: RiskPreferences;
}
/**
 * 
 * @export
 * @interface EarthquakeRiskResponse
 */
export interface EarthquakeRiskResponse {
    /**
     * 
     * @type {string}
     * @memberof EarthquakeRiskResponse
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EarthquakeRiskResponse
     */
    'riskLevel'?: string;
    /**
     * 
     * @type {EventsCount}
     * @memberof EarthquakeRiskResponse
     */
    'eventsCount'?: EventsCount;
    /**
     * 
     * @type {Grid}
     * @memberof EarthquakeRiskResponse
     */
    'grid'?: Grid;
    /**
     * 
     * @type {RiskAddress}
     * @memberof EarthquakeRiskResponse
     */
    'matchedAddress'?: RiskAddress;
}
/**
 * 
 * @export
 * @interface EarthquakeRiskResponseList
 */
export interface EarthquakeRiskResponseList {
    /**
     * 
     * @type {Array<EarthquakeRiskResponse>}
     * @memberof EarthquakeRiskResponseList
     */
    'earthquakeRisk'?: Array<EarthquakeRiskResponse>;
}
/**
 * 
 * @export
 * @interface EducationTheme
 */
export interface EducationTheme {
    /**
     * 
     * @type {string}
     * @memberof EducationTheme
     */
    'boundaryRef'?: string;
    /**
     * 
     * @type {Array<IndividualValueVariable>}
     * @memberof EducationTheme
     */
    'individualValueVariable'?: Array<IndividualValueVariable>;
    /**
     * 
     * @type {Array<RangeVariable>}
     * @memberof EducationTheme
     */
    'rangeVariable'?: Array<RangeVariable>;
}
/**
 * 
 * @export
 * @interface EmployeeCount
 */
export interface EmployeeCount {
    /**
     * 
     * @type {string}
     * @memberof EmployeeCount
     */
    'inLocalBranch'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmployeeCount
     */
    'inOrganization'?: string;
}
/**
 * 
 * @export
 * @interface EmploymentTheme
 */
export interface EmploymentTheme {
    /**
     * 
     * @type {string}
     * @memberof EmploymentTheme
     */
    'boundaryRef'?: string;
    /**
     * 
     * @type {Array<IndividualValueVariable>}
     * @memberof EmploymentTheme
     */
    'individualValueVariable'?: Array<IndividualValueVariable>;
    /**
     * 
     * @type {Array<RangeVariable>}
     * @memberof EmploymentTheme
     */
    'rangeVariable'?: Array<RangeVariable>;
}
/**
 * 
 * @export
 * @interface EnergyType
 */
export interface EnergyType {
    /**
     * 
     * @type {string}
     * @memberof EnergyType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnergyType
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface ErrorCode
 */
export interface ErrorCode {
    /**
     * 
     * @type {string}
     * @memberof ErrorCode
     */
    'errorCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorCode
     */
    'errorDescription'?: string;
}
/**
 * 
 * @export
 * @interface ErrorInfo
 */
export interface ErrorInfo {
    /**
     * 
     * @type {Array<ErrorCode>}
     * @memberof ErrorInfo
     */
    'errors'?: Array<ErrorCode>;
}
/**
 * 
 * @export
 * @interface EventsCount
 */
export interface EventsCount {
    /**
     * 
     * @type {string}
     * @memberof EventsCount
     */
    'total'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCount
     */
    'r0'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCount
     */
    'r1'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCount
     */
    'r2'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCount
     */
    'r3'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCount
     */
    'r4'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCount
     */
    'r5'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCount
     */
    'r6'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCount
     */
    'r7'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCount
     */
    'r0_ge'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCount
     */
    'r1_ge'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCount
     */
    'r2_ge'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCount
     */
    'r3_ge'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCount
     */
    'r4_ge'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCount
     */
    'r5_ge'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCount
     */
    'r6_ge'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCount
     */
    'r7_ge'?: string;
}
/**
 * 
 * @export
 * @interface ExpenditureTheme
 */
export interface ExpenditureTheme {
    /**
     * 
     * @type {string}
     * @memberof ExpenditureTheme
     */
    'boundaryRef'?: string;
    /**
     * 
     * @type {Array<IndividualValueVariable>}
     * @memberof ExpenditureTheme
     */
    'individualValueVariable'?: Array<IndividualValueVariable>;
    /**
     * 
     * @type {Array<RangeVariable>}
     * @memberof ExpenditureTheme
     */
    'rangeVariable'?: Array<RangeVariable>;
}
/**
 * 
 * @export
 * @interface ExteriorWalls
 */
export interface ExteriorWalls {
    /**
     * 
     * @type {string}
     * @memberof ExteriorWalls
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExteriorWalls
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface ExtraFeatureSqft
 */
export interface ExtraFeatureSqft {
    /**
     * 
     * @type {string}
     * @memberof ExtraFeatureSqft
     */
    'featureAreaSqFt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExtraFeatureSqft
     */
    'areaIndicator'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExtraFeatureSqft
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface Field
 */
export interface Field {
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface FieldsMatching
 */
export interface FieldsMatching {
    /**
     * 
     * @type {boolean}
     * @memberof FieldsMatching
     */
    'matchOnAddressNumber'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FieldsMatching
     */
    'matchOnPostCode1'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FieldsMatching
     */
    'matchOnPostCode2'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FieldsMatching
     */
    'matchOnAreaName1'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FieldsMatching
     */
    'matchOnAreaName2'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FieldsMatching
     */
    'matchOnAreaName3'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FieldsMatching
     */
    'matchOnAreaName4'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FieldsMatching
     */
    'matchOnAllStreetFields'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FieldsMatching
     */
    'matchOnStreetName'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FieldsMatching
     */
    'matchOnStreetType'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FieldsMatching
     */
    'matchOnStreetDirectional'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FieldsMatching
     */
    'matchOnPlaceName'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FieldsMatching
     */
    'matchOnInputFields'?: boolean;
}
/**
 * 
 * @export
 * @interface FireDepartment
 */
export interface FireDepartment {
    /**
     * 
     * @type {string}
     * @memberof FireDepartment
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FireDepartment
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof FireDepartment
     */
    'numberOfStations'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FireDepartment
     */
    'administrativeOfficeOnly'?: boolean;
    /**
     * 
     * @type {FireStationContactDetails}
     * @memberof FireDepartment
     */
    'contactDetails'?: FireStationContactDetails;
}
/**
 * 
 * @export
 * @interface FireEvent
 */
export interface FireEvent {
    /**
     * 
     * @type {string}
     * @memberof FireEvent
     */
    'fireStartDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof FireEvent
     */
    'fireEndDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof FireEvent
     */
    'fireName'?: string;
    /**
     * 
     * @type {Area}
     * @memberof FireEvent
     */
    'area'?: Area;
    /**
     * 
     * @type {string}
     * @memberof FireEvent
     */
    'agency'?: string;
}
/**
 * 
 * @export
 * @interface FireEventsResponse
 */
export interface FireEventsResponse {
    /**
     * 
     * @type {Array<FireEvent>}
     * @memberof FireEventsResponse
     */
    'event'?: Array<FireEvent>;
}
/**
 * 
 * @export
 * @interface FireHistory
 */
export interface FireHistory {
    /**
     * 
     * @type {string}
     * @memberof FireHistory
     */
    'stateCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof FireHistory
     */
    'postCode'?: string;
    /**
     * 
     * @type {FireEventsResponse}
     * @memberof FireHistory
     */
    'events'?: FireEventsResponse;
}
/**
 * 
 * @export
 * @interface FireRiskByAddressRequest
 */
export interface FireRiskByAddressRequest {
    /**
     * 
     * @type {Array<RiskAddress>}
     * @memberof FireRiskByAddressRequest
     */
    'addresses': Array<RiskAddress>;
    /**
     * 
     * @type {RiskPreferences}
     * @memberof FireRiskByAddressRequest
     */
    'preferences'?: RiskPreferences;
}
/**
 * 
 * @export
 * @interface FireRiskByLocationRequest
 */
export interface FireRiskByLocationRequest {
    /**
     * 
     * @type {Array<RiskLocations>}
     * @memberof FireRiskByLocationRequest
     */
    'locations': Array<RiskLocations>;
    /**
     * 
     * @type {RiskPreferences}
     * @memberof FireRiskByLocationRequest
     */
    'preferences'?: RiskPreferences;
}
/**
 * 
 * @export
 * @interface FireRiskResponse
 */
export interface FireRiskResponse {
    /**
     * 
     * @type {string}
     * @memberof FireRiskResponse
     */
    'objectId'?: string;
    /**
     * 
     * @type {State}
     * @memberof FireRiskResponse
     */
    'state'?: State;
    /**
     * 
     * @type {FireShed}
     * @memberof FireRiskResponse
     */
    'fireShed'?: FireShed;
    /**
     * 
     * @type {RiskAddress}
     * @memberof FireRiskResponse
     */
    'matchedAddress'?: RiskAddress;
}
/**
 * 
 * @export
 * @interface FireRiskResponseList
 */
export interface FireRiskResponseList {
    /**
     * 
     * @type {Array<FireRiskResponse>}
     * @memberof FireRiskResponseList
     */
    'fireRisk'?: Array<FireRiskResponse>;
}
/**
 * 
 * @export
 * @interface FireShed
 */
export interface FireShed {
    /**
     * 
     * @type {number}
     * @memberof FireShed
     */
    'id'?: number;
    /**
     * 
     * @type {Risk}
     * @memberof FireShed
     */
    'risk'?: Risk;
    /**
     * 
     * @type {CommonGeometry}
     * @memberof FireShed
     */
    'geometry'?: CommonGeometry;
}
/**
 * 
 * @export
 * @interface FireStation
 */
export interface FireStation {
    /**
     * 
     * @type {string}
     * @memberof FireStation
     */
    'numWithinDepartment'?: string;
    /**
     * 
     * @type {string}
     * @memberof FireStation
     */
    'locationReference'?: string;
    /**
     * 
     * @type {Distance}
     * @memberof FireStation
     */
    'travelDistance'?: Distance;
    /**
     * 
     * @type {Time}
     * @memberof FireStation
     */
    'travelTime'?: Time;
    /**
     * 
     * @type {FireStationContactDetails}
     * @memberof FireStation
     */
    'contactDetails'?: FireStationContactDetails;
    /**
     * 
     * @type {FireDepartment}
     * @memberof FireStation
     */
    'fireDepartment'?: FireDepartment;
    /**
     * 
     * @type {Geometry}
     * @memberof FireStation
     */
    'geometry'?: Geometry;
}
/**
 * 
 * @export
 * @interface FireStationContactDetails
 */
export interface FireStationContactDetails {
    /**
     * 
     * @type {RiskAddress}
     * @memberof FireStationContactDetails
     */
    'address'?: RiskAddress;
    /**
     * 
     * @type {string}
     * @memberof FireStationContactDetails
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof FireStationContactDetails
     */
    'fax'?: string;
}
/**
 * 
 * @export
 * @interface FireStations
 */
export interface FireStations {
    /**
     * 
     * @type {Array<FireStation>}
     * @memberof FireStations
     */
    'fireStation'?: Array<FireStation>;
    /**
     * 
     * @type {RiskAddress}
     * @memberof FireStations
     */
    'matchedAddress'?: RiskAddress;
}
/**
 * 
 * @export
 * @interface FireplaceType
 */
export interface FireplaceType {
    /**
     * 
     * @type {string}
     * @memberof FireplaceType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof FireplaceType
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface FloodHazardPreferences
 */
export interface FloodHazardPreferences {
    /**
     * 
     * @type {string}
     * @memberof FloodHazardPreferences
     */
    'waterBodyType'?: string;
    /**
     * 
     * @type {string}
     * @memberof FloodHazardPreferences
     */
    'maxCandidates'?: string;
    /**
     * 
     * @type {string}
     * @memberof FloodHazardPreferences
     */
    'searchDistance'?: string;
    /**
     * 
     * @type {string}
     * @memberof FloodHazardPreferences
     */
    'searchDistanceUnit'?: string;
}
/**
 * 
 * @export
 * @interface FloodRiskByAddressRequest
 */
export interface FloodRiskByAddressRequest {
    /**
     * 
     * @type {Array<RiskAddress>}
     * @memberof FloodRiskByAddressRequest
     */
    'addresses': Array<RiskAddress>;
    /**
     * 
     * @type {FloodRiskPreferences}
     * @memberof FloodRiskByAddressRequest
     */
    'preferences'?: FloodRiskPreferences;
}
/**
 * 
 * @export
 * @interface FloodRiskByLocationRequest
 */
export interface FloodRiskByLocationRequest {
    /**
     * 
     * @type {Array<RiskLocations>}
     * @memberof FloodRiskByLocationRequest
     */
    'locations': Array<RiskLocations>;
    /**
     * 
     * @type {FloodRiskPreferences}
     * @memberof FloodRiskByLocationRequest
     */
    'preferences'?: FloodRiskPreferences;
}
/**
 * 
 * @export
 * @interface FloodRiskPreferences
 */
export interface FloodRiskPreferences {
    /**
     * 
     * @type {string}
     * @memberof FloodRiskPreferences
     */
    'includeGeometry'?: string;
    /**
     * 
     * @type {string}
     * @memberof FloodRiskPreferences
     */
    'includeZoneDesc'?: string;
    /**
     * 
     * @type {string}
     * @memberof FloodRiskPreferences
     */
    'richterValue'?: string;
}
/**
 * 
 * @export
 * @interface FloodRiskResponse
 */
export interface FloodRiskResponse {
    /**
     * 
     * @type {string}
     * @memberof FloodRiskResponse
     */
    'objectId'?: string;
    /**
     * 
     * @type {State}
     * @memberof FloodRiskResponse
     */
    'state'?: State;
    /**
     * 
     * @type {FloodZone}
     * @memberof FloodRiskResponse
     */
    'floodZone'?: FloodZone;
    /**
     * 
     * @type {Community}
     * @memberof FloodRiskResponse
     */
    'community'?: Community;
    /**
     * 
     * @type {CrimeBoundary}
     * @memberof FloodRiskResponse
     */
    'boundary'?: CrimeBoundary;
    /**
     * 
     * @type {RiskAddress}
     * @memberof FloodRiskResponse
     */
    'matchedAddress'?: RiskAddress;
}
/**
 * 
 * @export
 * @interface FloodRiskResponseList
 */
export interface FloodRiskResponseList {
    /**
     * 
     * @type {Array<FloodRiskResponse>}
     * @memberof FloodRiskResponseList
     */
    'floodRisk'?: Array<FloodRiskResponse>;
}
/**
 * 
 * @export
 * @interface FloodZone
 */
export interface FloodZone {
    /**
     * 
     * @type {string}
     * @memberof FloodZone
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof FloodZone
     */
    'areaType'?: string;
    /**
     * 
     * @type {string}
     * @memberof FloodZone
     */
    'riskLevel'?: string;
    /**
     * 
     * @type {PrimaryZone}
     * @memberof FloodZone
     */
    'primaryZone'?: PrimaryZone;
    /**
     * 
     * @type {BaseFloodElevation}
     * @memberof FloodZone
     */
    'baseFloodElevation'?: BaseFloodElevation;
    /**
     * 
     * @type {string}
     * @memberof FloodZone
     */
    'additionalInfo'?: string;
}
/**
 * 
 * @export
 * @interface FloorType
 */
export interface FloorType {
    /**
     * 
     * @type {string}
     * @memberof FloorType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof FloorType
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface FormattedTaxAddress
 */
export interface FormattedTaxAddress {
    /**
     * 
     * @type {string}
     * @memberof FormattedTaxAddress
     */
    'mainAddressLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormattedTaxAddress
     */
    'addressNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormattedTaxAddress
     */
    'streetPreDirection'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormattedTaxAddress
     */
    'streetName'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormattedTaxAddress
     */
    'streetType'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormattedTaxAddress
     */
    'streetPostDirection'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormattedTaxAddress
     */
    'unitType'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormattedTaxAddress
     */
    'unitValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormattedTaxAddress
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormattedTaxAddress
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormattedTaxAddress
     */
    'postCode1'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormattedTaxAddress
     */
    'postCode2'?: string;
}
/**
 * 
 * @export
 * @interface Foundation
 */
export interface Foundation {
    /**
     * 
     * @type {string}
     * @memberof Foundation
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Foundation
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface FreeOrReducedPriceLunches
 */
export interface FreeOrReducedPriceLunches {
    /**
     * 
     * @type {string}
     * @memberof FreeOrReducedPriceLunches
     */
    'freeLunchesCount'?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeOrReducedPriceLunches
     */
    'reducedPriceLunchedCount'?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeOrReducedPriceLunches
     */
    'totalCount'?: string;
}
/**
 * 
 * @export
 * @interface FuelType
 */
export interface FuelType {
    /**
     * 
     * @type {string}
     * @memberof FuelType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof FuelType
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface GarageType
 */
export interface GarageType {
    /**
     * 
     * @type {string}
     * @memberof GarageType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GarageType
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface GeoLocationAccessPoint
 */
export interface GeoLocationAccessPoint {
    /**
     * 
     * @type {GeolocationGeometry}
     * @memberof GeoLocationAccessPoint
     */
    'geometry'?: GeolocationGeometry;
    /**
     * 
     * @type {Accuracy}
     * @memberof GeoLocationAccessPoint
     */
    'accuracy'?: Accuracy;
}
/**
 * 
 * @export
 * @interface GeoLocationCountry
 */
export interface GeoLocationCountry {
    /**
     * 
     * @type {string}
     * @memberof GeoLocationCountry
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeoLocationCountry
     */
    'confidence'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeoLocationCountry
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface GeoLocationIpAddr
 */
export interface GeoLocationIpAddr {
    /**
     * 
     * @type {GeolocationGeometry}
     * @memberof GeoLocationIpAddr
     */
    'geometry'?: GeolocationGeometry;
    /**
     * 
     * @type {Accuracy}
     * @memberof GeoLocationIpAddr
     */
    'accuracy'?: Accuracy;
    /**
     * 
     * @type {IpInfo}
     * @memberof GeoLocationIpAddr
     */
    'ipInfo'?: IpInfo;
}
/**
 * 
 * @export
 * @interface GeoLocationPlace
 */
export interface GeoLocationPlace {
    /**
     * 
     * @type {string}
     * @memberof GeoLocationPlace
     */
    'continent'?: string;
    /**
     * 
     * @type {GeoLocationCountry}
     * @memberof GeoLocationPlace
     */
    'country'?: GeoLocationCountry;
    /**
     * 
     * @type {ConsistencyCode}
     * @memberof GeoLocationPlace
     */
    'consistencyCode'?: ConsistencyCode;
    /**
     * 
     * @type {string}
     * @memberof GeoLocationPlace
     */
    'region'?: string;
    /**
     * 
     * @type {GeoLocationState}
     * @memberof GeoLocationPlace
     */
    'state'?: GeoLocationState;
    /**
     * 
     * @type {City}
     * @memberof GeoLocationPlace
     */
    'city'?: City;
    /**
     * 
     * @type {string}
     * @memberof GeoLocationPlace
     */
    'postCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeoLocationPlace
     */
    'postCodeConfidence'?: string;
}
/**
 * 
 * @export
 * @interface GeoLocationState
 */
export interface GeoLocationState {
    /**
     * 
     * @type {string}
     * @memberof GeoLocationState
     */
    'confidence'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeoLocationState
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface GeoPos
 */
export interface GeoPos {
    /**
     * 
     * @type {string}
     * @memberof GeoPos
     */
    'type': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof GeoPos
     */
    'coordinates'?: Array<number>;
    /**
     * 
     * @type {Crs}
     * @memberof GeoPos
     */
    'crs': Crs;
}
/**
 * 
 * @export
 * @interface GeocodeAddress
 */
export interface GeocodeAddress {
    /**
     * 
     * @type {string}
     * @memberof GeocodeAddress
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodeAddress
     */
    'mainAddressLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodeAddress
     */
    'addressLastLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodeAddress
     */
    'placeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodeAddress
     */
    'areaName1'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodeAddress
     */
    'areaName2'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodeAddress
     */
    'areaName3'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodeAddress
     */
    'areaName4'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodeAddress
     */
    'postCode1'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodeAddress
     */
    'postCode2'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodeAddress
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodeAddress
     */
    'addressNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodeAddress
     */
    'streetName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodeAddress
     */
    'unitType'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodeAddress
     */
    'unitValue'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof GeocodeAddress
     */
    'customFields'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface GeocodePreferences
 */
export interface GeocodePreferences {
    /**
     * 
     * @type {boolean}
     * @memberof GeocodePreferences
     */
    'returnAllCandidateInfo': boolean;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'fallbackToGeographic': string;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'fallbackToPostal': string;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'maxReturnedCandidates': string;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'distance': string;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'streetOffset': string;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'cornerOffset': string;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'matchMode'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'clientLocale'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'clientCoordSysName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'distanceUnits'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'streetOffsetUnits'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'cornerOffsetUnits'?: string;
    /**
     * 
     * @type {FieldsMatching}
     * @memberof GeocodePreferences
     */
    'mustMatchFields'?: FieldsMatching;
    /**
     * 
     * @type {ReturnFieldsDescriptor}
     * @memberof GeocodePreferences
     */
    'returnFieldsDescriptor'?: ReturnFieldsDescriptor;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'outputRecordType'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof GeocodePreferences
     */
    'customPreferences'?: { [key: string]: object; };
    /**
     * 
     * @type {Array<string>}
     * @memberof GeocodePreferences
     */
    'preferredDictionaryOrders'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'outputCasing'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'latLongOffset'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'squeeze'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'returnLatLongFields'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'useGeoTaxAuxiliaryFile'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'latLongFormat'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'defaultBufferWidth'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeocodePreferences
     */
    'returnCensusFields'?: string;
}
/**
 * 
 * @export
 * @interface GeocodeRequest
 */
export interface GeocodeRequest {
    /**
     * 
     * @type {string}
     * @memberof GeocodeRequest
     */
    'type'?: string;
    /**
     * 
     * @type {GeocodePreferences}
     * @memberof GeocodeRequest
     */
    'preferences'?: GeocodePreferences;
    /**
     * 
     * @type {Array<GeocodeAddress>}
     * @memberof GeocodeRequest
     */
    'addresses': Array<GeocodeAddress>;
}
/**
 * 
 * @export
 * @interface GeocodeServiceResponse
 */
export interface GeocodeServiceResponse {
    /**
     * 
     * @type {string}
     * @memberof GeocodeServiceResponse
     */
    'objectId'?: string;
    /**
     * 
     * @type {number}
     * @memberof GeocodeServiceResponse
     */
    'totalPossibleCandidates'?: number;
    /**
     * 
     * @type {number}
     * @memberof GeocodeServiceResponse
     */
    'totalMatches'?: number;
    /**
     * 
     * @type {Array<Candidate>}
     * @memberof GeocodeServiceResponse
     */
    'candidates'?: Array<Candidate>;
}
/**
 * 
 * @export
 * @interface GeocodeServiceResponseList
 */
export interface GeocodeServiceResponseList {
    /**
     * 
     * @type {Array<GeocodeServiceResponse>}
     * @memberof GeocodeServiceResponseList
     */
    'responses'?: Array<GeocodeServiceResponse>;
}
/**
 * 
 * @export
 * @interface GeolocationGeometry
 */
export interface GeolocationGeometry {
    /**
     * 
     * @type {string}
     * @memberof GeolocationGeometry
     */
    'type'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof GeolocationGeometry
     */
    'coordinates'?: Array<number>;
}
/**
 * 
 * @export
 * @interface Geometry
 */
export interface Geometry {
    /**
     * 
     * @type {string}
     * @memberof Geometry
     */
    'type'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof Geometry
     */
    'coordinates'?: Array<number>;
}
/**
 * 
 * @export
 * @interface GeometryCRC
 */
export interface GeometryCRC {
    /**
     * 
     * @type {string}
     * @memberof GeometryCRC
     */
    'type'?: string;
    /**
     * 
     * @type {GeometryProperties}
     * @memberof GeometryCRC
     */
    'properties'?: GeometryProperties;
}
/**
 * 
 * @export
 * @interface GeometryProperties
 */
export interface GeometryProperties {
    /**
     * 
     * @type {string}
     * @memberof GeometryProperties
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GetCityStateProvinceAPIInput
 */
export interface GetCityStateProvinceAPIInput {
    /**
     * 
     * @type {Array<GetCityStateProvinceAPIInputRow>}
     * @memberof GetCityStateProvinceAPIInput
     */
    'Row'?: Array<GetCityStateProvinceAPIInputRow>;
}
/**
 * 
 * @export
 * @interface GetCityStateProvinceAPIInputRow
 */
export interface GetCityStateProvinceAPIInputRow {
    /**
     * These fields are returned, unmodified, in the user_fields section of the response.
     * @type {Array<GetPostalCodesAPIOutputUserFields>}
     * @memberof GetCityStateProvinceAPIInputRow
     */
    'user_fields'?: Array<GetPostalCodesAPIOutputUserFields>;
    /**
     * The validated ZIP Code or postal code.
     * @type {string}
     * @memberof GetCityStateProvinceAPIInputRow
     */
    'PostalCode'?: string;
}
/**
 * 
 * @export
 * @interface GetCityStateProvinceAPIOptions
 */
export interface GetCityStateProvinceAPIOptions {
    /**
     * Output VanityCity.
     * @type {string}
     * @memberof GetCityStateProvinceAPIOptions
     */
    'OutputVanityCity'?: string;
    /**
     * PerformCanadianProcessing.
     * @type {string}
     * @memberof GetCityStateProvinceAPIOptions
     */
    'PerformCanadianProcessing'?: string;
    /**
     * MaximumResults.
     * @type {string}
     * @memberof GetCityStateProvinceAPIOptions
     */
    'MaximumResults'?: string;
    /**
     * PerformUSProcessing.
     * @type {string}
     * @memberof GetCityStateProvinceAPIOptions
     */
    'PerformUSProcessing'?: string;
}
/**
 * 
 * @export
 * @interface GetCityStateProvinceAPIOutput
 */
export interface GetCityStateProvinceAPIOutput {
    /**
     * These fields are returned, unmodified, in the user_fields section of the response.
     * @type {Array<GetPostalCodesAPIOutputUserFields>}
     * @memberof GetCityStateProvinceAPIOutput
     */
    'user_fields'?: Array<GetPostalCodesAPIOutputUserFields>;
    /**
     * The validated ZIP Code or postal code.
     * @type {string}
     * @memberof GetCityStateProvinceAPIOutput
     */
    'PostalCode'?: string;
    /**
     * City
     * @type {string}
     * @memberof GetCityStateProvinceAPIOutput
     */
    'City'?: string;
    /**
     * City.Type
     * @type {string}
     * @memberof GetCityStateProvinceAPIOutput
     */
    'City.Type'?: string;
    /**
     * The state or province.
     * @type {string}
     * @memberof GetCityStateProvinceAPIOutput
     */
    'StateProvince'?: string;
    /**
     * Reports the success or failure of the match attempt.
     * @type {string}
     * @memberof GetCityStateProvinceAPIOutput
     */
    'Status'?: string;
    /**
     * Reason for failure, if there is one.
     * @type {string}
     * @memberof GetCityStateProvinceAPIOutput
     */
    'Status.Code'?: string;
    /**
     * Description of the problem, if there is one.
     * @type {string}
     * @memberof GetCityStateProvinceAPIOutput
     */
    'Status.Description'?: string;
}
/**
 * 
 * @export
 * @interface GetCityStateProvinceAPIRequest
 */
export interface GetCityStateProvinceAPIRequest {
    /**
     * 
     * @type {GetCityStateProvinceAPIOptions}
     * @memberof GetCityStateProvinceAPIRequest
     */
    'options'?: GetCityStateProvinceAPIOptions;
    /**
     * 
     * @type {GetCityStateProvinceAPIInput}
     * @memberof GetCityStateProvinceAPIRequest
     */
    'Input'?: GetCityStateProvinceAPIInput;
}
/**
 * 
 * @export
 * @interface GetCityStateProvinceAPIResponse
 */
export interface GetCityStateProvinceAPIResponse {
    /**
     * 
     * @type {Array<GetCityStateProvinceAPIOutput>}
     * @memberof GetCityStateProvinceAPIResponse
     */
    'Output'?: Array<GetCityStateProvinceAPIOutput>;
}
/**
 * 
 * @export
 * @interface GetPostalCodesAPIInput
 */
export interface GetPostalCodesAPIInput {
    /**
     * 
     * @type {Array<GetPostalCodesAPIInputRow>}
     * @memberof GetPostalCodesAPIInput
     */
    'Row'?: Array<GetPostalCodesAPIInputRow>;
}
/**
 * 
 * @export
 * @interface GetPostalCodesAPIInputRow
 */
export interface GetPostalCodesAPIInputRow {
    /**
     * These fields are returned, unmodified, in the user_fields section of the response.
     * @type {Array<GetPostalCodesAPIOutputUserFields>}
     * @memberof GetPostalCodesAPIInputRow
     */
    'user_fields'?: Array<GetPostalCodesAPIOutputUserFields>;
    /**
     * The city name.
     * @type {string}
     * @memberof GetPostalCodesAPIInputRow
     */
    'City'?: string;
    /**
     * The state or province.
     * @type {string}
     * @memberof GetPostalCodesAPIInputRow
     */
    'StateProvince'?: string;
}
/**
 * 
 * @export
 * @interface GetPostalCodesAPIOptions
 */
export interface GetPostalCodesAPIOptions {
    /**
     * Output CityType.
     * @type {string}
     * @memberof GetPostalCodesAPIOptions
     */
    'OutputCityType'?: string;
    /**
     * Output VanityCity.
     * @type {string}
     * @memberof GetPostalCodesAPIOptions
     */
    'OutputVanityCity'?: string;
}
/**
 * 
 * @export
 * @interface GetPostalCodesAPIOutput
 */
export interface GetPostalCodesAPIOutput {
    /**
     * These fields are returned, unmodified, in the user_fields section of the response.
     * @type {Array<GetPostalCodesAPIOutputUserFields>}
     * @memberof GetPostalCodesAPIOutput
     */
    'user_fields'?: Array<GetPostalCodesAPIOutputUserFields>;
    /**
     * The validated ZIP Code or postal code.
     * @type {string}
     * @memberof GetPostalCodesAPIOutput
     */
    'PostalCode'?: string;
    /**
     * City.Type
     * @type {string}
     * @memberof GetPostalCodesAPIOutput
     */
    'City.Type'?: string;
    /**
     * Reports the success or failure of the match attempt.
     * @type {string}
     * @memberof GetPostalCodesAPIOutput
     */
    'Status'?: string;
    /**
     * Reason for failure, if there is one.
     * @type {string}
     * @memberof GetPostalCodesAPIOutput
     */
    'Status.Code'?: string;
    /**
     * Description of the problem, if there is one.
     * @type {string}
     * @memberof GetPostalCodesAPIOutput
     */
    'Status.Description'?: string;
}
/**
 * 
 * @export
 * @interface GetPostalCodesAPIOutputUserFields
 */
export interface GetPostalCodesAPIOutputUserFields {
    /**
     * 
     * @type {string}
     * @memberof GetPostalCodesAPIOutputUserFields
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPostalCodesAPIOutputUserFields
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface GetPostalCodesAPIRequest
 */
export interface GetPostalCodesAPIRequest {
    /**
     * 
     * @type {GetPostalCodesAPIOptions}
     * @memberof GetPostalCodesAPIRequest
     */
    'options'?: GetPostalCodesAPIOptions;
    /**
     * 
     * @type {GetPostalCodesAPIInput}
     * @memberof GetPostalCodesAPIRequest
     */
    'Input'?: GetPostalCodesAPIInput;
}
/**
 * 
 * @export
 * @interface GetPostalCodesAPIResponse
 */
export interface GetPostalCodesAPIResponse {
    /**
     * 
     * @type {Array<GetPostalCodesAPIOutput>}
     * @memberof GetPostalCodesAPIResponse
     */
    'Output'?: Array<GetPostalCodesAPIOutput>;
}
/**
 * 
 * @export
 * @interface GlobalUltimateBusiness
 */
export interface GlobalUltimateBusiness {
    /**
     * 
     * @type {string}
     * @memberof GlobalUltimateBusiness
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalUltimateBusiness
     */
    'name'?: string;
    /**
     * 
     * @type {Address}
     * @memberof GlobalUltimateBusiness
     */
    'address'?: Address;
}
/**
 * 
 * @export
 * @interface GradeLevelsTaught
 */
export interface GradeLevelsTaught {
    /**
     * 
     * @type {string}
     * @memberof GradeLevelsTaught
     */
    'pk'?: string;
    /**
     * 
     * @type {string}
     * @memberof GradeLevelsTaught
     */
    'kg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GradeLevelsTaught
     */
    'first'?: string;
    /**
     * 
     * @type {string}
     * @memberof GradeLevelsTaught
     */
    'second'?: string;
    /**
     * 
     * @type {string}
     * @memberof GradeLevelsTaught
     */
    'third'?: string;
    /**
     * 
     * @type {string}
     * @memberof GradeLevelsTaught
     */
    'fourth'?: string;
    /**
     * 
     * @type {string}
     * @memberof GradeLevelsTaught
     */
    'fifth'?: string;
    /**
     * 
     * @type {string}
     * @memberof GradeLevelsTaught
     */
    'sixth'?: string;
    /**
     * 
     * @type {string}
     * @memberof GradeLevelsTaught
     */
    'seventh'?: string;
    /**
     * 
     * @type {string}
     * @memberof GradeLevelsTaught
     */
    'eighth'?: string;
    /**
     * 
     * @type {string}
     * @memberof GradeLevelsTaught
     */
    'ninth'?: string;
    /**
     * 
     * @type {string}
     * @memberof GradeLevelsTaught
     */
    'tenth'?: string;
    /**
     * 
     * @type {string}
     * @memberof GradeLevelsTaught
     */
    'eleventh'?: string;
    /**
     * 
     * @type {string}
     * @memberof GradeLevelsTaught
     */
    'twelfth'?: string;
}
/**
 * 
 * @export
 * @interface Greatschools
 */
export interface Greatschools {
    /**
     * 
     * @type {string}
     * @memberof Greatschools
     */
    'gsId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Greatschools
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Greatschools
     */
    'rating'?: string;
}
/**
 * 
 * @export
 * @interface Grid
 */
export interface Grid {
    /**
     * 
     * @type {string}
     * @memberof Grid
     */
    'code'?: string;
    /**
     * 
     * @type {CommonGeometry}
     * @memberof Grid
     */
    'geometry'?: CommonGeometry;
}
/**
 * 
 * @export
 * @interface HealthTheme
 */
export interface HealthTheme {
    /**
     * 
     * @type {string}
     * @memberof HealthTheme
     */
    'boundaryRef'?: string;
    /**
     * 
     * @type {Array<IndividualValueVariable>}
     * @memberof HealthTheme
     */
    'individualValueVariable'?: Array<IndividualValueVariable>;
    /**
     * 
     * @type {Array<RangeVariable>}
     * @memberof HealthTheme
     */
    'rangeVariable'?: Array<RangeVariable>;
}
/**
 * 
 * @export
 * @interface HeatingType
 */
export interface HeatingType {
    /**
     * 
     * @type {string}
     * @memberof HeatingType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof HeatingType
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface HouseholdsTheme
 */
export interface HouseholdsTheme {
    /**
     * 
     * @type {string}
     * @memberof HouseholdsTheme
     */
    'boundaryRef'?: string;
    /**
     * 
     * @type {Array<IndividualValueVariable>}
     * @memberof HouseholdsTheme
     */
    'individualValueVariable'?: Array<IndividualValueVariable>;
    /**
     * 
     * @type {Array<RangeVariable>}
     * @memberof HouseholdsTheme
     */
    'rangeVariable'?: Array<RangeVariable>;
}
/**
 * 
 * @export
 * @interface HousingTheme
 */
export interface HousingTheme {
    /**
     * 
     * @type {string}
     * @memberof HousingTheme
     */
    'boundaryRef'?: string;
    /**
     * 
     * @type {Array<IndividualValueVariable>}
     * @memberof HousingTheme
     */
    'individualValueVariable'?: Array<IndividualValueVariable>;
    /**
     * 
     * @type {Array<RangeVariable>}
     * @memberof HousingTheme
     */
    'rangeVariable'?: Array<RangeVariable>;
}
/**
 * 
 * @export
 * @interface IPDTaxByAddressBatchRequest
 */
export interface IPDTaxByAddressBatchRequest {
    /**
     * 
     * @type {Array<TaxRateMatchedAddress>}
     * @memberof IPDTaxByAddressBatchRequest
     */
    'addresses': Array<TaxRateMatchedAddress>;
    /**
     * 
     * @type {LocalTaxPreferences}
     * @memberof IPDTaxByAddressBatchRequest
     */
    'preferences'?: LocalTaxPreferences;
}
/**
 * 
 * @export
 * @interface IPDTaxJurisdiction
 */
export interface IPDTaxJurisdiction {
    /**
     * 
     * @type {TaxState}
     * @memberof IPDTaxJurisdiction
     */
    'state'?: TaxState;
    /**
     * 
     * @type {TaxCounty}
     * @memberof IPDTaxJurisdiction
     */
    'county'?: TaxCounty;
    /**
     * 
     * @type {TaxPlace}
     * @memberof IPDTaxJurisdiction
     */
    'place'?: TaxPlace;
}
/**
 * 
 * @export
 * @interface IncomeTheme
 */
export interface IncomeTheme {
    /**
     * 
     * @type {string}
     * @memberof IncomeTheme
     */
    'boundaryRef'?: string;
    /**
     * 
     * @type {Array<IndividualValueVariable>}
     * @memberof IncomeTheme
     */
    'individualValueVariable'?: Array<IndividualValueVariable>;
    /**
     * 
     * @type {Array<RangeVariable>}
     * @memberof IncomeTheme
     */
    'rangeVariable'?: Array<RangeVariable>;
}
/**
 * 
 * @export
 * @interface IndexVariable
 */
export interface IndexVariable {
    /**
     * 
     * @type {string}
     * @memberof IndexVariable
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndexVariable
     */
    'score'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndexVariable
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndexVariable
     */
    'percentile'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndexVariable
     */
    'stateScore'?: string;
}
/**
 * 
 * @export
 * @interface IndividualValueVariable
 */
export interface IndividualValueVariable {
    /**
     * 
     * @type {string}
     * @memberof IndividualValueVariable
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualValueVariable
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualValueVariable
     */
    'year'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualValueVariable
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface InteriorWall
 */
export interface InteriorWall {
    /**
     * 
     * @type {string}
     * @memberof InteriorWall
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof InteriorWall
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface IntermediatePoints
 */
export interface IntermediatePoints {
    /**
     * 
     * @type {string}
     * @memberof IntermediatePoints
     */
    'type'?: string;
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof IntermediatePoints
     */
    'coordinates'?: Array<Array<number>>;
}
/**
 * 
 * @export
 * @interface Intersection
 */
export interface Intersection {
    /**
     * 
     * @type {Unit}
     * @memberof Intersection
     */
    'distance'?: Unit;
    /**
     * 
     * @type {Unit}
     * @memberof Intersection
     */
    'driveTime'?: Unit;
    /**
     * 
     * @type {Unit}
     * @memberof Intersection
     */
    'driveDistance'?: Unit;
    /**
     * 
     * @type {Geometry}
     * @memberof Intersection
     */
    'geometry'?: Geometry;
    /**
     * 
     * @type {Set<Road>}
     * @memberof Intersection
     */
    'roads'?: Set<Road>;
}
/**
 * 
 * @export
 * @interface IntersectionResponse
 */
export interface IntersectionResponse {
    /**
     * 
     * @type {Array<Intersection>}
     * @memberof IntersectionResponse
     */
    'intersection'?: Array<Intersection>;
    /**
     * 
     * @type {Address}
     * @memberof IntersectionResponse
     */
    'matchedAddress'?: Address;
}
/**
 * 
 * @export
 * @interface IpInfo
 */
export interface IpInfo {
    /**
     * 
     * @type {string}
     * @memberof IpInfo
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {Proxy}
     * @memberof IpInfo
     */
    'proxy'?: Proxy;
    /**
     * 
     * @type {Network}
     * @memberof IpInfo
     */
    'network'?: Network;
    /**
     * 
     * @type {GeoLocationPlace}
     * @memberof IpInfo
     */
    'place'?: GeoLocationPlace;
}
/**
 * 
 * @export
 * @interface Ipd
 */
export interface Ipd {
    /**
     * 
     * @type {string}
     * @memberof Ipd
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ipd
     */
    'districtName'?: string;
    /**
     * 
     * @type {DistrictType}
     * @memberof Ipd
     */
    'districtType'?: DistrictType;
    /**
     * 
     * @type {string}
     * @memberof Ipd
     */
    'taxCodeDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ipd
     */
    'effectiveDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ipd
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {BoundaryBuffer}
     * @memberof Ipd
     */
    'boundaryBuffer'?: BoundaryBuffer;
    /**
     * 
     * @type {Array<Rate>}
     * @memberof Ipd
     */
    'rates'?: Array<Rate>;
}
/**
 * 
 * @export
 * @interface KeyLookupRequest
 */
export interface KeyLookupRequest {
    /**
     * 
     * @type {string}
     * @memberof KeyLookupRequest
     */
    'type'?: string;
    /**
     * 
     * @type {GeocodePreferences}
     * @memberof KeyLookupRequest
     */
    'preferences'?: GeocodePreferences;
    /**
     * 
     * @type {Array<Keys>}
     * @memberof KeyLookupRequest
     */
    'keys'?: Array<Keys>;
}
/**
 * 
 * @export
 * @interface Keys
 */
export interface Keys {
    /**
     * 
     * @type {string}
     * @memberof Keys
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Keys
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof Keys
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface LandUse
 */
export interface LandUse {
    /**
     * 
     * @type {string}
     * @memberof LandUse
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof LandUse
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface LatLongFields
 */
export interface LatLongFields {
    /**
     * 
     * @type {string}
     * @memberof LatLongFields
     */
    'matchCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof LatLongFields
     */
    'matchLevel'?: string;
    /**
     * 
     * @type {string}
     * @memberof LatLongFields
     */
    'streetMatchCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof LatLongFields
     */
    'streetMatchLevel'?: string;
    /**
     * 
     * @type {LocalTaxGeometry}
     * @memberof LatLongFields
     */
    'geometry'?: LocalTaxGeometry;
}
/**
 * 
 * @export
 * @interface LifeStyleTheme
 */
export interface LifeStyleTheme {
    /**
     * 
     * @type {string}
     * @memberof LifeStyleTheme
     */
    'boundaryRef'?: string;
    /**
     * 
     * @type {Array<IndividualValueVariable>}
     * @memberof LifeStyleTheme
     */
    'individualValueVariable'?: Array<IndividualValueVariable>;
    /**
     * 
     * @type {Array<RangeVariable>}
     * @memberof LifeStyleTheme
     */
    'rangeVariable'?: Array<RangeVariable>;
}
/**
 * 
 * @export
 * @interface LocCode
 */
export interface LocCode {
    /**
     * 
     * @type {string}
     * @memberof LocCode
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocCode
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface LocalTaxGeometry
 */
export interface LocalTaxGeometry {
    /**
     * 
     * @type {string}
     * @memberof LocalTaxGeometry
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LocalTaxGeometry
     */
    'coordinates'?: Array<string>;
}
/**
 * 
 * @export
 * @interface LocalTaxPreferences
 */
export interface LocalTaxPreferences {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof LocalTaxPreferences
     */
    'customPreferences'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof LocalTaxPreferences
     */
    'defaultBufferWidth'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocalTaxPreferences
     */
    'distanceUnits'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocalTaxPreferences
     */
    'fallbackToGeographic': string;
    /**
     * 
     * @type {string}
     * @memberof LocalTaxPreferences
     */
    'latLongFormat'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocalTaxPreferences
     */
    'latLongOffset'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocalTaxPreferences
     */
    'matchMode'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocalTaxPreferences
     */
    'outputCasing'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocalTaxPreferences
     */
    'returnCensusFields'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocalTaxPreferences
     */
    'returnLatLongFields'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocalTaxPreferences
     */
    'squeeze'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocalTaxPreferences
     */
    'taxRatetypeID'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocalTaxPreferences
     */
    'useGeoTaxAuxiliaryFile'?: string;
}
/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {Place}
     * @memberof Location
     */
    'place'?: Place;
}
/**
 * 
 * @export
 * @interface LocationTime
 */
export interface LocationTime {
    /**
     * 
     * @type {TimezoneGeometry}
     * @memberof LocationTime
     */
    'geometry': TimezoneGeometry;
    /**
     * 
     * @type {string}
     * @memberof LocationTime
     */
    'purchaseAmount'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationTime
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationTime
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface Magnitude
 */
export interface Magnitude {
    /**
     * 
     * @type {number}
     * @memberof Magnitude
     */
    'value'?: number;
    /**
     * 
     * @type {string}
     * @memberof Magnitude
     */
    'scale'?: string;
    /**
     * 
     * @type {number}
     * @memberof Magnitude
     */
    'bodyWave'?: number;
    /**
     * 
     * @type {number}
     * @memberof Magnitude
     */
    'surfaceWave'?: number;
    /**
     * 
     * @type {number}
     * @memberof Magnitude
     */
    'surfaceWaveValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Magnitude
     */
    'bodyWaveValue'?: number;
}
/**
 * 
 * @export
 * @interface Match
 */
export interface Match {
    /**
     * 
     * @type {string}
     * @memberof Match
     */
    'confidence'?: string;
    /**
     * 
     * @type {string}
     * @memberof Match
     */
    'percentGeocode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Match
     */
    'precisionLevel'?: string;
    /**
     * 
     * @type {string}
     * @memberof Match
     */
    'locationCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Match
     */
    'matchCode'?: string;
}
/**
 * 
 * @export
 * @interface MatchedAddress
 */
export interface MatchedAddress {
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'streetSide'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'businessName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'addressLine1'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'addressLine2'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'addressLine3'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'stateProvince'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'county'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'latitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'longitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'urbanizationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'formattedAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'mainAddressLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'addressLastLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'placeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'areaName1'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'areaName2'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'areaName3'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'areaName4'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'postCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'postCodeExt'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'addressNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'streetName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'unitType'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchedAddress
     */
    'unitValue'?: string;
}
/**
 * 
 * @export
 * @interface Matrix
 */
export interface Matrix {
    /**
     * 
     * @type {number}
     * @memberof Matrix
     */
    'distance'?: number;
    /**
     * 
     * @type {string}
     * @memberof Matrix
     */
    'distanceUnit'?: string;
    /**
     * 
     * @type {StartEndPoint}
     * @memberof Matrix
     */
    'endPoint'?: StartEndPoint;
    /**
     * 
     * @type {StartEndPoint}
     * @memberof Matrix
     */
    'startPoint'?: StartEndPoint;
    /**
     * 
     * @type {number}
     * @memberof Matrix
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof Matrix
     */
    'timeUnit'?: string;
}
/**
 * 
 * @export
 * @interface Mcd
 */
export interface Mcd {
    /**
     * 
     * @type {string}
     * @memberof Mcd
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Mcd
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface MetadataResponse
 */
export interface MetadataResponse {
    /**
     * 
     * @type {Array<SicMetadata>}
     * @memberof MetadataResponse
     */
    'sic'?: Array<SicMetadata>;
    /**
     * 
     * @type {Array<CategoryMetadata>}
     * @memberof MetadataResponse
     */
    'category'?: Array<CategoryMetadata>;
}
/**
 * 
 * @export
 * @interface Name
 */
export interface Name {
    /**
     * 
     * @type {string}
     * @memberof Name
     */
    'langISOCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Name
     */
    'langType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Name
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface NeighborhoodsResponse
 */
export interface NeighborhoodsResponse {
    /**
     * 
     * @type {Array<Location>}
     * @memberof NeighborhoodsResponse
     */
    'location'?: Array<Location>;
}
/**
 * 
 * @export
 * @interface Network
 */
export interface Network {
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'connectionFromHome'?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'organization'?: string;
    /**
     * 
     * @type {Carrier}
     * @memberof Network
     */
    'carrier'?: Carrier;
    /**
     * 
     * @type {OrganizationType}
     * @memberof Network
     */
    'organizationType'?: OrganizationType;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'connectionType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'lineSpeed'?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'ipRouteType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'hostingFacility'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationType
 */
export interface OrganizationType {
    /**
     * 
     * @type {string}
     * @memberof OrganizationType
     */
    'naicsCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationType
     */
    'isicCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationType
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface OtherRooms
 */
export interface OtherRooms {
    /**
     * 
     * @type {string}
     * @memberof OtherRooms
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof OtherRooms
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface OwnerVestType
 */
export interface OwnerVestType {
    /**
     * 
     * @type {string}
     * @memberof OwnerVestType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof OwnerVestType
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface Owners
 */
export interface Owners {
    /**
     * 
     * @type {string}
     * @memberof Owners
     */
    'ownerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Owners
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Owners
     */
    'middleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Owners
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Owners
     */
    'ownerName'?: string;
}
/**
 * 
 * @export
 * @interface PBKeyAddressRequest
 */
export interface PBKeyAddressRequest {
    /**
     * 
     * @type {Array<GeocodeAddress>}
     * @memberof PBKeyAddressRequest
     */
    'addresses': Array<GeocodeAddress>;
}
/**
 * 
 * @export
 * @interface PBKeyResponse
 */
export interface PBKeyResponse {
    /**
     * 
     * @type {string}
     * @memberof PBKeyResponse
     */
    'key'?: string;
    /**
     * 
     * @type {Address}
     * @memberof PBKeyResponse
     */
    'matchedAddress'?: Address;
}
/**
 * 
 * @export
 * @interface PBKeyResponseList
 */
export interface PBKeyResponseList {
    /**
     * 
     * @type {Array<Pbkey>}
     * @memberof PBKeyResponseList
     */
    'pbkey'?: Array<Pbkey>;
}
/**
 * 
 * @export
 * @interface POIBoundaryAddressRequest
 */
export interface POIBoundaryAddressRequest {
    /**
     * 
     * @type {Array<ZonesAddress>}
     * @memberof POIBoundaryAddressRequest
     */
    'addresses': Array<ZonesAddress>;
    /**
     * 
     * @type {POIBoundaryPreferences}
     * @memberof POIBoundaryAddressRequest
     */
    'preferences'?: POIBoundaryPreferences;
}
/**
 * 
 * @export
 * @interface POIBoundaryLocationRequest
 */
export interface POIBoundaryLocationRequest {
    /**
     * 
     * @type {Array<POIBoundaryLocations>}
     * @memberof POIBoundaryLocationRequest
     */
    'locations': Array<POIBoundaryLocations>;
    /**
     * 
     * @type {POIBoundaryPreferences}
     * @memberof POIBoundaryLocationRequest
     */
    'preferences'?: POIBoundaryPreferences;
}
/**
 * 
 * @export
 * @interface POIBoundaryLocations
 */
export interface POIBoundaryLocations {
    /**
     * 
     * @type {ZonesGeometry}
     * @memberof POIBoundaryLocations
     */
    'geometry': ZonesGeometry;
    /**
     * 
     * @type {string}
     * @memberof POIBoundaryLocations
     */
    'purchaseAmount'?: string;
    /**
     * 
     * @type {string}
     * @memberof POIBoundaryLocations
     */
    'objectId'?: string;
}
/**
 * 
 * @export
 * @interface POIBoundaryPreferences
 */
export interface POIBoundaryPreferences {
    /**
     * 
     * @type {string}
     * @memberof POIBoundaryPreferences
     */
    'categoryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof POIBoundaryPreferences
     */
    'sicCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof POIBoundaryPreferences
     */
    'naicsCode'?: string;
}
/**
 * 
 * @export
 * @interface POIBoundaryResponse
 */
export interface POIBoundaryResponse {
    /**
     * 
     * @type {Array<PoiBoundary>}
     * @memberof POIBoundaryResponse
     */
    'poiBoundary'?: Array<PoiBoundary>;
}
/**
 * 
 * @export
 * @interface POIByGeometryRequest
 */
export interface POIByGeometryRequest {
    /**
     * 
     * @type {string}
     * @memberof POIByGeometryRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof POIByGeometryRequest
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof POIByGeometryRequest
     */
    'categoryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof POIByGeometryRequest
     */
    'sicCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof POIByGeometryRequest
     */
    'maxCandidates'?: string;
    /**
     * 
     * @type {string}
     * @memberof POIByGeometryRequest
     */
    'fuzzyOnName'?: string;
    /**
     * 
     * @type {string}
     * @memberof POIByGeometryRequest
     */
    'page'?: string;
    /**
     * 
     * @type {string}
     * @memberof POIByGeometryRequest
     */
    'matchMode'?: string;
    /**
     * 
     * @type {string}
     * @memberof POIByGeometryRequest
     */
    'specificMatchOn'?: string;
    /**
     * 
     * @type {Geometry}
     * @memberof POIByGeometryRequest
     */
    'geometry'?: Geometry;
    /**
     * 
     * @type {string}
     * @memberof POIByGeometryRequest
     */
    'geometryAsText'?: string;
}
/**
 * 
 * @export
 * @interface PSAPResponse
 */
export interface PSAPResponse {
    /**
     * 
     * @type {string}
     * @memberof PSAPResponse
     */
    'psapId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PSAPResponse
     */
    'fccId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PSAPResponse
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof PSAPResponse
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PSAPResponse
     */
    'agency'?: string;
    /**
     * 
     * @type {string}
     * @memberof PSAPResponse
     */
    'phone'?: string;
    /**
     * 
     * @type {County}
     * @memberof PSAPResponse
     */
    'county'?: County;
    /**
     * 
     * @type {Coverage}
     * @memberof PSAPResponse
     */
    'coverage'?: Coverage;
    /**
     * 
     * @type {ContactPerson}
     * @memberof PSAPResponse
     */
    'contactPerson'?: ContactPerson;
    /**
     * 
     * @type {SiteDetails}
     * @memberof PSAPResponse
     */
    'siteDetails'?: SiteDetails;
    /**
     * 
     * @type {AHJmailingAddress}
     * @memberof PSAPResponse
     */
    'mailingAddress'?: AHJmailingAddress;
}
/**
 * 
 * @export
 * @interface ParcelBoundaryV2
 */
export interface ParcelBoundaryV2 {
    /**
     * 
     * @type {string}
     * @memberof ParcelBoundaryV2
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParcelBoundaryV2
     */
    'parcelApn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParcelBoundaryV2
     */
    'geoId'?: string;
    /**
     * 
     * @type {Center}
     * @memberof ParcelBoundaryV2
     */
    'center'?: Center;
    /**
     * 
     * @type {string}
     * @memberof ParcelBoundaryV2
     */
    'countyfips'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParcelBoundaryV2
     */
    'parcelAreaSqFt'?: string;
    /**
     * 
     * @type {PropertyInformationGeometry}
     * @memberof ParcelBoundaryV2
     */
    'geometry'?: PropertyInformationGeometry;
    /**
     * 
     * @type {Array<ParcelV2>}
     * @memberof ParcelBoundaryV2
     */
    'parcelList'?: Array<ParcelV2>;
    /**
     * 
     * @type {Array<ParcelBoundaryV2>}
     * @memberof ParcelBoundaryV2
     */
    'adjacentParcelBoundary'?: Array<ParcelBoundaryV2>;
    /**
     * 
     * @type {MatchedAddress}
     * @memberof ParcelBoundaryV2
     */
    'matchedAddress'?: MatchedAddress;
}
/**
 * 
 * @export
 * @interface ParcelV2
 */
export interface ParcelV2 {
    /**
     * 
     * @type {string}
     * @memberof ParcelV2
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParcelV2
     */
    'preciselyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParcelV2
     */
    'parentPreciselyId'?: string;
    /**
     * 
     * @type {MatchedAddress}
     * @memberof ParcelV2
     */
    'address'?: MatchedAddress;
    /**
     * 
     * @type {string}
     * @memberof ParcelV2
     */
    'taxApn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParcelV2
     */
    'taxAccountNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParcelV2
     */
    'propLinkId'?: string;
}
/**
 * 
 * @export
 * @interface ParentBusiness
 */
export interface ParentBusiness {
    /**
     * 
     * @type {string}
     * @memberof ParentBusiness
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParentBusiness
     */
    'name'?: string;
    /**
     * 
     * @type {Address}
     * @memberof ParentBusiness
     */
    'address'?: Address;
}
/**
 * 
 * @export
 * @interface Pbkey
 */
export interface Pbkey {
    /**
     * 
     * @type {string}
     * @memberof Pbkey
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pbkey
     */
    'key'?: string;
    /**
     * 
     * @type {Address}
     * @memberof Pbkey
     */
    'matchedAddress'?: Address;
}
/**
 * 
 * @export
 * @interface PhoneVerification
 */
export interface PhoneVerification {
    /**
     * 
     * @type {Array<PhoneVerificationOutput>}
     * @memberof PhoneVerification
     */
    'Output'?: Array<PhoneVerificationOutput>;
}
/**
 * 
 * @export
 * @interface PhoneVerificationOutput
 */
export interface PhoneVerificationOutput {
    /**
     * 
     * @type {string}
     * @memberof PhoneVerificationOutput
     */
    'MNC'?: string;
    /**
     * 
     * @type {string}
     * @memberof PhoneVerificationOutput
     */
    'MCC'?: string;
    /**
     * 
     * @type {string}
     * @memberof PhoneVerificationOutput
     */
    'CarrierName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PhoneVerificationOutput
     */
    'PhoneType'?: string;
    /**
     * 
     * @type {string}
     * @memberof PhoneVerificationOutput
     */
    'PhoneNumberFormatted'?: string;
    /**
     * 
     * @type {string}
     * @memberof PhoneVerificationOutput
     */
    'CountryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PhoneVerificationOutput
     */
    'PhoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PhoneVerificationOutput
     */
    'ResultCode'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PhoneVerificationOutput
     */
    'user_fields'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Place
 */
export interface Place {
    /**
     * 
     * @type {Array<Name>}
     * @memberof Place
     */
    'name'?: Array<Name>;
    /**
     * 
     * @type {string}
     * @memberof Place
     */
    'levelName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Place
     */
    'level'?: string;
}
/**
 * 
 * @export
 * @interface PlacesResponse
 */
export interface PlacesResponse {
    /**
     * 
     * @type {string}
     * @memberof PlacesResponse
     */
    'page'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlacesResponse
     */
    'candidates'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlacesResponse
     */
    'totalMatchingCandidates'?: string;
    /**
     * 
     * @type {Array<Poi>}
     * @memberof PlacesResponse
     */
    'poi'?: Array<Poi>;
    /**
     * 
     * @type {Address}
     * @memberof PlacesResponse
     */
    'matchedAddress'?: Address;
}
/**
 * 
 * @export
 * @interface Poi
 */
export interface Poi {
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'poiId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'pbkey'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'parentPbkey'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'geocodeConfidence'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'brandName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'tradeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'franchiseName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'open24Hours'?: string;
    /**
     * 
     * @type {Distance}
     * @memberof Poi
     */
    'distance'?: Distance;
    /**
     * 
     * @type {BusinessId}
     * @memberof Poi
     */
    'businessId'?: BusinessId;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'relevanceScore'?: string;
    /**
     * 
     * @type {ContactDetails}
     * @memberof Poi
     */
    'contactDetails'?: ContactDetails;
    /**
     * 
     * @type {PoiClassification}
     * @memberof Poi
     */
    'poiClassification'?: PoiClassification;
    /**
     * 
     * @type {Array<SalesVolume>}
     * @memberof Poi
     */
    'salesVolume'?: Array<SalesVolume>;
    /**
     * 
     * @type {EmployeeCount}
     * @memberof Poi
     */
    'employeeCount'?: EmployeeCount;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'yearStart'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'goodsAgentCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'goodsAgentCodeDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'legalStatusCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'organizationStatusCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'organizationStatusCodeDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'subsidaryIndicator'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'subsidaryIndicatorDescription'?: string;
    /**
     * 
     * @type {ParentBusiness}
     * @memberof Poi
     */
    'parentBusiness'?: ParentBusiness;
    /**
     * 
     * @type {DomesticUltimateBusiness}
     * @memberof Poi
     */
    'domesticUltimateBusiness'?: DomesticUltimateBusiness;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'globalUltimateIndicator'?: string;
    /**
     * 
     * @type {GlobalUltimateBusiness}
     * @memberof Poi
     */
    'globalUltimateBusiness'?: GlobalUltimateBusiness;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'familyMembers'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'hierarchyCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'tickerSymbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'exchangeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'ceoName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Poi
     */
    'ceoTitle'?: string;
    /**
     * 
     * @type {Geometry}
     * @memberof Poi
     */
    'geometry'?: Geometry;
}
/**
 * 
 * @export
 * @interface PoiBoundary
 */
export interface PoiBoundary {
    /**
     * 
     * @type {string}
     * @memberof PoiBoundary
     */
    'objectId'?: string;
    /**
     * 
     * @type {Center}
     * @memberof PoiBoundary
     */
    'center'?: Center;
    /**
     * 
     * @type {string}
     * @memberof PoiBoundary
     */
    'countyfips'?: string;
    /**
     * 
     * @type {ZonesPoiGeometry}
     * @memberof PoiBoundary
     */
    'geometry'?: ZonesPoiGeometry;
    /**
     * 
     * @type {Array<ZonesPoi>}
     * @memberof PoiBoundary
     */
    'poiList'?: Array<ZonesPoi>;
    /**
     * 
     * @type {ZonesAddress}
     * @memberof PoiBoundary
     */
    'matchedAddress'?: ZonesAddress;
    /**
     * 
     * @type {string}
     * @memberof PoiBoundary
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface PoiClassification
 */
export interface PoiClassification {
    /**
     * 
     * @type {Sic}
     * @memberof PoiClassification
     */
    'sic'?: Sic;
    /**
     * 
     * @type {Category}
     * @memberof PoiClassification
     */
    'category'?: Category;
    /**
     * 
     * @type {string}
     * @memberof PoiClassification
     */
    'alternateIndustryCode'?: string;
}
/**
 * 
 * @export
 * @interface PoiCount
 */
export interface PoiCount {
    /**
     * 
     * @type {number}
     * @memberof PoiCount
     */
    'totalPoisFound'?: number;
}
/**
 * 
 * @export
 * @interface PoiCountRequest
 */
export interface PoiCountRequest {
    /**
     * 
     * @type {string}
     * @memberof PoiCountRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PoiCountRequest
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof PoiCountRequest
     */
    'categoryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PoiCountRequest
     */
    'sicCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PoiCountRequest
     */
    'fuzzyOnName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PoiCountRequest
     */
    'matchMode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PoiCountRequest
     */
    'specificMatchOn'?: string;
    /**
     * 
     * @type {Geometry}
     * @memberof PoiCountRequest
     */
    'geometry'?: Geometry;
    /**
     * 
     * @type {string}
     * @memberof PoiCountRequest
     */
    'geometryAsText'?: string;
}
/**
 * 
 * @export
 * @interface Points
 */
export interface Points {
    /**
     * 
     * @type {string}
     * @memberof Points
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Points
     */
    'country': string;
    /**
     * 
     * @type {GeoPos}
     * @memberof Points
     */
    'geometry': GeoPos;
}
/**
 * 
 * @export
 * @interface PoolType
 */
export interface PoolType {
    /**
     * 
     * @type {string}
     * @memberof PoolType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PoolType
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface PopulationTheme
 */
export interface PopulationTheme {
    /**
     * 
     * @type {string}
     * @memberof PopulationTheme
     */
    'boundaryRef'?: string;
    /**
     * 
     * @type {Array<IndividualValueVariable>}
     * @memberof PopulationTheme
     */
    'individualValueVariable'?: Array<IndividualValueVariable>;
    /**
     * 
     * @type {Array<RangeVariable>}
     * @memberof PopulationTheme
     */
    'rangeVariable'?: Array<RangeVariable>;
}
/**
 * 
 * @export
 * @interface PreferencTimeZone
 */
export interface PreferencTimeZone {
    /**
     * 
     * @type {string}
     * @memberof PreferencTimeZone
     */
    'matchMode'?: string;
}
/**
 * 
 * @export
 * @interface PrimaryZone
 */
export interface PrimaryZone {
    /**
     * 
     * @type {string}
     * @memberof PrimaryZone
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrimaryZone
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface PriorSaleCode
 */
export interface PriorSaleCode {
    /**
     * 
     * @type {string}
     * @memberof PriorSaleCode
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PriorSaleCode
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface PropSiteInfluene
 */
export interface PropSiteInfluene {
    /**
     * 
     * @type {string}
     * @memberof PropSiteInfluene
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropSiteInfluene
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface Properties
 */
export interface Properties {
    /**
     * 
     * @type {string}
     * @memberof Properties
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface PropertyAttributes
 */
export interface PropertyAttributes {
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'pbKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'propApn'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'propType'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'propSqFt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'buildgSqFt'?: string;
    /**
     * 
     * @type {BuildingSqftSource}
     * @memberof PropertyAttributes
     */
    'buildgSqFtSource'?: BuildingSqftSource;
    /**
     * 
     * @type {LandUse}
     * @memberof PropertyAttributes
     */
    'landUse'?: LandUse;
    /**
     * 
     * @type {Construction}
     * @memberof PropertyAttributes
     */
    'construction'?: Construction;
    /**
     * 
     * @type {RoofCoverType}
     * @memberof PropertyAttributes
     */
    'roofCoverType'?: RoofCoverType;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'subdivision'?: string;
    /**
     * 
     * @type {PropertyGeometry}
     * @memberof PropertyAttributes
     */
    'geometry'?: PropertyGeometry;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'builtYear'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'bedrooms'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'baths'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'partialBaths'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'bathFixtures'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'pool'?: string;
    /**
     * 
     * @type {PoolType}
     * @memberof PropertyAttributes
     */
    'poolType'?: PoolType;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'fireplace'?: string;
    /**
     * 
     * @type {FireplaceType}
     * @memberof PropertyAttributes
     */
    'fireplaceType'?: FireplaceType;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'mobileHome'?: string;
    /**
     * 
     * @type {HeatingType}
     * @memberof PropertyAttributes
     */
    'heatingType'?: HeatingType;
    /**
     * 
     * @type {CoolingType}
     * @memberof PropertyAttributes
     */
    'coolingType'?: CoolingType;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'assessedValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'marketValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'appraisedValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'taxAmount'?: string;
    /**
     * 
     * @type {Array<TaxExemption>}
     * @memberof PropertyAttributes
     */
    'taxExemptions'?: Array<TaxExemption>;
    /**
     * 
     * @type {CaExemptions}
     * @memberof PropertyAttributes
     */
    'caExemptions'?: CaExemptions;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'salesDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'priorSaleDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'priorSalesPrice'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'priorSaleDocType'?: string;
    /**
     * 
     * @type {PriorSaleCode}
     * @memberof PropertyAttributes
     */
    'priorSaleCode'?: PriorSaleCode;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'priorSaleFolioNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'priorSalePageNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'priorSaleDocNumber'?: string;
    /**
     * 
     * @type {Stories}
     * @memberof PropertyAttributes
     */
    'stories'?: Stories;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'livingSqFt'?: string;
    /**
     * 
     * @type {RoofFrameType}
     * @memberof PropertyAttributes
     */
    'roofFrameType'?: RoofFrameType;
    /**
     * 
     * @type {Foundation}
     * @memberof PropertyAttributes
     */
    'foundation'?: Foundation;
    /**
     * 
     * @type {BuildgCondition}
     * @memberof PropertyAttributes
     */
    'buildgCondition'?: BuildgCondition;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'buildgCount'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'buildgUnitNo'?: string;
    /**
     * 
     * @type {Array<BuildgFeaturesSqft>}
     * @memberof PropertyAttributes
     */
    'buildgFeaturesSqFt'?: Array<BuildgFeaturesSqft>;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'taxAddress'?: string;
    /**
     * 
     * @type {FormattedTaxAddress}
     * @memberof PropertyAttributes
     */
    'formattedTaxAddress'?: FormattedTaxAddress;
    /**
     * 
     * @type {SitusAddress}
     * @memberof PropertyAttributes
     */
    'situsAddress'?: SitusAddress;
    /**
     * 
     * @type {Vacancy}
     * @memberof PropertyAttributes
     */
    'vacancy'?: Vacancy;
    /**
     * 
     * @type {Array<Owners>}
     * @memberof PropertyAttributes
     */
    'owners'?: Array<Owners>;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'appraisedValueImp'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'assessedValueImp'?: string;
    /**
     * 
     * @type {BuildgType}
     * @memberof PropertyAttributes
     */
    'buildgType'?: BuildgType;
    /**
     * 
     * @type {BasementType}
     * @memberof PropertyAttributes
     */
    'basementType'?: BasementType;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'effectiveBuiltYear'?: string;
    /**
     * 
     * @type {ExteriorWalls}
     * @memberof PropertyAttributes
     */
    'exteriorWalls'?: ExteriorWalls;
    /**
     * 
     * @type {GarageType}
     * @memberof PropertyAttributes
     */
    'garageType'?: GarageType;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'lastUpdated'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'marketValueImp'?: string;
    /**
     * 
     * @type {AbsenteeOwner}
     * @memberof PropertyAttributes
     */
    'absenteeOwner'?: AbsenteeOwner;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'parkingSqFt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'replacementCost'?: string;
    /**
     * 
     * @type {RoofShapeType}
     * @memberof PropertyAttributes
     */
    'roofShapeType'?: RoofShapeType;
    /**
     * 
     * @type {BuildgStyle}
     * @memberof PropertyAttributes
     */
    'buildgStyle'?: BuildgStyle;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'basementSqFt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'ownerType'?: string;
    /**
     * 
     * @type {OwnerVestType}
     * @memberof PropertyAttributes
     */
    'ownerVestType'?: OwnerVestType;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'elevator'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'propApnSequence'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'fipsCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'propZoning'?: string;
    /**
     * 
     * @type {LocCode}
     * @memberof PropertyAttributes
     */
    'locCode'?: LocCode;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'legalMapRef'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'legalAssessorDesc'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'legalFullDesc'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'legalLotCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'legalLotNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'legalLandLot'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'legalTractNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'legalBlock'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'legalSection'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'legalDistrict'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'legalUnitNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'legalPhaseNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'legalSubName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'legalTownMuniName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'legalSectionTownshipRange'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'propAcres'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'propFrontFootage'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'propDepthFootage'?: string;
    /**
     * 
     * @type {BuildgView}
     * @memberof PropertyAttributes
     */
    'buildgView'?: BuildgView;
    /**
     * 
     * @type {PropSiteInfluene}
     * @memberof PropertyAttributes
     */
    'propSiteInfluene'?: PropSiteInfluene;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'buildgName'?: string;
    /**
     * 
     * @type {BuildgQuality}
     * @memberof PropertyAttributes
     */
    'buildgQuality'?: BuildgQuality;
    /**
     * 
     * @type {BuildgImproveType}
     * @memberof PropertyAttributes
     */
    'buildgImproveType'?: BuildgImproveType;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'grossSqft'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'adjGrossSqft'?: string;
    /**
     * 
     * @type {BuildgClass}
     * @memberof PropertyAttributes
     */
    'buildgClass'?: BuildgClass;
    /**
     * 
     * @type {InteriorWall}
     * @memberof PropertyAttributes
     */
    'interiorWall'?: InteriorWall;
    /**
     * 
     * @type {FloorType}
     * @memberof PropertyAttributes
     */
    'floorType'?: FloorType;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'rooms'?: string;
    /**
     * 
     * @type {OtherRooms}
     * @memberof PropertyAttributes
     */
    'otherRooms'?: OtherRooms;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'plumbingFixtures'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'parkingCapacity'?: string;
    /**
     * 
     * @type {EnergyType}
     * @memberof PropertyAttributes
     */
    'energyType'?: EnergyType;
    /**
     * 
     * @type {FuelType}
     * @memberof PropertyAttributes
     */
    'fuelType'?: FuelType;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'sewerType'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'waterType'?: string;
    /**
     * 
     * @type {Amenities}
     * @memberof PropertyAttributes
     */
    'amenities'?: Amenities;
    /**
     * 
     * @type {Array<ExtraFeatureSqft>}
     * @memberof PropertyAttributes
     */
    'extraFeatureSqft'?: Array<ExtraFeatureSqft>;
    /**
     * 
     * @type {Array<BuildgImproveArea>}
     * @memberof PropertyAttributes
     */
    'buildgImproveArea'?: Array<BuildgImproveArea>;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'taxAccountNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'taxTapeCutDate'?: string;
    /**
     * 
     * @type {TaxDocType}
     * @memberof PropertyAttributes
     */
    'taxDocType'?: TaxDocType;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'taxSalesPrice'?: string;
    /**
     * 
     * @type {TaxSalesPriceCode}
     * @memberof PropertyAttributes
     */
    'taxSalesPriceCode'?: TaxSalesPriceCode;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'recBookNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'recPageNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'recDocNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'taxYear'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'taxDelYear'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'assessedYear'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'assessedLandValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'marketValueYear'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'marketValueLand'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'appraisedValueLand'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'taxRateCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'propLinkId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyAttributes
     */
    'geoId'?: string;
}
/**
 * 
 * @export
 * @interface PropertyGeometry
 */
export interface PropertyGeometry {
    /**
     * 
     * @type {string}
     * @memberof PropertyGeometry
     */
    'type': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof PropertyGeometry
     */
    'coordinates'?: Array<number>;
}
/**
 * 
 * @export
 * @interface PropertyInfoAddressRequest
 */
export interface PropertyInfoAddressRequest {
    /**
     * 
     * @type {PropertyInfoPreferences}
     * @memberof PropertyInfoAddressRequest
     */
    'preferences': PropertyInfoPreferences;
    /**
     * 
     * @type {Array<MatchedAddress>}
     * @memberof PropertyInfoAddressRequest
     */
    'addresses': Array<MatchedAddress>;
}
/**
 * 
 * @export
 * @interface PropertyInfoPreferences
 */
export interface PropertyInfoPreferences {
    /**
     * 
     * @type {string}
     * @memberof PropertyInfoPreferences
     */
    'attributes'?: string;
}
/**
 * 
 * @export
 * @interface PropertyInfoResponse
 */
export interface PropertyInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof PropertyInfoResponse
     */
    'objectId'?: string;
    /**
     * 
     * @type {PropertyAttributes}
     * @memberof PropertyInfoResponse
     */
    'propertyAttributes'?: PropertyAttributes;
    /**
     * 
     * @type {MatchedAddress}
     * @memberof PropertyInfoResponse
     */
    'matchedAddress'?: MatchedAddress;
}
/**
 * 
 * @export
 * @interface PropertyInfoResponses
 */
export interface PropertyInfoResponses {
    /**
     * 
     * @type {Array<PropertyInfoResponse>}
     * @memberof PropertyInfoResponses
     */
    'propertyInfoResponses'?: Array<PropertyInfoResponse>;
}
/**
 * 
 * @export
 * @interface PropertyInformationGeometry
 */
export interface PropertyInformationGeometry {
    /**
     * 
     * @type {string}
     * @memberof PropertyInformationGeometry
     */
    'type'?: string;
    /**
     * 
     * @type {PropertyInformationGeometryCRC}
     * @memberof PropertyInformationGeometry
     */
    'crs'?: PropertyInformationGeometryCRC;
    /**
     * 
     * @type {object}
     * @memberof PropertyInformationGeometry
     */
    'coordinates'?: object;
}
/**
 * 
 * @export
 * @interface PropertyInformationGeometryCRC
 */
export interface PropertyInformationGeometryCRC {
    /**
     * 
     * @type {string}
     * @memberof PropertyInformationGeometryCRC
     */
    'type'?: string;
    /**
     * 
     * @type {GeometryProperties}
     * @memberof PropertyInformationGeometryCRC
     */
    'properties'?: GeometryProperties;
}
/**
 * 
 * @export
 * @interface Proxy
 */
export interface Proxy {
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'anonymizerStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'level'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'lastDetected'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface RaceAndEthnicityTheme
 */
export interface RaceAndEthnicityTheme {
    /**
     * 
     * @type {string}
     * @memberof RaceAndEthnicityTheme
     */
    'boundaryRef'?: string;
    /**
     * 
     * @type {Array<IndividualValueVariable>}
     * @memberof RaceAndEthnicityTheme
     */
    'individualValueVariable'?: Array<IndividualValueVariable>;
    /**
     * 
     * @type {Array<RangeVariable>}
     * @memberof RaceAndEthnicityTheme
     */
    'rangeVariable'?: Array<RangeVariable>;
}
/**
 * 
 * @export
 * @interface RangeVariable
 */
export interface RangeVariable {
    /**
     * 
     * @type {string}
     * @memberof RangeVariable
     */
    'count'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangeVariable
     */
    'order'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangeVariable
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangeVariable
     */
    'alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangeVariable
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangeVariable
     */
    'baseVariable'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangeVariable
     */
    'year'?: string;
    /**
     * 
     * @type {Array<Field>}
     * @memberof RangeVariable
     */
    'field': Array<Field>;
}
/**
 * 
 * @export
 * @interface Rate
 */
export interface Rate {
    /**
     * 
     * @type {string}
     * @memberof Rate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Rate
     */
    'format'?: string;
    /**
     * 
     * @type {string}
     * @memberof Rate
     */
    'formatDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof Rate
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface RateCenterResponse
 */
export interface RateCenterResponse {
    /**
     * 
     * @type {string}
     * @memberof RateCenterResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RateCenterResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RateCenterResponse
     */
    'alternateName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RateCenterResponse
     */
    'areaName1'?: string;
    /**
     * 
     * @type {Geometry}
     * @memberof RateCenterResponse
     */
    'geometry'?: Geometry;
    /**
     * 
     * @type {Array<AreaCodeInfo>}
     * @memberof RateCenterResponse
     */
    'areaCodeInfoList'?: Array<AreaCodeInfo>;
    /**
     * 
     * @type {Address}
     * @memberof RateCenterResponse
     */
    'matchedAddress'?: Address;
    /**
     * 
     * @type {Match}
     * @memberof RateCenterResponse
     */
    'match'?: Match;
    /**
     * 
     * @type {County}
     * @memberof RateCenterResponse
     */
    'county'?: County;
    /**
     * 
     * @type {number}
     * @memberof RateCenterResponse
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof RateCenterResponse
     */
    'product_code'?: string;
}
/**
 * 
 * @export
 * @interface ReturnFieldsDescriptor
 */
export interface ReturnFieldsDescriptor {
    /**
     * 
     * @type {boolean}
     * @memberof ReturnFieldsDescriptor
     */
    'returnAllCustomFields'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ReturnFieldsDescriptor
     */
    'returnMatchDescriptor'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ReturnFieldsDescriptor
     */
    'returnStreetAddressFields'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ReturnFieldsDescriptor
     */
    'returnUnitInformation'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ReturnFieldsDescriptor
     */
    'returnedCustomFieldKeys'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ReverseGeocodeRequest
 */
export interface ReverseGeocodeRequest {
    /**
     * 
     * @type {GeocodePreferences}
     * @memberof ReverseGeocodeRequest
     */
    'preferences'?: GeocodePreferences;
    /**
     * 
     * @type {Array<Points>}
     * @memberof ReverseGeocodeRequest
     */
    'points': Array<Points>;
}
/**
 * 
 * @export
 * @interface Risk
 */
export interface Risk {
    /**
     * 
     * @type {string}
     * @memberof Risk
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Risk
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Risk
     */
    'risk50Rating'?: number;
    /**
     * 
     * @type {number}
     * @memberof Risk
     */
    'frequency'?: number;
    /**
     * 
     * @type {string}
     * @memberof Risk
     */
    'nonburn'?: string;
    /**
     * 
     * @type {number}
     * @memberof Risk
     */
    'pastFires'?: number;
    /**
     * 
     * @type {number}
     * @memberof Risk
     */
    'severity'?: number;
    /**
     * 
     * @type {string}
     * @memberof Risk
     */
    'continuity'?: string;
    /**
     * 
     * @type {string}
     * @memberof Risk
     */
    'adjustment'?: string;
    /**
     * 
     * @type {string}
     * @memberof Risk
     */
    'aspect'?: string;
    /**
     * 
     * @type {string}
     * @memberof Risk
     */
    'crownFire'?: string;
    /**
     * 
     * @type {string}
     * @memberof Risk
     */
    'vegetation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Risk
     */
    'foehn'?: string;
    /**
     * 
     * @type {string}
     * @memberof Risk
     */
    'golfCourse'?: string;
    /**
     * 
     * @type {string}
     * @memberof Risk
     */
    'roadDist'?: string;
    /**
     * 
     * @type {string}
     * @memberof Risk
     */
    'slope'?: string;
    /**
     * 
     * @type {string}
     * @memberof Risk
     */
    'waterDist'?: string;
    /**
     * 
     * @type {string}
     * @memberof Risk
     */
    'tier'?: string;
    /**
     * 
     * @type {string}
     * @memberof Risk
     */
    'tierDescription'?: string;
    /**
     * 
     * @type {number}
     * @memberof Risk
     */
    'distanceToFireStation'?: number;
}
/**
 * 
 * @export
 * @interface RiskAddress
 */
export interface RiskAddress {
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'streetSide'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'businessName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'addressLine1'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'addressLine2'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'addressLine3'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'stateProvince'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'county'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'latitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'longitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'urbanizationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'formattedAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'mainAddressLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'addressLastLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'placeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'areaName1'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'areaName2'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'areaName3'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'areaName4'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'postCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'postCodeExt'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'addressNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'streetName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'unitType'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAddress
     */
    'unitValue'?: string;
}
/**
 * 
 * @export
 * @interface RiskGeometry
 */
export interface RiskGeometry {
    /**
     * 
     * @type {string}
     * @memberof RiskGeometry
     */
    'type': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof RiskGeometry
     */
    'coordinates'?: Array<number>;
}
/**
 * 
 * @export
 * @interface RiskLocations
 */
export interface RiskLocations {
    /**
     * 
     * @type {RiskGeometry}
     * @memberof RiskLocations
     */
    'geometry': RiskGeometry;
    /**
     * 
     * @type {string}
     * @memberof RiskLocations
     */
    'purchaseAmount'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskLocations
     */
    'objectId'?: string;
}
/**
 * 
 * @export
 * @interface RiskPreferences
 */
export interface RiskPreferences {
    /**
     * 
     * @type {string}
     * @memberof RiskPreferences
     */
    'includeGeometry'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskPreferences
     */
    'includeZoneDesc'?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskPreferences
     */
    'richterValue'?: string;
}
/**
 * 
 * @export
 * @interface RisksBoundaries
 */
export interface RisksBoundaries {
    /**
     * 
     * @type {Array<CrimeBoundary>}
     * @memberof RisksBoundaries
     */
    'boundary'?: Array<CrimeBoundary>;
}
/**
 * 
 * @export
 * @interface RisksCrimeTheme
 */
export interface RisksCrimeTheme {
    /**
     * 
     * @type {CrimeIndexTheme}
     * @memberof RisksCrimeTheme
     */
    'crimeIndexTheme'?: CrimeIndexTheme;
}
/**
 * 
 * @export
 * @interface RisksGeometryCRC
 */
export interface RisksGeometryCRC {
    /**
     * 
     * @type {string}
     * @memberof RisksGeometryCRC
     */
    'type'?: string;
    /**
     * 
     * @type {GeometryProperties}
     * @memberof RisksGeometryCRC
     */
    'properties'?: GeometryProperties;
}
/**
 * 
 * @export
 * @interface Road
 */
export interface Road {
    /**
     * 
     * @type {string}
     * @memberof Road
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Road
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Road
     */
    'altName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Road
     */
    'roadClass'?: string;
    /**
     * 
     * @type {string}
     * @memberof Road
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Road
     */
    'lengthInMeters'?: string;
    /**
     * 
     * @type {string}
     * @memberof Road
     */
    'routeNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Road
     */
    'surfaceType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Road
     */
    'trafficFlow'?: string;
    /**
     * 
     * @type {string}
     * @memberof Road
     */
    'isToll'?: string;
    /**
     * 
     * @type {string}
     * @memberof Road
     */
    'beginningLevel'?: string;
    /**
     * 
     * @type {string}
     * @memberof Road
     */
    'endingLevel'?: string;
}
/**
 * 
 * @export
 * @interface RoofCoverType
 */
export interface RoofCoverType {
    /**
     * 
     * @type {string}
     * @memberof RoofCoverType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoofCoverType
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface RoofFrameType
 */
export interface RoofFrameType {
    /**
     * 
     * @type {string}
     * @memberof RoofFrameType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoofFrameType
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface RoofShapeType
 */
export interface RoofShapeType {
    /**
     * 
     * @type {string}
     * @memberof RoofShapeType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoofShapeType
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface RouteDirection
 */
export interface RouteDirection {
    /**
     * 
     * @type {number}
     * @memberof RouteDirection
     */
    'distance'?: number;
    /**
     * 
     * @type {string}
     * @memberof RouteDirection
     */
    'distanceUnit'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteDirection
     */
    'timeUnit'?: string;
    /**
     * 
     * @type {number}
     * @memberof RouteDirection
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof RouteDirection
     */
    'instruction'?: string;
    /**
     * 
     * @type {RouteGeometry}
     * @memberof RouteDirection
     */
    'directionGeometry'?: RouteGeometry;
}
/**
 * 
 * @export
 * @interface RouteGeometry
 */
export interface RouteGeometry {
    /**
     * 
     * @type {string}
     * @memberof RouteGeometry
     */
    'type'?: string;
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof RouteGeometry
     */
    'coordinates'?: Array<Array<number>>;
}
/**
 * 
 * @export
 * @interface RouteResponse
 */
export interface RouteResponse {
    /**
     * 
     * @type {string}
     * @memberof RouteResponse
     */
    'directionsStyle'?: string;
    /**
     * 
     * @type {number}
     * @memberof RouteResponse
     */
    'distance'?: number;
    /**
     * 
     * @type {string}
     * @memberof RouteResponse
     */
    'distanceUnit'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteResponse
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteResponse
     */
    'timeUnit'?: string;
    /**
     * 
     * @type {number}
     * @memberof RouteResponse
     */
    'time'?: number;
    /**
     * 
     * @type {RouteGeometry}
     * @memberof RouteResponse
     */
    'geometry'?: RouteGeometry;
    /**
     * 
     * @type {Array<RouteDirection>}
     * @memberof RouteResponse
     */
    'routeDirections'?: Array<RouteDirection>;
    /**
     * 
     * @type {IntermediatePoints}
     * @memberof RouteResponse
     */
    'intermediatePoints'?: IntermediatePoints;
}
/**
 * 
 * @export
 * @interface SalesTax
 */
export interface SalesTax {
    /**
     * 
     * @type {boolean}
     * @memberof SalesTax
     */
    'specialTaxRulesApplied'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SalesTax
     */
    'specialTaxRulesDescriptor'?: string;
    /**
     * 
     * @type {number}
     * @memberof SalesTax
     */
    'totalTaxRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof SalesTax
     */
    'totalTaxAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SalesTax
     */
    'stateTaxRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof SalesTax
     */
    'stateTaxAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SalesTax
     */
    'countyTaxRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof SalesTax
     */
    'countyTaxAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SalesTax
     */
    'municipalTaxRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof SalesTax
     */
    'municipalTaxAmount'?: number;
    /**
     * 
     * @type {Array<SpecialPurposeDistrictTax>}
     * @memberof SalesTax
     */
    'spdsTax'?: Array<SpecialPurposeDistrictTax>;
}
/**
 * 
 * @export
 * @interface SalesVolume
 */
export interface SalesVolume {
    /**
     * 
     * @type {string}
     * @memberof SalesVolume
     */
    'currencyCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof SalesVolume
     */
    'worldBaseCurrencyCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof SalesVolume
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface School
 */
export interface School {
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'assigned'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'website'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'addressType'?: string;
    /**
     * 
     * @type {Address}
     * @memberof School
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'lowestGrade'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'highestGrade'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'schoolType'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'schoolTypeDesc'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'schoolSubType'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'schoolSubTypeDesc'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'genderDesc'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'educationLevel'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'educationLevelDesc'?: string;
    /**
     * 
     * @type {Greatschools}
     * @memberof School
     */
    'greatschools'?: Greatschools;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'ncesSchoolId'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'ncesDistrictId'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'ncesDataYear'?: string;
    /**
     * 
     * @type {Array<SchoolRanking>}
     * @memberof School
     */
    'schoolRanking'?: Array<SchoolRanking>;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'students'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'teachers'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'studentTeacherRatio'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'choice'?: string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'coextensiv'?: string;
    /**
     * 
     * @type {SchoolDistrict}
     * @memberof School
     */
    'schoolDistricts'?: SchoolDistrict;
    /**
     * 
     * @type {SchoolProfile}
     * @memberof School
     */
    'schoolProfile'?: SchoolProfile;
    /**
     * 
     * @type {GradeLevelsTaught}
     * @memberof School
     */
    'gradeLevelsTaught'?: GradeLevelsTaught;
    /**
     * 
     * @type {Distance}
     * @memberof School
     */
    'distance'?: Distance;
    /**
     * 
     * @type {Geometry}
     * @memberof School
     */
    'geometry'?: Geometry;
}
/**
 * 
 * @export
 * @interface SchoolDistrict
 */
export interface SchoolDistrict {
    /**
     * 
     * @type {string}
     * @memberof SchoolDistrict
     */
    'ncesDistrictId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolDistrict
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolDistrict
     */
    'totalSchools'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolDistrict
     */
    'districtType'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolDistrict
     */
    'metro'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolDistrict
     */
    'areaInSqM'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolDistrict
     */
    'supervisoryUnionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolDistrict
     */
    'districtEnrollment'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolDistrict
     */
    'districtUrl'?: string;
}
/**
 * 
 * @export
 * @interface SchoolProfile
 */
export interface SchoolProfile {
    /**
     * 
     * @type {string}
     * @memberof SchoolProfile
     */
    'blueRibbon'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolProfile
     */
    'internationalBaccalaureate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolProfile
     */
    'titleI'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolProfile
     */
    'expensePerStudent'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolProfile
     */
    'studentBelowPovertyPct'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolProfile
     */
    'advancePlacementClasses'?: string;
    /**
     * 
     * @type {FreeOrReducedPriceLunches}
     * @memberof SchoolProfile
     */
    'freeOrReducedPriceLunches'?: FreeOrReducedPriceLunches;
    /**
     * 
     * @type {StudentEthnicity}
     * @memberof SchoolProfile
     */
    'studentEthnicity'?: StudentEthnicity;
}
/**
 * 
 * @export
 * @interface SchoolRanking
 */
export interface SchoolRanking {
    /**
     * 
     * @type {string}
     * @memberof SchoolRanking
     */
    'current'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolRanking
     */
    'rankYear'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolRanking
     */
    'stateRank'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolRanking
     */
    'numberOfSchools'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolRanking
     */
    'avgMathScore'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolRanking
     */
    'avgReadingScore'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolRanking
     */
    'statePercentileScore'?: string;
}
/**
 * 
 * @export
 * @interface SchoolsNearByResponse
 */
export interface SchoolsNearByResponse {
    /**
     * 
     * @type {Address}
     * @memberof SchoolsNearByResponse
     */
    'matchedAddress'?: Address;
    /**
     * 
     * @type {Array<School>}
     * @memberof SchoolsNearByResponse
     */
    'school'?: Array<School>;
    /**
     * 
     * @type {SchoolDistrict}
     * @memberof SchoolsNearByResponse
     */
    'schoolDistrict'?: SchoolDistrict;
}
/**
 * 
 * @export
 * @interface Segmentation
 */
export interface Segmentation {
    /**
     * 
     * @type {Boundaries}
     * @memberof Segmentation
     */
    'boundaries': Boundaries;
    /**
     * 
     * @type {SegmentationThemes}
     * @memberof Segmentation
     */
    'themes': SegmentationThemes;
}
/**
 * 
 * @export
 * @interface SegmentationThemes
 */
export interface SegmentationThemes {
    /**
     * 
     * @type {LifeStyleTheme}
     * @memberof SegmentationThemes
     */
    'lifeStyleTheme'?: LifeStyleTheme;
}
/**
 * 
 * @export
 * @interface ShoreLineDistance
 */
export interface ShoreLineDistance {
    /**
     * 
     * @type {string}
     * @memberof ShoreLineDistance
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoreLineDistance
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface Sic
 */
export interface Sic {
    /**
     * 
     * @type {string}
     * @memberof Sic
     */
    'businessLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sic
     */
    'sicCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sic
     */
    'sicCodeDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sic
     */
    'primarySicCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sic
     */
    'secondarySicCode'?: string;
}
/**
 * 
 * @export
 * @interface SicMetadata
 */
export interface SicMetadata {
    /**
     * 
     * @type {string}
     * @memberof SicMetadata
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof SicMetadata
     */
    'categoryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof SicMetadata
     */
    'tradeDivision'?: string;
    /**
     * 
     * @type {string}
     * @memberof SicMetadata
     */
    'tradeGroup'?: string;
    /**
     * 
     * @type {string}
     * @memberof SicMetadata
     */
    'class'?: string;
    /**
     * 
     * @type {string}
     * @memberof SicMetadata
     */
    'subClass'?: string;
    /**
     * 
     * @type {string}
     * @memberof SicMetadata
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface SiteDetails
 */
export interface SiteDetails {
    /**
     * 
     * @type {string}
     * @memberof SiteDetails
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteDetails
     */
    'fax'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteDetails
     */
    'contactName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteDetails
     */
    'email'?: string;
    /**
     * 
     * @type {AHJmailingAddress}
     * @memberof SiteDetails
     */
    'address'?: AHJmailingAddress;
}
/**
 * 
 * @export
 * @interface SitusAddress
 */
export interface SitusAddress {
    /**
     * 
     * @type {string}
     * @memberof SitusAddress
     */
    'mainAddressLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof SitusAddress
     */
    'addressNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SitusAddress
     */
    'streetPreDirection'?: string;
    /**
     * 
     * @type {string}
     * @memberof SitusAddress
     */
    'streetName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SitusAddress
     */
    'streetType'?: string;
    /**
     * 
     * @type {string}
     * @memberof SitusAddress
     */
    'streetPostDirection'?: string;
    /**
     * 
     * @type {string}
     * @memberof SitusAddress
     */
    'unitType'?: string;
    /**
     * 
     * @type {string}
     * @memberof SitusAddress
     */
    'unitValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof SitusAddress
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof SitusAddress
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof SitusAddress
     */
    'postCode1'?: string;
    /**
     * 
     * @type {string}
     * @memberof SitusAddress
     */
    'postCode2'?: string;
}
/**
 * 
 * @export
 * @interface SpecialPurposeDistrict
 */
export interface SpecialPurposeDistrict {
    /**
     * 
     * @type {string}
     * @memberof SpecialPurposeDistrict
     */
    'districtName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecialPurposeDistrict
     */
    'districtCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecialPurposeDistrict
     */
    'districtNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecialPurposeDistrict
     */
    'versionDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecialPurposeDistrict
     */
    'effectiveDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecialPurposeDistrict
     */
    'compiledDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecialPurposeDistrict
     */
    'updateDate'?: string;
}
/**
 * 
 * @export
 * @interface SpecialPurposeDistrictTax
 */
export interface SpecialPurposeDistrictTax {
    /**
     * 
     * @type {string}
     * @memberof SpecialPurposeDistrictTax
     */
    'districtNumber'?: string;
    /**
     * 
     * @type {number}
     * @memberof SpecialPurposeDistrictTax
     */
    'taxRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof SpecialPurposeDistrictTax
     */
    'taxAmount'?: number;
}
/**
 * 
 * @export
 * @interface SpeedLimit
 */
export interface SpeedLimit {
    /**
     * 
     * @type {string}
     * @memberof SpeedLimit
     */
    'maxSpeed'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpeedLimit
     */
    'speedUnit'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpeedLimit
     */
    'speedVerification'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpeedLimit
     */
    'amPeakAvgSpeed'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpeedLimit
     */
    'pmPeakAvgSpeed'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpeedLimit
     */
    'offPeakAvgSpeed'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpeedLimit
     */
    'nightAvgSpeed'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpeedLimit
     */
    'weekAvgSpeed'?: string;
    /**
     * 
     * @type {Road}
     * @memberof SpeedLimit
     */
    'road'?: Road;
}
/**
 * 
 * @export
 * @interface StartEndPoint
 */
export interface StartEndPoint {
    /**
     * 
     * @type {string}
     * @memberof StartEndPoint
     */
    'type'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof StartEndPoint
     */
    'coordinates'?: Array<number>;
}
/**
 * 
 * @export
 * @interface State
 */
export interface State {
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'fips'?: string;
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface Stories
 */
export interface Stories {
    /**
     * 
     * @type {string}
     * @memberof Stories
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof Stories
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface StudentEthnicity
 */
export interface StudentEthnicity {
    /**
     * 
     * @type {string}
     * @memberof StudentEthnicity
     */
    'indianAlaskaNative'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentEthnicity
     */
    'asian'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentEthnicity
     */
    'hispanic'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentEthnicity
     */
    'black'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentEthnicity
     */
    'white'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentEthnicity
     */
    'hawaiianPacificlslander'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentEthnicity
     */
    'twoOrMoreRaces'?: string;
}
/**
 * 
 * @export
 * @interface SupplyAndDemandTheme
 */
export interface SupplyAndDemandTheme {
    /**
     * 
     * @type {string}
     * @memberof SupplyAndDemandTheme
     */
    'boundaryRef'?: string;
    /**
     * 
     * @type {Array<IndividualValueVariable>}
     * @memberof SupplyAndDemandTheme
     */
    'individualValueVariable'?: Array<IndividualValueVariable>;
    /**
     * 
     * @type {Array<RangeVariable>}
     * @memberof SupplyAndDemandTheme
     */
    'rangeVariable'?: Array<RangeVariable>;
}
/**
 * 
 * @export
 * @interface TaxAddress
 */
export interface TaxAddress {
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'streetSide'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'businessName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'addressLine1'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'addressLine2'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'addressLine3'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'stateProvince'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'county'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'latitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'longitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'urbanizationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'formattedAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'mainAddressLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'addressLastLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'placeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'areaName1'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'areaName2'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'areaName3'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'areaName4'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'postCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'postCode1'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'postCodeExt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'addressNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'streetName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'unitType'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'unitValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'distanceUnits'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'bufferWidth'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'userBufferWidth'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxAddress
     */
    'purchaseAmount'?: string;
}
/**
 * 
 * @export
 * @interface TaxAddressRequest
 */
export interface TaxAddressRequest {
    /**
     * 
     * @type {LocalTaxPreferences}
     * @memberof TaxAddressRequest
     */
    'preferences'?: LocalTaxPreferences;
    /**
     * 
     * @type {Array<TaxAddress>}
     * @memberof TaxAddressRequest
     */
    'taxAddresses': Array<TaxAddress>;
}
/**
 * 
 * @export
 * @interface TaxCounty
 */
export interface TaxCounty {
    /**
     * 
     * @type {string}
     * @memberof TaxCounty
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxCounty
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface TaxDistrictResponse
 */
export interface TaxDistrictResponse {
    /**
     * 
     * @type {string}
     * @memberof TaxDistrictResponse
     */
    'vendorName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxDistrictResponse
     */
    'objectId'?: string;
    /**
     * 
     * @type {number}
     * @memberof TaxDistrictResponse
     */
    'confidence'?: number;
    /**
     * 
     * @type {IPDTaxJurisdiction}
     * @memberof TaxDistrictResponse
     */
    'jurisdiction'?: IPDTaxJurisdiction;
    /**
     * 
     * @type {number}
     * @memberof TaxDistrictResponse
     */
    'numOfIpdsFound'?: number;
    /**
     * 
     * @type {Array<Ipd>}
     * @memberof TaxDistrictResponse
     */
    'ipds'?: Array<Ipd>;
    /**
     * 
     * @type {TaxRateMatchedAddress}
     * @memberof TaxDistrictResponse
     */
    'matchedAddress'?: TaxRateMatchedAddress;
    /**
     * 
     * @type {Census}
     * @memberof TaxDistrictResponse
     */
    'census'?: Census;
    /**
     * 
     * @type {LatLongFields}
     * @memberof TaxDistrictResponse
     */
    'latLongFields'?: LatLongFields;
}
/**
 * 
 * @export
 * @interface TaxDistrictResponseList
 */
export interface TaxDistrictResponseList {
    /**
     * 
     * @type {Array<TaxDistrictResponse>}
     * @memberof TaxDistrictResponseList
     */
    'taxDistrictResponse'?: Array<TaxDistrictResponse>;
}
/**
 * 
 * @export
 * @interface TaxDocType
 */
export interface TaxDocType {
    /**
     * 
     * @type {string}
     * @memberof TaxDocType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxDocType
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface TaxExemption
 */
export interface TaxExemption {
    /**
     * 
     * @type {string}
     * @memberof TaxExemption
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxExemption
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface TaxGeometry
 */
export interface TaxGeometry {
    /**
     * 
     * @type {string}
     * @memberof TaxGeometry
     */
    'type': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof TaxGeometry
     */
    'coordinates'?: Array<number>;
}
/**
 * 
 * @export
 * @interface TaxJurisdiction
 */
export interface TaxJurisdiction {
    /**
     * 
     * @type {TaxState}
     * @memberof TaxJurisdiction
     */
    'state'?: TaxState;
    /**
     * 
     * @type {TaxCounty}
     * @memberof TaxJurisdiction
     */
    'county'?: TaxCounty;
    /**
     * 
     * @type {TaxPlace}
     * @memberof TaxJurisdiction
     */
    'place'?: TaxPlace;
    /**
     * 
     * @type {Array<SpecialPurposeDistrict>}
     * @memberof TaxJurisdiction
     */
    'spds'?: Array<SpecialPurposeDistrict>;
}
/**
 * 
 * @export
 * @interface TaxLocationRequest
 */
export interface TaxLocationRequest {
    /**
     * 
     * @type {LocalTaxPreferences}
     * @memberof TaxLocationRequest
     */
    'preferences'?: LocalTaxPreferences;
    /**
     * 
     * @type {Array<TaxLocations>}
     * @memberof TaxLocationRequest
     */
    'locations': Array<TaxLocations>;
}
/**
 * 
 * @export
 * @interface TaxLocations
 */
export interface TaxLocations {
    /**
     * 
     * @type {TaxGeometry}
     * @memberof TaxLocations
     */
    'geometry': TaxGeometry;
    /**
     * 
     * @type {string}
     * @memberof TaxLocations
     */
    'purchaseAmount'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxLocations
     */
    'objectId'?: string;
}
/**
 * 
 * @export
 * @interface TaxPlace
 */
export interface TaxPlace {
    /**
     * 
     * @type {string}
     * @memberof TaxPlace
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxPlace
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxPlace
     */
    'gnisCode'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TaxPlace
     */
    'selfCollected'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TaxPlace
     */
    'classCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxPlace
     */
    'incorporatedFlag'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxPlace
     */
    'lastAnnexedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxPlace
     */
    'lastUpdatedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxPlace
     */
    'lastVerifiedDate'?: string;
}
/**
 * 
 * @export
 * @interface TaxRateAddress
 */
export interface TaxRateAddress {
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'streetSide'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'businessName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'addressLine1'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'addressLine2'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'addressLine3'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'stateProvince'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'county'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'latitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'longitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'urbanizationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'formattedAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'mainAddressLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'addressLastLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'placeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'areaName1'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'areaName2'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'areaName3'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'areaName4'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'postCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'postCode1'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'postCodeExt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'addressNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'streetName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'unitType'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'unitValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'distanceUnits'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'bufferWidth'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateAddress
     */
    'userBufferWidth'?: string;
}
/**
 * 
 * @export
 * @interface TaxRateAddressRequest
 */
export interface TaxRateAddressRequest {
    /**
     * 
     * @type {LocalTaxPreferences}
     * @memberof TaxRateAddressRequest
     */
    'preferences'?: LocalTaxPreferences;
    /**
     * 
     * @type {Array<TaxRateAddress>}
     * @memberof TaxRateAddressRequest
     */
    'taxRateAddresses': Array<TaxRateAddress>;
}
/**
 * 
 * @export
 * @interface TaxRateLocationRequest
 */
export interface TaxRateLocationRequest {
    /**
     * 
     * @type {LocalTaxPreferences}
     * @memberof TaxRateLocationRequest
     */
    'preferences'?: LocalTaxPreferences;
    /**
     * 
     * @type {Array<TaxLocations>}
     * @memberof TaxRateLocationRequest
     */
    'locations': Array<TaxLocations>;
}
/**
 * 
 * @export
 * @interface TaxRateMatchedAddress
 */
export interface TaxRateMatchedAddress {
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'streetSide'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'businessName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'addressLine1'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'addressLine2'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'addressLine3'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'stateProvince'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'county'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'latitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'longitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'urbanizationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'formattedAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'mainAddressLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'addressLastLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'placeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'areaName1'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'areaName2'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'areaName3'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'areaName4'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'postCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'postCode1'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'postCodeExt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'addressNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'streetName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'unitType'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateMatchedAddress
     */
    'unitValue'?: string;
}
/**
 * 
 * @export
 * @interface TaxRateResponse
 */
export interface TaxRateResponse {
    /**
     * 
     * @type {string}
     * @memberof TaxRateResponse
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateResponse
     */
    'vendorName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxRateResponse
     */
    'gnisCode'?: string;
    /**
     * 
     * @type {number}
     * @memberof TaxRateResponse
     */
    'confidence'?: number;
    /**
     * 
     * @type {TaxJurisdiction}
     * @memberof TaxRateResponse
     */
    'jurisdiction'?: TaxJurisdiction;
    /**
     * 
     * @type {TaxRateMatchedAddress}
     * @memberof TaxRateResponse
     */
    'matchedAddress'?: TaxRateMatchedAddress;
    /**
     * 
     * @type {SalesTax}
     * @memberof TaxRateResponse
     */
    'salesTax'?: SalesTax;
    /**
     * 
     * @type {UseTax}
     * @memberof TaxRateResponse
     */
    'useTax'?: UseTax;
    /**
     * 
     * @type {Census}
     * @memberof TaxRateResponse
     */
    'census'?: Census;
    /**
     * 
     * @type {LatLongFields}
     * @memberof TaxRateResponse
     */
    'latLongFields'?: LatLongFields;
    /**
     * 
     * @type {TaxRateMatchedAddress}
     * @memberof TaxRateResponse
     */
    'address'?: TaxRateMatchedAddress;
}
/**
 * 
 * @export
 * @interface TaxResponses
 */
export interface TaxResponses {
    /**
     * 
     * @type {Array<TaxRateResponse>}
     * @memberof TaxResponses
     */
    'taxResponses'?: Array<TaxRateResponse>;
}
/**
 * 
 * @export
 * @interface TaxSalesPriceCode
 */
export interface TaxSalesPriceCode {
    /**
     * 
     * @type {string}
     * @memberof TaxSalesPriceCode
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxSalesPriceCode
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface TaxState
 */
export interface TaxState {
    /**
     * 
     * @type {string}
     * @memberof TaxState
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxState
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Time
 */
export interface Time {
    /**
     * 
     * @type {string}
     * @memberof Time
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof Time
     */
    'unit'?: string;
}
/**
 * 
 * @export
 * @interface TimezoneAddressRequest
 */
export interface TimezoneAddressRequest {
    /**
     * 
     * @type {PreferencTimeZone}
     * @memberof TimezoneAddressRequest
     */
    'preferences'?: PreferencTimeZone;
    /**
     * 
     * @type {Array<AddressTime>}
     * @memberof TimezoneAddressRequest
     */
    'addressTime'?: Array<AddressTime>;
}
/**
 * 
 * @export
 * @interface TimezoneGeometry
 */
export interface TimezoneGeometry {
    /**
     * 
     * @type {string}
     * @memberof TimezoneGeometry
     */
    'type': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof TimezoneGeometry
     */
    'coordinates'?: Array<number>;
}
/**
 * 
 * @export
 * @interface TimezoneLocationRequest
 */
export interface TimezoneLocationRequest {
    /**
     * 
     * @type {Array<LocationTime>}
     * @memberof TimezoneLocationRequest
     */
    'locationTime'?: Array<LocationTime>;
}
/**
 * 
 * @export
 * @interface TimezoneResponse
 */
export interface TimezoneResponse {
    /**
     * 
     * @type {string}
     * @memberof TimezoneResponse
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimezoneResponse
     */
    'timezoneName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimezoneResponse
     */
    'zoneType'?: string;
    /**
     * 
     * @type {number}
     * @memberof TimezoneResponse
     */
    'utcOffset'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimezoneResponse
     */
    'dstOffset'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimezoneResponse
     */
    'timestamp'?: number;
    /**
     * 
     * @type {Address}
     * @memberof TimezoneResponse
     */
    'matchedAddress'?: Address;
    /**
     * 
     * @type {string}
     * @memberof TimezoneResponse
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimezoneResponse
     */
    'tzValidFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimezoneResponse
     */
    'tzValidUntill'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimezoneResponse
     */
    'dstRule'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimezoneResponse
     */
    'dstValidFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimezoneResponse
     */
    'dstValidUntill'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimezoneResponse
     */
    'dstStartDateFormat'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimezoneResponse
     */
    'dstEndDateFormat'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimezoneResponse
     */
    'dstStartDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimezoneResponse
     */
    'dstStartTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimezoneResponse
     */
    'dstEndTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimezoneResponse
     */
    'dstEndDate'?: string;
}
/**
 * 
 * @export
 * @interface TimezoneResponseList
 */
export interface TimezoneResponseList {
    /**
     * 
     * @type {Array<TimezoneResponse>}
     * @memberof TimezoneResponseList
     */
    'timezone'?: Array<TimezoneResponse>;
}
/**
 * 
 * @export
 * @interface TravelBoundaries
 */
export interface TravelBoundaries {
    /**
     * 
     * @type {TravelBoundary}
     * @memberof TravelBoundaries
     */
    'travelBoundary'?: TravelBoundary;
}
/**
 * 
 * @export
 * @interface TravelBoundary
 */
export interface TravelBoundary {
    /**
     * 
     * @type {Array<Cost>}
     * @memberof TravelBoundary
     */
    'costs'?: Array<Cost>;
}
/**
 * 
 * @export
 * @interface TravelCostMatrixResponse
 */
export interface TravelCostMatrixResponse {
    /**
     * 
     * @type {Array<Matrix>}
     * @memberof TravelCostMatrixResponse
     */
    'matrix'?: Array<Matrix>;
}
/**
 * 
 * @export
 * @interface Type
 */
export interface Type {
    /**
     * 
     * @type {string}
     * @memberof Type
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Type
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface TypeaheadLocation
 */
export interface TypeaheadLocation {
    /**
     * 
     * @type {string}
     * @memberof TypeaheadLocation
     */
    'dataset'?: string;
    /**
     * 
     * @type {Match}
     * @memberof TypeaheadLocation
     */
    'match'?: Match;
    /**
     * 
     * @type {Address1}
     * @memberof TypeaheadLocation
     */
    'address'?: Address1;
    /**
     * 
     * @type {Poi}
     * @memberof TypeaheadLocation
     */
    'poi'?: Poi;
    /**
     * 
     * @type {Distance}
     * @memberof TypeaheadLocation
     */
    'distance'?: Distance;
    /**
     * 
     * @type {string}
     * @memberof TypeaheadLocation
     */
    'unitTemp'?: string;
    /**
     * 
     * @type {string}
     * @memberof TypeaheadLocation
     */
    'valueTemp'?: string;
    /**
     * 
     * @type {Geometry}
     * @memberof TypeaheadLocation
     */
    'geometry'?: Geometry;
    /**
     * 
     * @type {number}
     * @memberof TypeaheadLocation
     */
    'totalUnitCount'?: number;
    /**
     * 
     * @type {Array<TypeaheadRange>}
     * @memberof TypeaheadLocation
     */
    'ranges'?: Array<TypeaheadRange>;
    /**
     * 
     * @type {Place}
     * @memberof TypeaheadLocation
     */
    'place'?: Place;
}
/**
 * 
 * @export
 * @interface TypeaheadLocations
 */
export interface TypeaheadLocations {
    /**
     * 
     * @type {Array<TypeaheadLocation>}
     * @memberof TypeaheadLocations
     */
    'location'?: Array<TypeaheadLocation>;
}
/**
 * 
 * @export
 * @interface TypeaheadRange
 */
export interface TypeaheadRange {
    /**
     * 
     * @type {string}
     * @memberof TypeaheadRange
     */
    'placeName'?: string;
    /**
     * 
     * @type {Array<TypeaheadUnit>}
     * @memberof TypeaheadRange
     */
    'units'?: Array<TypeaheadUnit>;
}
/**
 * 
 * @export
 * @interface TypeaheadUnit
 */
export interface TypeaheadUnit {
    /**
     * 
     * @type {string}
     * @memberof TypeaheadUnit
     */
    'unitInfo'?: string;
    /**
     * 
     * @type {string}
     * @memberof TypeaheadUnit
     */
    'formattedUnitAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof TypeaheadUnit
     */
    'postalVerified'?: string;
}
/**
 * 
 * @export
 * @interface Unit
 */
export interface Unit {
    /**
     * 
     * @type {number}
     * @memberof Unit
     */
    'value'?: number;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    'unit'?: string;
}
/**
 * 
 * @export
 * @interface UseTax
 */
export interface UseTax {
    /**
     * 
     * @type {boolean}
     * @memberof UseTax
     */
    'specialTaxRulesApplied'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UseTax
     */
    'specialTaxRulesDescriptor'?: string;
    /**
     * 
     * @type {number}
     * @memberof UseTax
     */
    'totalTaxRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof UseTax
     */
    'totalTaxAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof UseTax
     */
    'stateTaxRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof UseTax
     */
    'stateTaxAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof UseTax
     */
    'countyTaxRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof UseTax
     */
    'countyTaxAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof UseTax
     */
    'municipalTaxRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof UseTax
     */
    'municipalTaxAmount'?: number;
    /**
     * 
     * @type {Array<SpecialPurposeDistrictTax>}
     * @memberof UseTax
     */
    'spdsTax'?: Array<SpecialPurposeDistrictTax>;
}
/**
 * 
 * @export
 * @interface Vacancy
 */
export interface Vacancy {
    /**
     * 
     * @type {string}
     * @memberof Vacancy
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Vacancy
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface ValidateEmailAddressAPIRequest
 */
export interface ValidateEmailAddressAPIRequest {
    /**
     * 
     * @type {object}
     * @memberof ValidateEmailAddressAPIRequest
     */
    'options'?: object;
    /**
     * 
     * @type {ValidateEmailAddressInput}
     * @memberof ValidateEmailAddressAPIRequest
     */
    'Input'?: ValidateEmailAddressInput;
}
/**
 * 
 * @export
 * @interface ValidateEmailAddressAPIResponse
 */
export interface ValidateEmailAddressAPIResponse {
    /**
     * 
     * @type {Array<ValidateEmailAddressOutput>}
     * @memberof ValidateEmailAddressAPIResponse
     */
    'Output'?: Array<ValidateEmailAddressOutput>;
}
/**
 * 
 * @export
 * @interface ValidateEmailAddressInput
 */
export interface ValidateEmailAddressInput {
    /**
     * 
     * @type {Array<ValidateEmailAddressInputRow>}
     * @memberof ValidateEmailAddressInput
     */
    'Row'?: Array<ValidateEmailAddressInputRow>;
}
/**
 * 
 * @export
 * @interface ValidateEmailAddressInputRow
 */
export interface ValidateEmailAddressInputRow {
    /**
     * These fields are returned, unmodified, in the user_fields section of the response.
     * @type {Array<GetPostalCodesAPIOutputUserFields>}
     * @memberof ValidateEmailAddressInputRow
     */
    'user_fields'?: Array<GetPostalCodesAPIOutputUserFields>;
    /**
     * Enables or disables real-time confirmation. If the deliverability of an email address cannot be determined via our knowledge base, a real-time confirmation can be attempted.
     * @type {string}
     * @memberof ValidateEmailAddressInputRow
     */
    'rtc'?: string;
    /**
     * Specifies whether to check if the email address is fictitious. For example, bgates@microsoft.com.
     * @type {string}
     * @memberof ValidateEmailAddressInputRow
     */
    'bogus'?: string;
    /**
     * Specifies whether to check if the email address has a non-personal handle, such as info@, sales@, or webmaster@. For example, sales@example.com.
     * @type {string}
     * @memberof ValidateEmailAddressInputRow
     */
    'role'?: string;
    /**
     * Specifies whether to check if the email address appears on the Direct Marketing Association\'s Do Not Email list (Electronic Mail Preference Service).
     * @type {string}
     * @memberof ValidateEmailAddressInputRow
     */
    'emps'?: string;
    /**
     * Specifies whether to check if the email address is associated with a domain that has restrictions on commercial email per the FCC.
     * @type {string}
     * @memberof ValidateEmailAddressInputRow
     */
    'fccwireless'?: string;
    /**
     * Specifies whether to check if the email address handle contains derogatory words.
     * @type {string}
     * @memberof ValidateEmailAddressInputRow
     */
    'language'?: string;
    /**
     * Specifies whether to check if the owner of the email address is known to submit spam complaints.
     * @type {string}
     * @memberof ValidateEmailAddressInputRow
     */
    'complain'?: string;
    /**
     * Specifies whether to check if the email address originates from a website that provides temporary email addresses, or if the email address appears to be temporary
     * @type {string}
     * @memberof ValidateEmailAddressInputRow
     */
    'disposable'?: string;
    /**
     * One character code controlling the advanced suggestion behavior.The possible values are: a, c, and n
     * @type {string}
     * @memberof ValidateEmailAddressInputRow
     */
    'atc'?: string;
    /**
     * The email address you want to validate.
     * @type {string}
     * @memberof ValidateEmailAddressInputRow
     */
    'emailAddress'?: string;
    /**
     * Specifies the timeout for real-time confirmation. See the description of the rtc parameter. Specify the timeout value in milliseconds. Valid values are 0 to 4000. By default, the system allows 1200 milliseconds for this check.
     * @type {string}
     * @memberof ValidateEmailAddressInputRow
     */
    'rtc_timeout'?: string;
}
/**
 * 
 * @export
 * @interface ValidateEmailAddressOutput
 */
export interface ValidateEmailAddressOutput {
    /**
     * These fields are returned, unmodified, in the user_fields section of the response.
     * @type {Array<GetPostalCodesAPIOutputUserFields>}
     * @memberof ValidateEmailAddressOutput
     */
    'user_fields'?: Array<GetPostalCodesAPIOutputUserFields>;
    /**
     * The email address submitted for verification.
     * @type {string}
     * @memberof ValidateEmailAddressOutput
     */
    'EMAIL'?: string;
    /**
     * One character code indicating the validity of the submitted email address.
     * @type {string}
     * @memberof ValidateEmailAddressOutput
     */
    'FINDING'?: string;
    /**
     * The comment string pertaining to the result of the submitted email address.
     * @type {string}
     * @memberof ValidateEmailAddressOutput
     */
    'COMMENT'?: string;
    /**
     * A short code which maps to each returned COMMENT field value.
     * @type {string}
     * @memberof ValidateEmailAddressOutput
     */
    'COMMENT_CODE'?: string;
    /**
     * Suggested correction for submitted email address, if found. A suggestion will only be provided if it is valid and SafeToDeliver.
     * @type {string}
     * @memberof ValidateEmailAddressOutput
     */
    'SUGG_EMAIL'?: string;
    /**
     * This field contains suggestion not SafeToDeliver when ValidateEmailAddress corrected the address and the corrected version of the email address failed one or more SafeToDeliver process checks.
     * @type {string}
     * @memberof ValidateEmailAddressOutput
     */
    'SUGG_COMMENT'?: string;
    /**
     * Pre-formatted response intended to be provided to user.
     * @type {string}
     * @memberof ValidateEmailAddressOutput
     */
    'ERROR_RESPONSE'?: string;
    /**
     * Field reserved for special features only.
     * @type {string}
     * @memberof ValidateEmailAddressOutput
     */
    'ERROR'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidateEmailAddressOutput
     */
    'Status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidateEmailAddressOutput
     */
    'Status.Code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidateEmailAddressOutput
     */
    'Status.Description'?: string;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressInput
 */
export interface ValidateMailingAddressInput {
    /**
     * 
     * @type {Array<ValidateMailingAddressInputRow>}
     * @memberof ValidateMailingAddressInput
     */
    'Row'?: Array<ValidateMailingAddressInputRow>;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressInputRow
 */
export interface ValidateMailingAddressInputRow {
    /**
     * These fields are returned, unmodified, in the user_fields section of the response.
     * @type {Array<GetPostalCodesAPIOutputUserFields>}
     * @memberof ValidateMailingAddressInputRow
     */
    'user_fields'?: Array<GetPostalCodesAPIOutputUserFields>;
    /**
     * The first address line.
     * @type {string}
     * @memberof ValidateMailingAddressInputRow
     */
    'AddressLine1'?: string;
    /**
     * The second address line.
     * @type {string}
     * @memberof ValidateMailingAddressInputRow
     */
    'AddressLine2'?: string;
    /**
     * The company or firm name.
     * @type {string}
     * @memberof ValidateMailingAddressInputRow
     */
    'FirmName'?: string;
    /**
     * The city name.
     * @type {string}
     * @memberof ValidateMailingAddressInputRow
     */
    'City'?: string;
    /**
     * The state or province.
     * @type {string}
     * @memberof ValidateMailingAddressInputRow
     */
    'StateProvince'?: string;
    /**
     * The country code or name.
     * @type {string}
     * @memberof ValidateMailingAddressInputRow
     */
    'Country'?: string;
    /**
     * The postal code for the address.
     * @type {string}
     * @memberof ValidateMailingAddressInputRow
     */
    'PostalCode'?: string;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressOptions
 */
export interface ValidateMailingAddressOptions {
    /**
     * Specify the casing of the output data.
     * @type {string}
     * @memberof ValidateMailingAddressOptions
     */
    'OutputCasing'?: string;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressOutput
 */
export interface ValidateMailingAddressOutput {
    /**
     * These fields are returned, unmodified, in the user_fields section of the response.
     * @type {Array<GetPostalCodesAPIOutputUserFields>}
     * @memberof ValidateMailingAddressOutput
     */
    'user_fields'?: Array<GetPostalCodesAPIOutputUserFields>;
    /**
     * The first line of the validated address.
     * @type {string}
     * @memberof ValidateMailingAddressOutput
     */
    'AddressLine1'?: string;
    /**
     * The second line of the validated address.
     * @type {string}
     * @memberof ValidateMailingAddressOutput
     */
    'AddressLine2'?: string;
    /**
     * The validated firm or company name.
     * @type {string}
     * @memberof ValidateMailingAddressOutput
     */
    'FirmName'?: string;
    /**
     * The validated city name.
     * @type {string}
     * @memberof ValidateMailingAddressOutput
     */
    'City'?: string;
    /**
     * The validated ZIP Code or postal code.
     * @type {string}
     * @memberof ValidateMailingAddressOutput
     */
    'PostalCode'?: string;
    /**
     * The country name in English.
     * @type {string}
     * @memberof ValidateMailingAddressOutput
     */
    'Country'?: string;
    /**
     * The validated state or province abbreviation.
     * @type {string}
     * @memberof ValidateMailingAddressOutput
     */
    'StateProvince'?: string;
    /**
     * The formatted address, as it would appear on a physical mail piece.
     * @type {string}
     * @memberof ValidateMailingAddressOutput
     */
    'BlockAddress'?: string;
    /**
     * Input data not used by the address validation process.
     * @type {string}
     * @memberof ValidateMailingAddressOutput
     */
    'AdditionalInputData'?: string;
    /**
     * The 5-digit ZIP Code.
     * @type {string}
     * @memberof ValidateMailingAddressOutput
     */
    'PostalCode.Base'?: string;
    /**
     * The 4-digit add-on part of the ZIP Code.
     * @type {string}
     * @memberof ValidateMailingAddressOutput
     */
    'PostalCode.AddOn'?: string;
    /**
     * Reports the success or failure of the match attempt.
     * @type {string}
     * @memberof ValidateMailingAddressOutput
     */
    'Status'?: string;
    /**
     * Reason for failure, if there is one.
     * @type {string}
     * @memberof ValidateMailingAddressOutput
     */
    'Status.Code'?: string;
    /**
     * Description of the problem, if there is one.
     * @type {string}
     * @memberof ValidateMailingAddressOutput
     */
    'Status.Description'?: string;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressPremiumInput
 */
export interface ValidateMailingAddressPremiumInput {
    /**
     * 
     * @type {Array<ValidateMailingAddressPremiumInputRow>}
     * @memberof ValidateMailingAddressPremiumInput
     */
    'Row'?: Array<ValidateMailingAddressPremiumInputRow>;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressPremiumInputRow
 */
export interface ValidateMailingAddressPremiumInputRow {
    /**
     * These fields are returned, unmodified, in the user_fields section of the response.
     * @type {Array<GetPostalCodesAPIOutputUserFields>}
     * @memberof ValidateMailingAddressPremiumInputRow
     */
    'user_fields'?: Array<GetPostalCodesAPIOutputUserFields>;
    /**
     * The first address line.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumInputRow
     */
    'AddressLine1'?: string;
    /**
     * The second address line.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumInputRow
     */
    'AddressLine2'?: string;
    /**
     * The third address line.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumInputRow
     */
    'AddressLine3'?: string;
    /**
     * The fourth address line.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumInputRow
     */
    'AddressLine4'?: string;
    /**
     * The fifth address line.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumInputRow
     */
    'AddressLine5'?: string;
    /**
     * The company or firm name.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumInputRow
     */
    'FirmName'?: string;
    /**
     * The city name.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumInputRow
     */
    'City'?: string;
    /**
     * The state or province.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumInputRow
     */
    'StateProvince'?: string;
    /**
     * The country code or name.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumInputRow
     */
    'Country'?: string;
    /**
     * The postal code for the address.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumInputRow
     */
    'PostalCode'?: string;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressPremiumOptions
 */
export interface ValidateMailingAddressPremiumOptions {
    /**
     * Specifies whether to return a formatted version of the address as it would be printed on a physical mail piece.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOptions
     */
    'OutputAddressBlocks'?: string;
    /**
     * Specifies whether to return multiple address for those input addresses that have more than one possible match.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOptions
     */
    'KeepMultimatch'?: string;
    /**
     * Specifies the format to use for the country name returned in the Country output field.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOptions
     */
    'OutputCountryFormat'?: string;
    /**
     * Specifies the type of output record you get.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOptions
     */
    'OutputRecordType'?: string;
    /**
     * Specifies whether to include field-level result indicators.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOptions
     */
    'OutputFieldLevelReturnCodes'?: string;
    /**
     * Specifies the alphabet or script in which the output should be returned.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOptions
     */
    'OutputScript'?: string;
    /**
     * Specify the casing of the output data.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOptions
     */
    'OutputCasing'?: string;
    /**
     * A number between 1 and 10 that indicates the maximum number of addresses to return.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOptions
     */
    'MaximumResults'?: string;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressPremiumOutput
 */
export interface ValidateMailingAddressPremiumOutput {
    /**
     * These fields are returned, unmodified, in the user_fields section of the response.
     * @type {Array<GetPostalCodesAPIOutputUserFields>}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'user_fields'?: Array<GetPostalCodesAPIOutputUserFields>;
    /**
     * Reports the success or failure of the match attempt.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'Status'?: string;
    /**
     * Reason for failure, if there is one.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'Status.Code'?: string;
    /**
     * Description of the problem, if there is one.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'Status.Description'?: string;
    /**
     * The level of confidence assigned to the address being returned.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'Confidence'?: string;
    /**
     * Type of address record.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'RecordType'?: string;
    /**
     * Code indicating the default match.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'RecordType.Default'?: string;
    /**
     * Indicates which address component had multiple matches.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'MultipleMatches'?: string;
    /**
     * Mentions the address component that could not be validated, in case no match is found.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'CouldNotValidate'?: string;
    /**
     * The category of address matching available.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'CountryLevel'?: string;
    /**
     * The type of address data being returned.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'AddressFormat'?: string;
    /**
     * The first line of the validated address.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'AddressLine1'?: string;
    /**
     * The second line of the validated address.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'AddressLine2'?: string;
    /**
     * The third line of the validated address.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'AddressLine3'?: string;
    /**
     * The fourth line of the validated address.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'AddressLine4'?: string;
    /**
     * The validated city name.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'City'?: string;
    /**
     * The validated state or province abbreviation.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'StateProvince'?: string;
    /**
     * The validated ZIP Code or postal code.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'PostalCode'?: string;
    /**
     * The 5-digit ZIP Code.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'PostalCode.Base'?: string;
    /**
     * The 4-digit add-on part of the ZIP Code.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'PostalCode.AddOn'?: string;
    /**
     * The country in the format determined by what you selected.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'Country'?: string;
    /**
     * Input data that could not be matched to a particular address component.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'AdditionalInputData'?: string;
    /**
     * The validated firm or company name.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'FirmName'?: string;
    /**
     * House number.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'HouseNumber'?: string;
    /**
     * Leading directional.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'LeadingDirectional'?: string;
    /**
     * Street name.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'StreetName'?: string;
    /**
     * Street suffix.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'StreetSuffix'?: string;
    /**
     * Trailing directional.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'TrailingDirectional'?: string;
    /**
     * Apartment designator (such as STE or APT).
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'ApartmentLabel'?: string;
    /**
     * Apartment number.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'ApartmentNumber'?: string;
    /**
     * Secondary apartment designator.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'ApartmentLabel2'?: string;
    /**
     * Secondary apartment number.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'ApartmentNumber2'?: string;
    /**
     * Rural Route/Highway Contract indicator.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'RRHC'?: string;
    /**
     * Post office box number.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'POBox'?: string;
    /**
     * Private mailbox indicator.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'PrivateMailbox'?: string;
    /**
     * The type of private mailbox.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'PrivateMailbox.Type'?: string;
    /**
     * House number.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'HouseNumber.Input'?: string;
    /**
     * Leading directional.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'LeadingDirectional.Input'?: string;
    /**
     * Street name.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'StreetName.Input'?: string;
    /**
     * Street suffix.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'StreetSuffix.Input'?: string;
    /**
     * Trailing directional.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'TrailingDirectional.Input'?: string;
    /**
     * Apartment designator (such as STE or APT).
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'ApartmentLabel.Input'?: string;
    /**
     * Apartment number.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'ApartmentNumber.Input'?: string;
    /**
     * Rural Route/Highway Contract indicator.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'RRHC.Input'?: string;
    /**
     * Post office box number.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'POBox.Input'?: string;
    /**
     * Private mailbox indicator.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'PrivateMailbox.Input'?: string;
    /**
     * The type of private mailbox.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'PrivateMailbox.Type.Input'?: string;
    /**
     * Validated city name.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'City.Input'?: string;
    /**
     * Validated state or province name.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'StateProvince.Input'?: string;
    /**
     * Validated postal code.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'PostalCode.Input'?: string;
    /**
     * Country. Format is determined by what you selected in OutputCountryFormat.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'Country.Input'?: string;
    /**
     * The validated firm or company name.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'FirmName.Input'?: string;
    /**
     * The field-level result indicator for HouseNumber.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'HouseNumber.Result'?: string;
    /**
     * The field-level result indicator for LeadingDirectional.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'LeadingDirectional.Result'?: string;
    /**
     * The field-level result indicator for Street.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'Street.Result'?: string;
    /**
     * The field-level result indicator for StreetName.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'StreetName.Result'?: string;
    /**
     * The field-level result indicator for StreetName Alias.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'StreetName.Alias.Type'?: string;
    /**
     * The field-level result indicator for StreetSuffix.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'StreetSuffix.Result'?: string;
    /**
     * The field-level result indicator for TrailingDirectional.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'TrailingDirectional.Result'?: string;
    /**
     * The field-level result indicator for ApartmentLabel.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'ApartmentLabel.Result'?: string;
    /**
     * The field-level result indicator for ApartmentNumber.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'ApartmentNumber.Result'?: string;
    /**
     * The field-level result indicator for ApartmentLabel2.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'ApartmentLabel2.Result'?: string;
    /**
     * The field-level result indicator for ApartmentNumber2.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'ApartmentNumber2.Result'?: string;
    /**
     * The field-level result indicator for RRHC.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'RRHC.Result'?: string;
    /**
     * The field-level result indicator for RRHC Type.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'RRHC.Type'?: string;
    /**
     * The field-level result indicator for POBox.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'POBox.Result'?: string;
    /**
     * The field-level result indicator for City.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'City.Result'?: string;
    /**
     * The field-level result indicator for StateProvince.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'StateProvince.Result'?: string;
    /**
     * The field-level result indicator for PostalCode.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'PostalCode.Result'?: string;
    /**
     * The field-level result indicator for PostalCodeCity.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'PostalCodeCity.Result'?: string;
    /**
     * The field-level result indicator for AddressRecord.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'AddressRecord.Result'?: string;
    /**
     * The field-level result indicator for PostalCode Source.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'PostalCode.Source'?: string;
    /**
     * Indicates the type of postal code returned.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'PostalCode.Type'?: string;
    /**
     * The validated firm or company name.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'Country.Result'?: string;
    /**
     * Indicates if the firm name got validated.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'FirmName.Result'?: string;
    /**
     * Indicates the result of preferred alias processing.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'StreetNamePreferredAlias.Result'?: string;
    /**
     * Indicates the result of abbreviated alias processing.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'StreetNameAbbreviatedAlias.Result'?: string;
    /**
     * The fifth line of the validated address.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'AddressLine5'?: string;
    /**
     * A two character code indicating overall quality of the resulting address.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'AddressQuality'?: string;
    /**
     * An estimate of confidence that an item mailed or shipped to this address would be successfully delivered.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'Deliverability'?: string;
    /**
     * A single letter code that indicates the type of address.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'AddressType'?: string;
    /**
     * A locality is a village in rural areas or it may be a suburb in urban areas.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'Locality'?: string;
    /**
     * A value of 0 and 100 that reflects how much the address has changed to make it valid.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'ChangeScore'?: string;
    /**
     * The validated firm or company name.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'Suburb'?: string;
    /**
     * It is the formatted address, as it would appear on a physical mail piece.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'BlockAddress'?: string;
    /**
     * Seven-digit number in degrees, calculated to four decimal places.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'Latitude'?: string;
    /**
     * Seven-digit number in degrees, calculated to four decimal places.
     * @type {string}
     * @memberof ValidateMailingAddressPremiumOutput
     */
    'Longitude'?: string;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressPremiumRequest
 */
export interface ValidateMailingAddressPremiumRequest {
    /**
     * 
     * @type {ValidateMailingAddressPremiumOptions}
     * @memberof ValidateMailingAddressPremiumRequest
     */
    'options'?: ValidateMailingAddressPremiumOptions;
    /**
     * 
     * @type {ValidateMailingAddressPremiumInput}
     * @memberof ValidateMailingAddressPremiumRequest
     */
    'Input'?: ValidateMailingAddressPremiumInput;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressPremiumResponse
 */
export interface ValidateMailingAddressPremiumResponse {
    /**
     * 
     * @type {Array<ValidateMailingAddressPremiumOutput>}
     * @memberof ValidateMailingAddressPremiumResponse
     */
    'Output'?: Array<ValidateMailingAddressPremiumOutput>;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressProInput
 */
export interface ValidateMailingAddressProInput {
    /**
     * 
     * @type {Array<ValidateMailingAddressProInputRow>}
     * @memberof ValidateMailingAddressProInput
     */
    'Row'?: Array<ValidateMailingAddressProInputRow>;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressProInputRow
 */
export interface ValidateMailingAddressProInputRow {
    /**
     * These fields are returned, unmodified, in the user_fields section of the response.
     * @type {Array<GetPostalCodesAPIOutputUserFields>}
     * @memberof ValidateMailingAddressProInputRow
     */
    'user_fields'?: Array<GetPostalCodesAPIOutputUserFields>;
    /**
     * The first address line.
     * @type {string}
     * @memberof ValidateMailingAddressProInputRow
     */
    'AddressLine1'?: string;
    /**
     * The second address line.
     * @type {string}
     * @memberof ValidateMailingAddressProInputRow
     */
    'AddressLine2'?: string;
    /**
     * The company or firm name.
     * @type {string}
     * @memberof ValidateMailingAddressProInputRow
     */
    'FirmName'?: string;
    /**
     * The city name.
     * @type {string}
     * @memberof ValidateMailingAddressProInputRow
     */
    'City'?: string;
    /**
     * The state or province.
     * @type {string}
     * @memberof ValidateMailingAddressProInputRow
     */
    'StateProvince'?: string;
    /**
     * The country code or name.
     * @type {string}
     * @memberof ValidateMailingAddressProInputRow
     */
    'Country'?: string;
    /**
     * The postal code for the address.
     * @type {string}
     * @memberof ValidateMailingAddressProInputRow
     */
    'PostalCode'?: string;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressProOptions
 */
export interface ValidateMailingAddressProOptions {
    /**
     * Specifies whether to return a formatted version of the address as it would be printed on a physical mail piece.
     * @type {string}
     * @memberof ValidateMailingAddressProOptions
     */
    'OutputAddressBlocks'?: string;
    /**
     * Specifies whether to return multiple address for those input addresses that have more than one possible match.
     * @type {string}
     * @memberof ValidateMailingAddressProOptions
     */
    'KeepMultimatch'?: string;
    /**
     * Specifies the format to use for the country name returned in the Country output field.
     * @type {string}
     * @memberof ValidateMailingAddressProOptions
     */
    'OutputCountryFormat'?: string;
    /**
     * Specifies the alphabet or script in which the output should be returned.
     * @type {string}
     * @memberof ValidateMailingAddressProOptions
     */
    'OutputScript'?: string;
    /**
     * Specify the casing of the output data.
     * @type {string}
     * @memberof ValidateMailingAddressProOptions
     */
    'OutputCasing'?: string;
    /**
     * A number between 1 and 10 that indicates the maximum number of addresses to return.
     * @type {string}
     * @memberof ValidateMailingAddressProOptions
     */
    'MaximumResults'?: string;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressProOutput
 */
export interface ValidateMailingAddressProOutput {
    /**
     * These fields are returned, unmodified, in the user_fields section of the response.
     * @type {Array<GetPostalCodesAPIOutputUserFields>}
     * @memberof ValidateMailingAddressProOutput
     */
    'user_fields'?: Array<GetPostalCodesAPIOutputUserFields>;
    /**
     * The first line of the validated address.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'AddressLine1'?: string;
    /**
     * The second line of the validated address.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'AddressLine2'?: string;
    /**
     * The validated firm or company name.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'FirmName'?: string;
    /**
     * A value of 0 and 100 that reflects how much the address has changed to make it valid.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'ChangeScore'?: string;
    /**
     * Generally a locality is a village in rural areas or it may be a suburb in urban areas.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'Locality'?: string;
    /**
     * The suburb name.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'Suburb'?: string;
    /**
     * A single letter code that indicates the type of address.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'AddressType'?: string;
    /**
     * An estimate of confidence that an item mailed or shipped to this address would be successfully delivered.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'Deliverability'?: string;
    /**
     * A two character code indicating overall quality of the resulting address.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'AddressQuality'?: string;
    /**
     * Mentions the address component that could not be validated, in case no match is found.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'CouldNotValidate'?: string;
    /**
     * The validated city name.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'City'?: string;
    /**
     * The validated ZIP Code or postal code.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'PostalCode'?: string;
    /**
     * The country in the format determined by what you selected.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'Country'?: string;
    /**
     * The validated state or province abbreviation.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'StateProvince'?: string;
    /**
     * The formatted address, as it would appear on a physical mail piece.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'BlockAddress'?: string;
    /**
     * Input data that could not be matched to a particular address component.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'AdditionalInputData'?: string;
    /**
     * The 5-digit ZIP Code.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'PostalCode.Base'?: string;
    /**
     * The 4-digit add-on part of the ZIP Code.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'PostalCode.AddOn'?: string;
    /**
     * Reports the success or failure of the match attempt.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'Status'?: string;
    /**
     * Reason for failure, if there is one.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'Status.Code'?: string;
    /**
     * Description of the problem, if there is one.
     * @type {string}
     * @memberof ValidateMailingAddressProOutput
     */
    'Status.Description'?: string;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressProRequest
 */
export interface ValidateMailingAddressProRequest {
    /**
     * 
     * @type {ValidateMailingAddressProOptions}
     * @memberof ValidateMailingAddressProRequest
     */
    'options'?: ValidateMailingAddressProOptions;
    /**
     * 
     * @type {ValidateMailingAddressProInput}
     * @memberof ValidateMailingAddressProRequest
     */
    'Input'?: ValidateMailingAddressProInput;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressProResponse
 */
export interface ValidateMailingAddressProResponse {
    /**
     * 
     * @type {Array<ValidateMailingAddressProOutput>}
     * @memberof ValidateMailingAddressProResponse
     */
    'Output'?: Array<ValidateMailingAddressProOutput>;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressRequest
 */
export interface ValidateMailingAddressRequest {
    /**
     * 
     * @type {ValidateMailingAddressOptions}
     * @memberof ValidateMailingAddressRequest
     */
    'options'?: ValidateMailingAddressOptions;
    /**
     * 
     * @type {ValidateMailingAddressInput}
     * @memberof ValidateMailingAddressRequest
     */
    'Input'?: ValidateMailingAddressInput;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressResponse
 */
export interface ValidateMailingAddressResponse {
    /**
     * 
     * @type {Array<ValidateMailingAddressOutput>}
     * @memberof ValidateMailingAddressResponse
     */
    'Output'?: Array<ValidateMailingAddressOutput>;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressUSCANAPIInput
 */
export interface ValidateMailingAddressUSCANAPIInput {
    /**
     * 
     * @type {Array<ValidateMailingAddressUSCANAPIInputRow>}
     * @memberof ValidateMailingAddressUSCANAPIInput
     */
    'Row'?: Array<ValidateMailingAddressUSCANAPIInputRow>;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressUSCANAPIInputRow
 */
export interface ValidateMailingAddressUSCANAPIInputRow {
    /**
     * These fields are returned, unmodified, in the user_fields section of the response.
     * @type {Array<GetPostalCodesAPIOutputUserFields>}
     * @memberof ValidateMailingAddressUSCANAPIInputRow
     */
    'user_fields'?: Array<GetPostalCodesAPIOutputUserFields>;
    /**
     * The first address line.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIInputRow
     */
    'AddressLine1'?: string;
    /**
     * The second address line.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIInputRow
     */
    'AddressLine2'?: string;
    /**
     * The third address line.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIInputRow
     */
    'AddressLine3'?: string;
    /**
     * The fourth address line.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIInputRow
     */
    'AddressLine4'?: string;
    /**
     * The company or firm name.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIInputRow
     */
    'FirmName'?: string;
    /**
     * The city name.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIInputRow
     */
    'City'?: string;
    /**
     * The state or province.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIInputRow
     */
    'StateProvince'?: string;
    /**
     * The country code or name.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIInputRow
     */
    'Country'?: string;
    /**
     * The postal code for the address.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIInputRow
     */
    'PostalCode'?: string;
    /**
     * U.S. address urbanization name. Used primarily for Puerto Rico addresses.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIInputRow
     */
    'USUrbanName'?: string;
    /**
     * Canadian language.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIInputRow
     */
    'CanLanguage'?: string;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressUSCANAPIOptions
 */
export interface ValidateMailingAddressUSCANAPIOptions {
    /**
     * Specifies whether to return a formatted version of the address.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'OutputAddressBlocks'?: string;
    /**
     * Specifies whether or not to process U.S. addresses.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'PerformUSProcessing'?: string;
    /**
     * Delivery Point Validation (DPV) validates that a specific address exists
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'PerformDPV'?: string;
    /**
     * Specifies whether to return a formatted address when an address cannot be validated.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'OutputFormattedOnFail'?: string;
    /**
     * Specifies whether to use separators (spaces or hyphens) in ZIP Codes or Canadian postal codes.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'OutputPostalCodeSeparator'?: string;
    /**
     * Specifies the format to use for the country name returned in the Country output field.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'OutputCountryFormat'?: string;
    /**
     * Indicates whether to return multiple address for input addresses that have more than one possible matches.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'KeepMultimatch'?: string;
    /**
     * Specifies the casing of the output address. M for mixed case and U for upper case.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'OutputCasing'?: string;
    /**
     * Specifies a number between 1 and 10 that indicates the maximum number of addresses to be returned.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'MaximumResults'?: string;
    /**
     * Specifies the type of the output record.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'OutputRecordType'?: string;
    /**
     * Identifies which output addresses are candidate addresses as value if Y for OutputFieldLevelReturnCodes.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'OutputFieldLevelReturnCodes'?: string;
    /**
     * Determines the no stat status of an address which means it exists but cannot receive mails.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'DPVDetermineNoStat'?: string;
    /**
     * Specifies the algorithm to determe if an input address matches in the postal database.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'StreetMatchingStrictness'?: string;
    /**
     * Specifies the default apartment label for the output if there is no apartment label in the input address. This is specific to French address. 
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'CanFrenchApartmentLabel'?: string;
    /**
     * Specifies whether to use a street\'s abbreviated alias in the output if the output address line is longer than 31 characters.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'OutputAbbreviatedAlias'?: string;
    /**
     * Selecting the match condition where a DPV result does NOT cause a record to fail.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'DPVSuccessfulStatusCondition'?: string;
    /**
     * Specifies where Private Mailbox (PMB) information is placed.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'StandardAddressPMBLine'?: string;
    /**
     * Specifies the algorithm to determining if an input address matches in the postal database.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'FirmMatchingStrictness'?: string;
    /**
     * Specifies where to place rural route delivery information.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'CanRuralRouteFormat'?: string;
    /**
     * Specifies whether to select a house number of postal code in case of conflict.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'CanPreferHouseNum'?: string;
    /**
     * Specifies whether to use a street\'s preferred alias in the output.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'OutputPreferredAlias'?: string;
    /**
     * Specifies the algorithm to determine if an input address matches in the postal database.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'DirectionalMatchingStrictness'?: string;
    /**
     * Specifies whether to extract the firm name from AddressLine1 through AddressLine4 and place it in the FirmName output field.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'ExtractFirm'?: string;
    /**
     * Specifies whether to consider Treat Commercial Mail Receiving Agency (CMRA) matches as failures?
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'FailOnCMRAMatch'?: string;
    /**
     * Specifies whether or not non-civic keywords are abbreviated in the output. 
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'CanNonCivicFormat'?: string;
    /**
     * Changes the civic and/or suite information to match the LVR or single-single record.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'CanSSLVRFlg'?: string;
    /**
     * Specifies how to handle street name aliases used in the input. This is specific to US.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'OutputStreetNameAlias'?: string;
    /**
     * Specifies the Early Warning System (EWS) that uses the USPS EWS File to validate addresses that are not in the ZIP + 4 database.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'PerformEWS'?: string;
    /**
     * Specifies whether to use the long, medium, or short version of the city if the city has a long name.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'CanOutputCityFormat'?: string;
    /**
     * Specifies how to return a match if multiple non-blank address lines are present or multiple address types are on the same address line. (U.S. addresses only.)
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'DualAddressLogic'?: string;
    /**
     * Specifies whether to perform SuiteLink processing.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'PerformSuiteLink'?: string;
    /**
     * Specifies where to place secondary address information in the output address.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'CanStandardAddressFormat'?: string;
    /**
     * Specifies whether the preferred last line city name should be stored.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'OutputPreferredCity'?: string;
    /**
     * Specifies whether to return multinational characters, including diacritical marks such as umlauts or accents.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'OutputMultinationalCharacters'?: string;
    /**
     * Specifies where to place station information.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'CanDeliveryOfficeFormat'?: string;
    /**
     * Facilitates the conversion of rural route address converting into street-style address using the LACS.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'PerformLACSLink'?: string;
    /**
     * Specifies whether ValidateMailingAddressUSCAN should return a street match or a PO Box/non-civic match when the address contains both civic and non-civic information.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'CanDualAddressLogic'?: string;
    /**
     * Specifies whether to extract the urbanization name from AddressLine1 through AddressLine4 and place it in the USUrbanName output field. 
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'ExtractUrb'?: string;
    /**
     * Specifies where to place secondary address information for U.S. addresses.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'StandardAddressFormat'?: string;
    /**
     * Specifies how to determine the language (English or French) to use to format the address and directional.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'CanFrenchFormat'?: string;
    /**
     * Determines if the location has been unoccupied for at least 90 days.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'DPVDetermineVacancy'?: string;
    /**
     * Specifies the default apartment label to use in the output if there is no apartment label in the input address. rhis is specific to English addresses.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'CanEnglishApartmentLabel'?: string;
    /**
     * Specifies whether to supress addresses with Carrier Route R777.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'SuppressZplusPhantomCarrierR777'?: string;
    /**
     * Specifies whether or not to return the city alias when the alias is in the input address.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'CanOutputCityAlias'?: string;
    /**
     * Specifies how to format city names that have short city name or non-mailing city name alternatives.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOptions
     */
    'OutputShortCityName'?: string;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressUSCANAPIOutput
 */
export interface ValidateMailingAddressUSCANAPIOutput {
    /**
     * These fields are returned, unmodified, in the user_fields section of the response.
     * @type {Array<GetPostalCodesAPIOutputUserFields>}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'user_fields'?: Array<GetPostalCodesAPIOutputUserFields>;
    /**
     * Reports the success or failure of the match attempt.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'Status'?: string;
    /**
     * Reason for failure, if there is one.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'Status.Code'?: string;
    /**
     * Specifies the description of the problem, if there is one.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'Status.description'?: string;
    /**
     * Specifies the first line of the validated and standardized address.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'AddressLine1'?: string;
    /**
     * Specifies the second line of the validated and standardized address.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'AddressLine2'?: string;
    /**
     * Specifies the validated city name.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'City'?: string;
    /**
     * Specifies the validated state or province abbreviation.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'StateProvince'?: string;
    /**
     * Specifies the validated ZIP Code or postal code.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'PostalCode'?: string;
    /**
     * Specifies the country in the format determined by the selection from ISO or UPO or English.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'Country'?: string;
    /**
     * Specifies the validated firm or company name.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'FirmName'?: string;
    /**
     * Specifies the formatted address, as it would appear on a physical mail piece. 
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'BlockAddress'?: string;
    /**
     * Specifies the 5-digit ZIP Code.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'PostalCode.Base'?: string;
    /**
     * Specifies the 4-digit add-on part of the ZIP Code.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'PostalCode.AddOn'?: string;
    /**
     * Specifies input data not used by the address validation process.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'AdditionalInputData'?: string;
    /**
     * Specifies the address component that could not be validated, in case no match is found. 
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'CouldNotValidate'?: string;
    /**
     * Specifies the type of address data being returned.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'AddressFormat'?: string;
    /**
     * Specifies the third line of the validated and standardized address. If the address could not be validated, the third line of the input address without any changes.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'AddressLine3'?: string;
    /**
     * Specifies the fourth line of the validated and standardized address. If the address could not be validated, the fourth line of the input address without any changes.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'AddressLine4'?: string;
    /**
     * Specifies the result codes that apply to international addresses only.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'AddressRecord.Result'?: string;
    /**
     * Specifies the apartment designator such as STE or APT.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'ApartmentLabel'?: string;
    /**
     * Specifies the apartment designator such as STE or APT.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'ApartmentLabel.Input'?: string;
    /**
     * Specifies the result of apartment label.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'ApartmentLabel.Result'?: string;
    /**
     * Specifies the apartment number.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'ApartmentNumber'?: string;
    /**
     * Specifies the apartment number.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'ApartmentNumber.Input'?: string;
    /**
     * Specifies the result of apartment number.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'ApartmentNumber.Result'?: string;
    /**
     * Specifies the validated city name.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'City.Input'?: string;
    /**
     * Specifies the result of the validated city name.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'City.Result'?: string;
    /**
     * Specifies the the level of confidence assigned to the address being returned.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'Confidence'?: string;
    /**
     * Specifies the name of the country.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'Country.Input'?: string;
    /**
     * Specifies the result code for the country.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'Country.Result'?: string;
    /**
     * Specifies the category of address matching available.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'CountryLevel'?: string;
    /**
     * Specifies the validated firm or company name.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'FirmName.Input'?: string;
    /**
     * Specifies if the firm name got validated.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'FirmName.Result'?: string;
    /**
     * Specifies the house number.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'HouseNumber'?: string;
    /**
     * Specifies the house number.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'HouseNumber.Input'?: string;
    /**
     * Specifies the result for house number.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'HouseNumber.Result'?: string;
    /**
     * Specifies the leading directional.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'LeadingDirectional'?: string;
    /**
     * Specifies the leading directional.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'LeadingDirectional.Input'?: string;
    /**
     * Specifies the result of leading directional.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'LeadingDirectional.Result'?: string;
    /**
     * Specifies the address component with multiple matches, if multiple matches were found: 
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'MultipleMatches'?: string;
    /**
     * Specifies the post office box number.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'POBox'?: string;
    /**
     * Specifies the post office box number.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'POBox.Input'?: string;
    /**
     * Specifies the result of post office box number.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'POBox.Result'?: string;
    /**
     * Specifies the validated postal code. For U.S. addresses, this is the ZIP code.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'PostalCode.Input'?: string;
    /**
     * Specifies the result of validated postal code.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'PostalCode.Result'?: string;
    /**
     * Specifies the result code.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'PostalCode.Source'?: string;
    /**
     * Specifies the type of postal code returned.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'PostalCode.Type'?: string;
    /**
     * Specifies the international result code.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'PostalCodeCity.Result'?: string;
    /**
     * Specifies the private mailbox indicator.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'PrivateMailbox'?: string;
    /**
     * Specifies the private mailbox indicator.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'PrivateMailbox.Input'?: string;
    /**
     * Specifies the type of private mailbox.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'PrivateMailbox.Type'?: string;
    /**
     * Specifies the type of private mailbox.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'PrivateMailbox.Type.Input'?: string;
    /**
     * Specifies the type of address record, as defined by U.S. and Canadian postal authorities.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'RecordType'?: string;
    /**
     * Specifies the code indicating the default match.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'RecordType.Default'?: string;
    /**
     * Specifies the Rural Route/Highway Contract indicator.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'RRHC'?: string;
    /**
     * Specifies the Rural Route/Highway Contract indicator.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'RRHC.Input'?: string;
    /**
     * Specifies the result for Rural Route/Highway Contract indicator.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'RRHC.Result'?: string;
    /**
     * Specifies the result code for Rural Route/Highway Contract indicator.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'RRHC.Type'?: string;
    /**
     * Specifies the validated state or province abbreviation.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'StateProvince.Input'?: string;
    /**
     * Specifies the result of validated state or province abbreviation.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'StateProvince.Result'?: string;
    /**
     * Specifies the result codes for international addresses.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'Street.Result'?: string;
    /**
     * Specifies the street name.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'StreetName'?: string;
    /**
     * Specifies result code that applies to U.S. addresses only.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'StreetName.Alias.Type'?: string;
    /**
     * Specifies the street name.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'StreetName.Input'?: string;
    /**
     * Specifies the result of the street name.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'StreetName.Result'?: string;
    /**
     * Indicates the result of abbreviated alias processing.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'StreetNameAbbreviatedAlias.Result'?: string;
    /**
     * Specifies the result of preferred alias processing.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'StreetNamePreferredAlias.Result'?: string;
    /**
     * Specifies the street suffix.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'StreetSuffix'?: string;
    /**
     * Specifies the street suffix.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'StreetSuffix.Input'?: string;
    /**
     * Specifies the result of the street suffix.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'StreetSuffix.Result'?: string;
    /**
     * Specifies the trailing directional.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'TrailingDirectional'?: string;
    /**
     * Specifies the trailing directional.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'TrailingDirectional.Input'?: string;
    /**
     * Specifies the result of the trailing directional.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'TrailingDirectional.Result'?: string;
    /**
     * Specifies an indication of the degree to which the output address is correct.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'MatchScore'?: string;
    /**
     * Specifies whether the address is a candidate for LACS conversion. This is for U.S. addresses only).
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'USLACS'?: string;
    /**
     * Specifies the the success or failure of LACS processing. This is for U.S. addresses only).
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'USLACS.ReturnCode'?: string;
    /**
     * Specifies the values indicating address type.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'RDI'?: string;
    /**
     * Specifies if the address is a Commercial Mail Receiving Agency (CMRA).
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'CMRA'?: string;
    /**
     * Specifies the results of Delivery Point Validation (DPV) processing.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'DPV'?: string;
    /**
     * Specifies the DPV footnote codes.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'DPVFootnote'?: string;
    /**
     * Indicates whether or not API corrected the secondary address information (U.S. addresses only). 
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'SuiteLinkReturnCode'?: string;
    /**
     * Provides additional information on the SuiteLink match attempt. (U.S. addresses only)
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'SuiteLinkMatchCode'?: string;
    /**
     * Indicates how well ValidateAddress matched the firm name to the firm names in the SuiteLink database.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'SuiteLinkFidelity'?: string;
    /**
     * Specifies the check-digit portion of the 11-digit delivery point barcode.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'USBCCheckDigit'?: string;
    /**
     * Specifies the delivery point portion of the delivery point barcode.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'PostalBarCode'?: string;
    /**
     * Specifies carrier route code.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'USCarrierRouteCode'?: string;
    /**
     * Specifies FIPS (Federal Information Processing Standards) county number (U.S. addresses only).
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'USFIPSCountyNumber'?: string;
    /**
     * Specifies the county name (U.S. addresses only).
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'USCountyName'?: string;
    /**
     * Specifies congressional district (U.S. addresses only).
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'USCongressionalDistrict'?: string;
    /**
     * Specifies whether the alternate address matching logic was used, and if so which logic was used (U.S. addresses only).
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'USAltAddr'?: string;
    /**
     * Specifies a six-character alphanumeric value that groups together ZIP Codes that share the same primary city.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'USLastLineNumber'?: string;
    /**
     * Specifies the finance number in which the address resides (U.S. addresses only).
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'USFinanceNumber'?: string;
    /**
     * U.S. address urbanization name. Used primarily for Puerto Rico addresses.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'USUrbanName'?: string;
    /**
     * U.S. address urbanization name. Used primarily for Puerto Rico addresses.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'USUrbanName.Input'?: string;
    /**
     * U.S. address urbanization name. Used primarily for Puerto Rico addresses.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'USUrbanName.Result'?: string;
    /**
     * If the address was matched to multiple candidate addresses in the reference data, this field contains the number of candidate matches found.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'MultimatchCount'?: string;
    /**
     * AddressBlock1
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'AddressBlock1'?: string;
    /**
     * AddressBlock2
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'AddressBlock2'?: string;
    /**
     * AddressBlock3
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'AddressBlock3'?: string;
    /**
     * AddressBlock4
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'AddressBlock4'?: string;
    /**
     * AddressBlock5
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'AddressBlock5'?: string;
    /**
     * AddressBlock6
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'AddressBlock6'?: string;
    /**
     * AddressBlock7
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'AddressBlock7'?: string;
    /**
     * AddressBlock8
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'AddressBlock8'?: string;
    /**
     * AddressBlock9
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'AddressBlock9'?: string;
    /**
     * Specifies whether the address is in English or French. This is for Canadian address only.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'CanLanguage'?: string;
    /**
     * Specifies whether the building is a no stat building and therefore unable to receive mail.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'DPVNoStat'?: string;
    /**
     * Specifies whether the building is vacant, unoccupied for 90 days.
     * @type {string}
     * @memberof ValidateMailingAddressUSCANAPIOutput
     */
    'DPVVacant'?: string;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressUSCANAPIRequest
 */
export interface ValidateMailingAddressUSCANAPIRequest {
    /**
     * 
     * @type {ValidateMailingAddressUSCANAPIOptions}
     * @memberof ValidateMailingAddressUSCANAPIRequest
     */
    'options'?: ValidateMailingAddressUSCANAPIOptions;
    /**
     * 
     * @type {ValidateMailingAddressUSCANAPIInput}
     * @memberof ValidateMailingAddressUSCANAPIRequest
     */
    'Input'?: ValidateMailingAddressUSCANAPIInput;
}
/**
 * 
 * @export
 * @interface ValidateMailingAddressUSCANAPIResponse
 */
export interface ValidateMailingAddressUSCANAPIResponse {
    /**
     * 
     * @type {Array<ValidateMailingAddressUSCANAPIOutput>}
     * @memberof ValidateMailingAddressUSCANAPIResponse
     */
    'Output'?: Array<ValidateMailingAddressUSCANAPIOutput>;
}
/**
 * 
 * @export
 * @interface ValidatePhoneNumberAPIRequest
 */
export interface ValidatePhoneNumberAPIRequest {
    /**
     * 
     * @type {ValidatePhoneNumberAPIRequestInput}
     * @memberof ValidatePhoneNumberAPIRequest
     */
    'Input'?: ValidatePhoneNumberAPIRequestInput;
}
/**
 * 
 * @export
 * @interface ValidatePhoneNumberAPIRequestInput
 */
export interface ValidatePhoneNumberAPIRequestInput {
    /**
     * 
     * @type {Array<ValidatePhoneNumberAPIRequestInputRow>}
     * @memberof ValidatePhoneNumberAPIRequestInput
     */
    'Row'?: Array<ValidatePhoneNumberAPIRequestInputRow>;
}
/**
 * 
 * @export
 * @interface ValidatePhoneNumberAPIRequestInputRow
 */
export interface ValidatePhoneNumberAPIRequestInputRow {
    /**
     * 
     * @type {string}
     * @memberof ValidatePhoneNumberAPIRequestInputRow
     */
    'PhoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidatePhoneNumberAPIRequestInputRow
     */
    'Country'?: string;
}
/**
 * 
 * @export
 * @interface WaterBody
 */
export interface WaterBody {
    /**
     * 
     * @type {string}
     * @memberof WaterBody
     */
    'name'?: string;
    /**
     * 
     * @type {ShoreLineDistance}
     * @memberof WaterBody
     */
    'distance'?: ShoreLineDistance;
    /**
     * 
     * @type {Type}
     * @memberof WaterBody
     */
    'type'?: Type;
}
/**
 * 
 * @export
 * @interface WaterBodyResponse
 */
export interface WaterBodyResponse {
    /**
     * 
     * @type {string}
     * @memberof WaterBodyResponse
     */
    'objectId'?: string;
    /**
     * 
     * @type {Array<WaterBody>}
     * @memberof WaterBodyResponse
     */
    'waterBody'?: Array<WaterBody>;
    /**
     * 
     * @type {RiskAddress}
     * @memberof WaterBodyResponse
     */
    'matchedAddress'?: RiskAddress;
}
/**
 * 
 * @export
 * @interface ZonesAddress
 */
export interface ZonesAddress {
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'streetSide'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'businessName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'addressLine1'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'addressLine2'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'addressLine3'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'stateProvince'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'county'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'latitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'longitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'urbanizationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'formattedAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'mainAddressLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'addressLastLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'placeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'areaName1'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'areaName2'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'areaName3'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'areaName4'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'postCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'postCodeExt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'addressNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'streetName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'unitType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesAddress
     */
    'unitValue'?: string;
}
/**
 * 
 * @export
 * @interface ZonesBoundaryGeometry
 */
export interface ZonesBoundaryGeometry {
    /**
     * 
     * @type {string}
     * @memberof ZonesBoundaryGeometry
     */
    'type'?: string;
    /**
     * 
     * @type {Array<Array<Array<number>>>}
     * @memberof ZonesBoundaryGeometry
     */
    'coordinates'?: Array<Array<Array<number>>>;
}
/**
 * 
 * @export
 * @interface ZonesContactDetails
 */
export interface ZonesContactDetails {
    /**
     * 
     * @type {ZonesAddress}
     * @memberof ZonesContactDetails
     */
    'address'?: ZonesAddress;
    /**
     * 
     * @type {ZonesAddress}
     * @memberof ZonesContactDetails
     */
    'propertyAddress'?: ZonesAddress;
}
/**
 * 
 * @export
 * @interface ZonesGeometry
 */
export interface ZonesGeometry {
    /**
     * 
     * @type {string}
     * @memberof ZonesGeometry
     */
    'type': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ZonesGeometry
     */
    'coordinates'?: Array<number>;
}
/**
 * 
 * @export
 * @interface ZonesParentBusiness
 */
export interface ZonesParentBusiness {
    /**
     * 
     * @type {string}
     * @memberof ZonesParentBusiness
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ZonesPoi
 */
export interface ZonesPoi {
    /**
     * 
     * @type {string}
     * @memberof ZonesPoi
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesPoi
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesPoi
     */
    'brandName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesPoi
     */
    'tradeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesPoi
     */
    'franchiseName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesPoi
     */
    'open24Hours'?: string;
    /**
     * 
     * @type {ZonesContactDetails}
     * @memberof ZonesPoi
     */
    'contactDetails'?: ZonesContactDetails;
    /**
     * 
     * @type {ZonesPoiClassification}
     * @memberof ZonesPoi
     */
    'poiClassification'?: ZonesPoiClassification;
    /**
     * 
     * @type {EmployeeCount}
     * @memberof ZonesPoi
     */
    'employeeCount'?: EmployeeCount;
    /**
     * 
     * @type {string}
     * @memberof ZonesPoi
     */
    'organizationStatusCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesPoi
     */
    'organizationStatusCodeDescription'?: string;
    /**
     * 
     * @type {ZonesParentBusiness}
     * @memberof ZonesPoi
     */
    'parentBusiness'?: ZonesParentBusiness;
    /**
     * 
     * @type {string}
     * @memberof ZonesPoi
     */
    'tickerSymbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesPoi
     */
    'exchangeName'?: string;
}
/**
 * 
 * @export
 * @interface ZonesPoiClassification
 */
export interface ZonesPoiClassification {
    /**
     * 
     * @type {ZonesSic}
     * @memberof ZonesPoiClassification
     */
    'sic'?: ZonesSic;
    /**
     * 
     * @type {Category}
     * @memberof ZonesPoiClassification
     */
    'category'?: Category;
    /**
     * 
     * @type {string}
     * @memberof ZonesPoiClassification
     */
    'alternateIndustryCode'?: string;
}
/**
 * 
 * @export
 * @interface ZonesPoiGeometry
 */
export interface ZonesPoiGeometry {
    /**
     * 
     * @type {string}
     * @memberof ZonesPoiGeometry
     */
    'type'?: string;
    /**
     * 
     * @type {GeometryCRC}
     * @memberof ZonesPoiGeometry
     */
    'crs'?: GeometryCRC;
    /**
     * 
     * @type {object}
     * @memberof ZonesPoiGeometry
     */
    'coordinates'?: object;
}
/**
 * 
 * @export
 * @interface ZonesSic
 */
export interface ZonesSic {
    /**
     * 
     * @type {string}
     * @memberof ZonesSic
     */
    'businessLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesSic
     */
    'sicCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesSic
     */
    'sicCodeDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZonesSic
     */
    'primarySicCode'?: string;
}

/**
 * AddressAutocompleteEnterpriseServiceApi - axios parameter creator
 * @export
 */
export const AddressAutocompleteEnterpriseServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} searchText The input to be searched.
         * @param {string} transactionId transactionId.
         * @param {string} [latitude] Latitude of the location. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {string} [longitude] Longitude of the location. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {string} [searchRadius] Radius range within which search is performed.
         * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters.
         * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved.
         * @param {string} [country] Country ISO code. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {string} [matchOnAddressNumber] Option so that we force api to match on address number
         * @param {string} [autoDetectLocation] Option to allow API to detect origin of API request automatically
         * @param {string} [ipAddress] 
         * @param {string} [areaName1] State province of the input to be searched
         * @param {string} [areaName3] City of the input to be searched
         * @param {string} [postCode] Postal Code of the input to be searched
         * @param {string} [returnAdminAreasOnly] if value set \&#39;Y\&#39; then it will only do a matching on postcode or areaName1, areaName2, areaName3 and areaName4 fields in the data
         * @param {string} [includeRangesDetails] if value set \&#39;Y\&#39; then display all unit info of ranges, if value set \&#39;N\&#39; then don\&#39;t show ranges
         * @param {string} [searchType] Preference to control search type of interactive requests.
         * @param {string} [searchOnAddressNumber] Preference to search on address number.
         * @param {string} [searchOnUnitInfo] Preference to search on unit info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLocations: async (searchText: string, transactionId: string, latitude?: string, longitude?: string, searchRadius?: string, searchRadiusUnit?: string, maxCandidates?: string, country?: string, matchOnAddressNumber?: string, autoDetectLocation?: string, ipAddress?: string, areaName1?: string, areaName3?: string, postCode?: string, returnAdminAreasOnly?: string, includeRangesDetails?: string, searchType?: string, searchOnAddressNumber?: string, searchOnUnitInfo?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchText' is not null or undefined
            assertParamExists('listLocations', 'searchText', searchText)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('listLocations', 'transactionId', transactionId)
            const localVarPath = `/typeahead/v1/list/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (searchRadius !== undefined) {
                localVarQueryParameter['searchRadius'] = searchRadius;
            }

            if (searchRadiusUnit !== undefined) {
                localVarQueryParameter['searchRadiusUnit'] = searchRadiusUnit;
            }

            if (maxCandidates !== undefined) {
                localVarQueryParameter['maxCandidates'] = maxCandidates;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (matchOnAddressNumber !== undefined) {
                localVarQueryParameter['matchOnAddressNumber'] = matchOnAddressNumber;
            }

            if (autoDetectLocation !== undefined) {
                localVarQueryParameter['autoDetectLocation'] = autoDetectLocation;
            }

            if (ipAddress !== undefined) {
                localVarQueryParameter['ipAddress'] = ipAddress;
            }

            if (areaName1 !== undefined) {
                localVarQueryParameter['areaName1'] = areaName1;
            }

            if (areaName3 !== undefined) {
                localVarQueryParameter['areaName3'] = areaName3;
            }

            if (postCode !== undefined) {
                localVarQueryParameter['postCode'] = postCode;
            }

            if (returnAdminAreasOnly !== undefined) {
                localVarQueryParameter['returnAdminAreasOnly'] = returnAdminAreasOnly;
            }

            if (includeRangesDetails !== undefined) {
                localVarQueryParameter['includeRangesDetails'] = includeRangesDetails;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['searchType'] = searchType;
            }

            if (searchOnAddressNumber !== undefined) {
                localVarQueryParameter['searchOnAddressNumber'] = searchOnAddressNumber;
            }

            if (transactionId !== undefined) {
                localVarQueryParameter['transactionId'] = transactionId;
            }

            if (searchOnUnitInfo !== undefined) {
                localVarQueryParameter['searchOnUnitInfo'] = searchOnUnitInfo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} selectedAddress Selected Address to be searched.
         * @param {string} transactionId transactionId.
         * @param {string} [country] Country ISO code. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSelect: async (selectedAddress: string, transactionId: string, country?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectedAddress' is not null or undefined
            assertParamExists('listSelect', 'selectedAddress', selectedAddress)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('listSelect', 'transactionId', transactionId)
            const localVarPath = `/typeahead/v1/list/select`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (selectedAddress !== undefined) {
                localVarQueryParameter['selectedAddress'] = selectedAddress;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (transactionId !== undefined) {
                localVarQueryParameter['transactionId'] = transactionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressAutocompleteEnterpriseServiceApi - functional programming interface
 * @export
 */
export const AddressAutocompleteEnterpriseServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = AddressAutocompleteEnterpriseServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * 
         * @param {string} searchText The input to be searched.
         * @param {string} transactionId transactionId.
         * @param {string} [latitude] Latitude of the location. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {string} [longitude] Longitude of the location. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {string} [searchRadius] Radius range within which search is performed.
         * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters.
         * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved.
         * @param {string} [country] Country ISO code. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {string} [matchOnAddressNumber] Option so that we force api to match on address number
         * @param {string} [autoDetectLocation] Option to allow API to detect origin of API request automatically
         * @param {string} [ipAddress] 
         * @param {string} [areaName1] State province of the input to be searched
         * @param {string} [areaName3] City of the input to be searched
         * @param {string} [postCode] Postal Code of the input to be searched
         * @param {string} [returnAdminAreasOnly] if value set \&#39;Y\&#39; then it will only do a matching on postcode or areaName1, areaName2, areaName3 and areaName4 fields in the data
         * @param {string} [includeRangesDetails] if value set \&#39;Y\&#39; then display all unit info of ranges, if value set \&#39;N\&#39; then don\&#39;t show ranges
         * @param {string} [searchType] Preference to control search type of interactive requests.
         * @param {string} [searchOnAddressNumber] Preference to search on address number.
         * @param {string} [searchOnUnitInfo] Preference to search on unit info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLocations(searchText: string, transactionId: string, latitude?: string, longitude?: string, searchRadius?: string, searchRadiusUnit?: string, maxCandidates?: string, country?: string, matchOnAddressNumber?: string, autoDetectLocation?: string, ipAddress?: string, areaName1?: string, areaName3?: string, postCode?: string, returnAdminAreasOnly?: string, includeRangesDetails?: string, searchType?: string, searchOnAddressNumber?: string, searchOnUnitInfo?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypeaheadLocations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLocations(searchText, transactionId, latitude, longitude, searchRadius, searchRadiusUnit, maxCandidates, country, matchOnAddressNumber, autoDetectLocation, ipAddress, areaName1, areaName3, postCode, returnAdminAreasOnly, includeRangesDetails, searchType, searchOnAddressNumber, searchOnUnitInfo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} selectedAddress Selected Address to be searched.
         * @param {string} transactionId transactionId.
         * @param {string} [country] Country ISO code. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSelect(selectedAddress: string, transactionId: string, country?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSelect(selectedAddress, transactionId, country, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddressAutocompleteEnterpriseServiceApi - factory interface
 * @export
 */
export const AddressAutocompleteEnterpriseServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressAutocompleteEnterpriseServiceApiFp(oAuth,configuration)
    return {
        /**
         * 
         * @param {string} searchText The input to be searched.
         * @param {string} transactionId transactionId.
         * @param {string} [latitude] Latitude of the location. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {string} [longitude] Longitude of the location. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {string} [searchRadius] Radius range within which search is performed.
         * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters.
         * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved.
         * @param {string} [country] Country ISO code. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {string} [matchOnAddressNumber] Option so that we force api to match on address number
         * @param {string} [autoDetectLocation] Option to allow API to detect origin of API request automatically
         * @param {string} [ipAddress] 
         * @param {string} [areaName1] State province of the input to be searched
         * @param {string} [areaName3] City of the input to be searched
         * @param {string} [postCode] Postal Code of the input to be searched
         * @param {string} [returnAdminAreasOnly] if value set \&#39;Y\&#39; then it will only do a matching on postcode or areaName1, areaName2, areaName3 and areaName4 fields in the data
         * @param {string} [includeRangesDetails] if value set \&#39;Y\&#39; then display all unit info of ranges, if value set \&#39;N\&#39; then don\&#39;t show ranges
         * @param {string} [searchType] Preference to control search type of interactive requests.
         * @param {string} [searchOnAddressNumber] Preference to search on address number.
         * @param {string} [searchOnUnitInfo] Preference to search on unit info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLocations(searchText: string, transactionId: string, latitude?: string, longitude?: string, searchRadius?: string, searchRadiusUnit?: string, maxCandidates?: string, country?: string, matchOnAddressNumber?: string, autoDetectLocation?: string, ipAddress?: string, areaName1?: string, areaName3?: string, postCode?: string, returnAdminAreasOnly?: string, includeRangesDetails?: string, searchType?: string, searchOnAddressNumber?: string, searchOnUnitInfo?: string, options?: any): AxiosPromise<TypeaheadLocations> {
            return localVarFp.listLocations(searchText, transactionId, latitude, longitude, searchRadius, searchRadiusUnit, maxCandidates, country, matchOnAddressNumber, autoDetectLocation, ipAddress, areaName1, areaName3, postCode, returnAdminAreasOnly, includeRangesDetails, searchType, searchOnAddressNumber, searchOnUnitInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} selectedAddress Selected Address to be searched.
         * @param {string} transactionId transactionId.
         * @param {string} [country] Country ISO code. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSelect(selectedAddress: string, transactionId: string, country?: string, options?: any): AxiosPromise<object> {
            return localVarFp.listSelect(selectedAddress, transactionId, country, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressAutocompleteEnterpriseServiceApi - object-oriented interface
 * @export
 * @class AddressAutocompleteEnterpriseServiceApi
 * @extends {BaseAPI}
 */
export class AddressAutocompleteEnterpriseServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} searchText The input to be searched.
     * @param {string} transactionId transactionId.
     * @param {string} [latitude] Latitude of the location. We need to make sure that either Lat/Lng or Country is provided to API
     * @param {string} [longitude] Longitude of the location. We need to make sure that either Lat/Lng or Country is provided to API
     * @param {string} [searchRadius] Radius range within which search is performed.
     * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters.
     * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved.
     * @param {string} [country] Country ISO code. We need to make sure that either Lat/Lng or Country is provided to API
     * @param {string} [matchOnAddressNumber] Option so that we force api to match on address number
     * @param {string} [autoDetectLocation] Option to allow API to detect origin of API request automatically
     * @param {string} [ipAddress] 
     * @param {string} [areaName1] State province of the input to be searched
     * @param {string} [areaName3] City of the input to be searched
     * @param {string} [postCode] Postal Code of the input to be searched
     * @param {string} [returnAdminAreasOnly] if value set \&#39;Y\&#39; then it will only do a matching on postcode or areaName1, areaName2, areaName3 and areaName4 fields in the data
     * @param {string} [includeRangesDetails] if value set \&#39;Y\&#39; then display all unit info of ranges, if value set \&#39;N\&#39; then don\&#39;t show ranges
     * @param {string} [searchType] Preference to control search type of interactive requests.
     * @param {string} [searchOnAddressNumber] Preference to search on address number.
     * @param {string} [searchOnUnitInfo] Preference to search on unit info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressAutocompleteEnterpriseServiceApi
     */
    public listLocations(searchText: string, transactionId: string, latitude?: string, longitude?: string, searchRadius?: string, searchRadiusUnit?: string, maxCandidates?: string, country?: string, matchOnAddressNumber?: string, autoDetectLocation?: string, ipAddress?: string, areaName1?: string, areaName3?: string, postCode?: string, returnAdminAreasOnly?: string, includeRangesDetails?: string, searchType?: string, searchOnAddressNumber?: string, searchOnUnitInfo?: string, options?: AxiosRequestConfig) {
        return AddressAutocompleteEnterpriseServiceApiFp(this.oAuthCred,this.configuration).listLocations(searchText, transactionId, latitude, longitude, searchRadius, searchRadiusUnit, maxCandidates, country, matchOnAddressNumber, autoDetectLocation, ipAddress, areaName1, areaName3, postCode, returnAdminAreasOnly, includeRangesDetails, searchType, searchOnAddressNumber, searchOnUnitInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} selectedAddress Selected Address to be searched.
     * @param {string} transactionId transactionId.
     * @param {string} [country] Country ISO code. We need to make sure that either Lat/Lng or Country is provided to API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressAutocompleteEnterpriseServiceApi
     */
    public listSelect(selectedAddress: string, transactionId: string, country?: string, options?: AxiosRequestConfig) {
        return AddressAutocompleteEnterpriseServiceApiFp(this.oAuthCred,this.configuration).listSelect(selectedAddress, transactionId, country, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AddressAutocompleteServiceApi - axios parameter creator
 * @export
 */
export const AddressAutocompleteServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * Performs search to retrieve list of places by input text and location vicinity.
         * @summary Address Autocomplete Search
         * @param {string} searchText The input to be searched.
         * @param {string} [latitude] Latitude of the location. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {string} [longitude] Longitude of the location. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {string} [searchRadius] Radius range within which search is performed.
         * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters.
         * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved.
         * @param {string} [country] Country ISO code. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {string} [matchOnAddressNumber] Option so that we force api to match on address number
         * @param {string} [autoDetectLocation] Option to allow API to detect origin of API request automatically
         * @param {string} [ipAddress] 
         * @param {string} [areaName1] State province of the input to be searched
         * @param {string} [areaName3] City of the input to be searched
         * @param {string} [postCode] Postal Code of the input to be searched
         * @param {string} [returnAdminAreasOnly] if value set \&#39;Y\&#39; then it will only do a matching on postcode or areaName1, areaName2, areaName3 and areaName4 fields in the data
         * @param {string} [includeRangesDetails] if value set \&#39;Y\&#39; then display all unit info of ranges, if value set \&#39;N\&#39; then don\&#39;t show ranges
         * @param {string} [searchType] Preference to control search type of interactive requests.
         * @param {string} [searchOnAddressNumber] Preference to search on address number.
         * @param {string} [searchOnUnitInfo] Preference to search on unit info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchV2: async (searchText: string, latitude?: string, longitude?: string, searchRadius?: string, searchRadiusUnit?: string, maxCandidates?: string, country?: string, matchOnAddressNumber?: string, autoDetectLocation?: string, ipAddress?: string, areaName1?: string, areaName3?: string, postCode?: string, returnAdminAreasOnly?: string, includeRangesDetails?: string, searchType?: string, searchOnAddressNumber?: string, searchOnUnitInfo?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchText' is not null or undefined
            assertParamExists('searchV2', 'searchText', searchText)
            const localVarPath = `/typeahead/v1/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (searchRadius !== undefined) {
                localVarQueryParameter['searchRadius'] = searchRadius;
            }

            if (searchRadiusUnit !== undefined) {
                localVarQueryParameter['searchRadiusUnit'] = searchRadiusUnit;
            }

            if (maxCandidates !== undefined) {
                localVarQueryParameter['maxCandidates'] = maxCandidates;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (matchOnAddressNumber !== undefined) {
                localVarQueryParameter['matchOnAddressNumber'] = matchOnAddressNumber;
            }

            if (autoDetectLocation !== undefined) {
                localVarQueryParameter['autoDetectLocation'] = autoDetectLocation;
            }

            if (ipAddress !== undefined) {
                localVarQueryParameter['ipAddress'] = ipAddress;
            }

            if (areaName1 !== undefined) {
                localVarQueryParameter['areaName1'] = areaName1;
            }

            if (areaName3 !== undefined) {
                localVarQueryParameter['areaName3'] = areaName3;
            }

            if (postCode !== undefined) {
                localVarQueryParameter['postCode'] = postCode;
            }

            if (returnAdminAreasOnly !== undefined) {
                localVarQueryParameter['returnAdminAreasOnly'] = returnAdminAreasOnly;
            }

            if (includeRangesDetails !== undefined) {
                localVarQueryParameter['includeRangesDetails'] = includeRangesDetails;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['searchType'] = searchType;
            }

            if (searchOnAddressNumber !== undefined) {
                localVarQueryParameter['searchOnAddressNumber'] = searchOnAddressNumber;
            }

            if (searchOnUnitInfo !== undefined) {
                localVarQueryParameter['searchOnUnitInfo'] = searchOnUnitInfo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressAutocompleteServiceApi - functional programming interface
 * @export
 */
export const AddressAutocompleteServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = AddressAutocompleteServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * Performs search to retrieve list of places by input text and location vicinity.
         * @summary Address Autocomplete Search
         * @param {string} searchText The input to be searched.
         * @param {string} [latitude] Latitude of the location. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {string} [longitude] Longitude of the location. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {string} [searchRadius] Radius range within which search is performed.
         * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters.
         * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved.
         * @param {string} [country] Country ISO code. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {string} [matchOnAddressNumber] Option so that we force api to match on address number
         * @param {string} [autoDetectLocation] Option to allow API to detect origin of API request automatically
         * @param {string} [ipAddress] 
         * @param {string} [areaName1] State province of the input to be searched
         * @param {string} [areaName3] City of the input to be searched
         * @param {string} [postCode] Postal Code of the input to be searched
         * @param {string} [returnAdminAreasOnly] if value set \&#39;Y\&#39; then it will only do a matching on postcode or areaName1, areaName2, areaName3 and areaName4 fields in the data
         * @param {string} [includeRangesDetails] if value set \&#39;Y\&#39; then display all unit info of ranges, if value set \&#39;N\&#39; then don\&#39;t show ranges
         * @param {string} [searchType] Preference to control search type of interactive requests.
         * @param {string} [searchOnAddressNumber] Preference to search on address number.
         * @param {string} [searchOnUnitInfo] Preference to search on unit info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchV2(searchText: string, latitude?: string, longitude?: string, searchRadius?: string, searchRadiusUnit?: string, maxCandidates?: string, country?: string, matchOnAddressNumber?: string, autoDetectLocation?: string, ipAddress?: string, areaName1?: string, areaName3?: string, postCode?: string, returnAdminAreasOnly?: string, includeRangesDetails?: string, searchType?: string, searchOnAddressNumber?: string, searchOnUnitInfo?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypeaheadLocations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchV2(searchText, latitude, longitude, searchRadius, searchRadiusUnit, maxCandidates, country, matchOnAddressNumber, autoDetectLocation, ipAddress, areaName1, areaName3, postCode, returnAdminAreasOnly, includeRangesDetails, searchType, searchOnAddressNumber, searchOnUnitInfo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddressAutocompleteServiceApi - factory interface
 * @export
 */
export const AddressAutocompleteServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressAutocompleteServiceApiFp(oAuth,configuration)
    return {
        /**
         * Performs search to retrieve list of places by input text and location vicinity.
         * @summary Address Autocomplete Search
         * @param {string} searchText The input to be searched.
         * @param {string} [latitude] Latitude of the location. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {string} [longitude] Longitude of the location. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {string} [searchRadius] Radius range within which search is performed.
         * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters.
         * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved.
         * @param {string} [country] Country ISO code. We need to make sure that either Lat/Lng or Country is provided to API
         * @param {string} [matchOnAddressNumber] Option so that we force api to match on address number
         * @param {string} [autoDetectLocation] Option to allow API to detect origin of API request automatically
         * @param {string} [ipAddress] 
         * @param {string} [areaName1] State province of the input to be searched
         * @param {string} [areaName3] City of the input to be searched
         * @param {string} [postCode] Postal Code of the input to be searched
         * @param {string} [returnAdminAreasOnly] if value set \&#39;Y\&#39; then it will only do a matching on postcode or areaName1, areaName2, areaName3 and areaName4 fields in the data
         * @param {string} [includeRangesDetails] if value set \&#39;Y\&#39; then display all unit info of ranges, if value set \&#39;N\&#39; then don\&#39;t show ranges
         * @param {string} [searchType] Preference to control search type of interactive requests.
         * @param {string} [searchOnAddressNumber] Preference to search on address number.
         * @param {string} [searchOnUnitInfo] Preference to search on unit info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchV2(searchText: string, latitude?: string, longitude?: string, searchRadius?: string, searchRadiusUnit?: string, maxCandidates?: string, country?: string, matchOnAddressNumber?: string, autoDetectLocation?: string, ipAddress?: string, areaName1?: string, areaName3?: string, postCode?: string, returnAdminAreasOnly?: string, includeRangesDetails?: string, searchType?: string, searchOnAddressNumber?: string, searchOnUnitInfo?: string, options?: any): AxiosPromise<TypeaheadLocations> {
            return localVarFp.searchV2(searchText, latitude, longitude, searchRadius, searchRadiusUnit, maxCandidates, country, matchOnAddressNumber, autoDetectLocation, ipAddress, areaName1, areaName3, postCode, returnAdminAreasOnly, includeRangesDetails, searchType, searchOnAddressNumber, searchOnUnitInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressAutocompleteServiceApi - object-oriented interface
 * @export
 * @class AddressAutocompleteServiceApi
 * @extends {BaseAPI}
 */
export class AddressAutocompleteServiceApi extends BaseAPI {
    /**
     * Performs search to retrieve list of places by input text and location vicinity.
     * @summary Address Autocomplete Search
     * @param {string} searchText The input to be searched.
     * @param {string} [latitude] Latitude of the location. We need to make sure that either Lat/Lng or Country is provided to API
     * @param {string} [longitude] Longitude of the location. We need to make sure that either Lat/Lng or Country is provided to API
     * @param {string} [searchRadius] Radius range within which search is performed.
     * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters.
     * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved.
     * @param {string} [country] Country ISO code. We need to make sure that either Lat/Lng or Country is provided to API
     * @param {string} [matchOnAddressNumber] Option so that we force api to match on address number
     * @param {string} [autoDetectLocation] Option to allow API to detect origin of API request automatically
     * @param {string} [ipAddress] 
     * @param {string} [areaName1] State province of the input to be searched
     * @param {string} [areaName3] City of the input to be searched
     * @param {string} [postCode] Postal Code of the input to be searched
     * @param {string} [returnAdminAreasOnly] if value set \&#39;Y\&#39; then it will only do a matching on postcode or areaName1, areaName2, areaName3 and areaName4 fields in the data
     * @param {string} [includeRangesDetails] if value set \&#39;Y\&#39; then display all unit info of ranges, if value set \&#39;N\&#39; then don\&#39;t show ranges
     * @param {string} [searchType] Preference to control search type of interactive requests.
     * @param {string} [searchOnAddressNumber] Preference to search on address number.
     * @param {string} [searchOnUnitInfo] Preference to search on unit info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressAutocompleteServiceApi
     */
    public searchV2(searchText: string, latitude?: string, longitude?: string, searchRadius?: string, searchRadiusUnit?: string, maxCandidates?: string, country?: string, matchOnAddressNumber?: string, autoDetectLocation?: string, ipAddress?: string, areaName1?: string, areaName3?: string, postCode?: string, returnAdminAreasOnly?: string, includeRangesDetails?: string, searchType?: string, searchOnAddressNumber?: string, searchOnUnitInfo?: string, options?: AxiosRequestConfig) {
        return AddressAutocompleteServiceApiFp(this.oAuthCred,this.configuration).searchV2(searchText, latitude, longitude, searchRadius, searchRadiusUnit, maxCandidates, country, matchOnAddressNumber, autoDetectLocation, ipAddress, areaName1, areaName3, postCode, returnAdminAreasOnly, includeRangesDetails, searchType, searchOnAddressNumber, searchOnUnitInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AddressVerificationServiceApi - axios parameter creator
 * @export
 */
export const AddressVerificationServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * GetCityStateProvince returns a city and state/province for a given input postal code for U.S. and Canadian addresses.
         * @summary GetCityStateProvince
         * @param {GetCityStateProvinceAPIRequest} inputAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCityStateProvince: async (inputAddress: GetCityStateProvinceAPIRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inputAddress' is not null or undefined
            assertParamExists('getCityStateProvince', 'inputAddress', inputAddress)
            const localVarPath = `/addressverification/v1/getcitystateprovince/results.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inputAddress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GetPostalCodes takes a city and state as input for U.S. addresses and returns the postal codes for that city.
         * @summary GetPostalCodes
         * @param {GetPostalCodesAPIRequest} inputAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostalCodes: async (inputAddress: GetPostalCodesAPIRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inputAddress' is not null or undefined
            assertParamExists('getPostalCodes', 'inputAddress', inputAddress)
            const localVarPath = `/addressverification/v1/getpostalcodes/results.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inputAddress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ValidateMailingAddress analyses and compares the input addresses against the known address databases around the world to output a standardized detail.
         * @summary ValidateMailingAddress
         * @param {ValidateMailingAddressRequest} inputAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateMailingAddress: async (inputAddress: ValidateMailingAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inputAddress' is not null or undefined
            assertParamExists('validateMailingAddress', 'inputAddress', inputAddress)
            const localVarPath = `/addressverification/v1/validatemailingaddress/results.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inputAddress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ValidateMailing AddressPremium expands on the ValidateMailingAddressPro service by adding premium address data sources to get the best address validation result possible.
         * @summary ValidateMailingAddressPremium
         * @param {ValidateMailingAddressPremiumRequest} inputAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateMailingAddressPremium: async (inputAddress: ValidateMailingAddressPremiumRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inputAddress' is not null or undefined
            assertParamExists('validateMailingAddressPremium', 'inputAddress', inputAddress)
            const localVarPath = `/addressverification/v1/validatemailingaddresspremium/results.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inputAddress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ValidateMailingAddressPro builds upon the ValidateMailingAddress service by using additional address databases so it can provide enhanced detail.
         * @summary ValidateMailingAddressPro
         * @param {ValidateMailingAddressProRequest} inputAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateMailingAddressPro: async (inputAddress: ValidateMailingAddressProRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inputAddress' is not null or undefined
            assertParamExists('validateMailingAddressPro', 'inputAddress', inputAddress)
            const localVarPath = `/addressverification/v1/validatemailingaddresspro/results.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inputAddress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ValidateMailingAddressUSCAN analyses and compares the input addresses against the known address databases around the world to output a standardized detail for US and CANADAIt gives RDI and DPV also along with other US/CAN specific functionalities.
         * @summary ValidateMailingAddressUSCAN
         * @param {ValidateMailingAddressUSCANAPIRequest} inputAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateMailingAddressUSCAN: async (inputAddress: ValidateMailingAddressUSCANAPIRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inputAddress' is not null or undefined
            assertParamExists('validateMailingAddressUSCAN', 'inputAddress', inputAddress)
            const localVarPath = `/addressverification/v1/validatemailingaddressuscan/results.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inputAddress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressVerificationServiceApi - functional programming interface
 * @export
 */
export const AddressVerificationServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = AddressVerificationServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * GetCityStateProvince returns a city and state/province for a given input postal code for U.S. and Canadian addresses.
         * @summary GetCityStateProvince
         * @param {GetCityStateProvinceAPIRequest} inputAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCityStateProvince(inputAddress: GetCityStateProvinceAPIRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCityStateProvinceAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCityStateProvince(inputAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * GetPostalCodes takes a city and state as input for U.S. addresses and returns the postal codes for that city.
         * @summary GetPostalCodes
         * @param {GetPostalCodesAPIRequest} inputAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostalCodes(inputAddress: GetPostalCodesAPIRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPostalCodesAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostalCodes(inputAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ValidateMailingAddress analyses and compares the input addresses against the known address databases around the world to output a standardized detail.
         * @summary ValidateMailingAddress
         * @param {ValidateMailingAddressRequest} inputAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateMailingAddress(inputAddress: ValidateMailingAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateMailingAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateMailingAddress(inputAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ValidateMailing AddressPremium expands on the ValidateMailingAddressPro service by adding premium address data sources to get the best address validation result possible.
         * @summary ValidateMailingAddressPremium
         * @param {ValidateMailingAddressPremiumRequest} inputAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateMailingAddressPremium(inputAddress: ValidateMailingAddressPremiumRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateMailingAddressPremiumResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateMailingAddressPremium(inputAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ValidateMailingAddressPro builds upon the ValidateMailingAddress service by using additional address databases so it can provide enhanced detail.
         * @summary ValidateMailingAddressPro
         * @param {ValidateMailingAddressProRequest} inputAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateMailingAddressPro(inputAddress: ValidateMailingAddressProRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateMailingAddressProResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateMailingAddressPro(inputAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ValidateMailingAddressUSCAN analyses and compares the input addresses against the known address databases around the world to output a standardized detail for US and CANADAIt gives RDI and DPV also along with other US/CAN specific functionalities.
         * @summary ValidateMailingAddressUSCAN
         * @param {ValidateMailingAddressUSCANAPIRequest} inputAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateMailingAddressUSCAN(inputAddress: ValidateMailingAddressUSCANAPIRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateMailingAddressUSCANAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateMailingAddressUSCAN(inputAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddressVerificationServiceApi - factory interface
 * @export
 */
export const AddressVerificationServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressVerificationServiceApiFp(oAuth,configuration)
    return {
        /**
         * GetCityStateProvince returns a city and state/province for a given input postal code for U.S. and Canadian addresses.
         * @summary GetCityStateProvince
         * @param {GetCityStateProvinceAPIRequest} inputAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCityStateProvince(inputAddress: GetCityStateProvinceAPIRequest, options?: any): AxiosPromise<GetCityStateProvinceAPIResponse> {
            return localVarFp.getCityStateProvince(inputAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * GetPostalCodes takes a city and state as input for U.S. addresses and returns the postal codes for that city.
         * @summary GetPostalCodes
         * @param {GetPostalCodesAPIRequest} inputAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostalCodes(inputAddress: GetPostalCodesAPIRequest, options?: any): AxiosPromise<GetPostalCodesAPIResponse> {
            return localVarFp.getPostalCodes(inputAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * ValidateMailingAddress analyses and compares the input addresses against the known address databases around the world to output a standardized detail.
         * @summary ValidateMailingAddress
         * @param {ValidateMailingAddressRequest} inputAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateMailingAddress(inputAddress: ValidateMailingAddressRequest, options?: any): AxiosPromise<ValidateMailingAddressResponse> {
            return localVarFp.validateMailingAddress(inputAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * ValidateMailing AddressPremium expands on the ValidateMailingAddressPro service by adding premium address data sources to get the best address validation result possible.
         * @summary ValidateMailingAddressPremium
         * @param {ValidateMailingAddressPremiumRequest} inputAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateMailingAddressPremium(inputAddress: ValidateMailingAddressPremiumRequest, options?: any): AxiosPromise<ValidateMailingAddressPremiumResponse> {
            return localVarFp.validateMailingAddressPremium(inputAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * ValidateMailingAddressPro builds upon the ValidateMailingAddress service by using additional address databases so it can provide enhanced detail.
         * @summary ValidateMailingAddressPro
         * @param {ValidateMailingAddressProRequest} inputAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateMailingAddressPro(inputAddress: ValidateMailingAddressProRequest, options?: any): AxiosPromise<ValidateMailingAddressProResponse> {
            return localVarFp.validateMailingAddressPro(inputAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * ValidateMailingAddressUSCAN analyses and compares the input addresses against the known address databases around the world to output a standardized detail for US and CANADAIt gives RDI and DPV also along with other US/CAN specific functionalities.
         * @summary ValidateMailingAddressUSCAN
         * @param {ValidateMailingAddressUSCANAPIRequest} inputAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateMailingAddressUSCAN(inputAddress: ValidateMailingAddressUSCANAPIRequest, options?: any): AxiosPromise<ValidateMailingAddressUSCANAPIResponse> {
            return localVarFp.validateMailingAddressUSCAN(inputAddress, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressVerificationServiceApi - object-oriented interface
 * @export
 * @class AddressVerificationServiceApi
 * @extends {BaseAPI}
 */
export class AddressVerificationServiceApi extends BaseAPI {
    /**
     * GetCityStateProvince returns a city and state/province for a given input postal code for U.S. and Canadian addresses.
     * @summary GetCityStateProvince
     * @param {GetCityStateProvinceAPIRequest} inputAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressVerificationServiceApi
     */
    public getCityStateProvince(inputAddress: GetCityStateProvinceAPIRequest, options?: AxiosRequestConfig) {
        return AddressVerificationServiceApiFp(this.oAuthCred,this.configuration).getCityStateProvince(inputAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GetPostalCodes takes a city and state as input for U.S. addresses and returns the postal codes for that city.
     * @summary GetPostalCodes
     * @param {GetPostalCodesAPIRequest} inputAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressVerificationServiceApi
     */
    public getPostalCodes(inputAddress: GetPostalCodesAPIRequest, options?: AxiosRequestConfig) {
        return AddressVerificationServiceApiFp(this.oAuthCred,this.configuration).getPostalCodes(inputAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ValidateMailingAddress analyses and compares the input addresses against the known address databases around the world to output a standardized detail.
     * @summary ValidateMailingAddress
     * @param {ValidateMailingAddressRequest} inputAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressVerificationServiceApi
     */
    public validateMailingAddress(inputAddress: ValidateMailingAddressRequest, options?: AxiosRequestConfig) {
        return AddressVerificationServiceApiFp(this.oAuthCred,this.configuration).validateMailingAddress(inputAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ValidateMailing AddressPremium expands on the ValidateMailingAddressPro service by adding premium address data sources to get the best address validation result possible.
     * @summary ValidateMailingAddressPremium
     * @param {ValidateMailingAddressPremiumRequest} inputAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressVerificationServiceApi
     */
    public validateMailingAddressPremium(inputAddress: ValidateMailingAddressPremiumRequest, options?: AxiosRequestConfig) {
        return AddressVerificationServiceApiFp(this.oAuthCred,this.configuration).validateMailingAddressPremium(inputAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ValidateMailingAddressPro builds upon the ValidateMailingAddress service by using additional address databases so it can provide enhanced detail.
     * @summary ValidateMailingAddressPro
     * @param {ValidateMailingAddressProRequest} inputAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressVerificationServiceApi
     */
    public validateMailingAddressPro(inputAddress: ValidateMailingAddressProRequest, options?: AxiosRequestConfig) {
        return AddressVerificationServiceApiFp(this.oAuthCred,this.configuration).validateMailingAddressPro(inputAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ValidateMailingAddressUSCAN analyses and compares the input addresses against the known address databases around the world to output a standardized detail for US and CANADAIt gives RDI and DPV also along with other US/CAN specific functionalities.
     * @summary ValidateMailingAddressUSCAN
     * @param {ValidateMailingAddressUSCANAPIRequest} inputAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressVerificationServiceApi
     */
    public validateMailingAddressUSCAN(inputAddress: ValidateMailingAddressUSCANAPIRequest, options?: AxiosRequestConfig) {
        return AddressVerificationServiceApiFp(this.oAuthCred,this.configuration).validateMailingAddressUSCAN(inputAddress, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AddressesServiceApi - axios parameter creator
 * @export
 */
export const AddressesServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * This service accepts zip code, neighborhood, county, or city names, and returns the total number of addresses associated with these names.
         * @summary Addresses Count by Boundary Name.
         * @param {string} country Name of country. Acceptable values are CAN, USA.
         * @param {string} [areaName1] Specifies the largest geographical area, typically a state or province.
         * @param {string} [areaName2] Specifies the secondary geographic area, typically a county or district.
         * @param {string} [areaName3] Specifies a city or town name.
         * @param {string} [areaName4] Specifies a city subdivision or locality/neighborhood.
         * @param {string} [postCode] Specifies the postcode (ZIP code) in the appropriate format for the country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressesCountByBoundaryName: async (country: string, areaName1?: string, areaName2?: string, areaName3?: string, areaName4?: string, postCode?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('getAddressesCountByBoundaryName', 'country', country)
            const localVarPath = `/addresses/v1/addresscount/byboundaryname`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (areaName1 !== undefined) {
                localVarQueryParameter['areaName1'] = areaName1;
            }

            if (areaName2 !== undefined) {
                localVarQueryParameter['areaName2'] = areaName2;
            }

            if (areaName3 !== undefined) {
                localVarQueryParameter['areaName3'] = areaName3;
            }

            if (areaName4 !== undefined) {
                localVarQueryParameter['areaName4'] = areaName4;
            }

            if (postCode !== undefined) {
                localVarQueryParameter['postCode'] = postCode;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service accepts custom geographic boundaries or drive time & drive distance, returns the total number of addresses within these boundaries.
         * @summary Addresses count by Boundary.
         * @param {AddressesByBoundaryRequest} addressesByBoundaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressesCountbyBoundary: async (addressesByBoundaryRequest: AddressesByBoundaryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressesByBoundaryRequest' is not null or undefined
            assertParamExists('getAddressesCountbyBoundary', 'addressesByBoundaryRequest', addressesByBoundaryRequest)
            const localVarPath = `/addresses/v1/addresscount/byboundary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressesByBoundaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service accepts custom geographic boundaries or drive time & drive distance, returns all known & valid addresses within these boundaries.
         * @summary Addresses by Boundary.
         * @param {AddressesByBoundaryRequest} addressesByBoundaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressesbyBoundary: async (addressesByBoundaryRequest: AddressesByBoundaryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressesByBoundaryRequest' is not null or undefined
            assertParamExists('getAddressesbyBoundary', 'addressesByBoundaryRequest', addressesByBoundaryRequest)
            const localVarPath = `/addresses/v1/address/byboundary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressesByBoundaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service accepts zip code, neighborhood, county, or city names, and returns all known & valid addresses associated with these names.
         * @summary Addresses by Boundary Name.
         * @param {string} country Name of country. Acceptable values are CAN, USA.
         * @param {string} [areaName1] Specifies the largest geographical area, typically a state or province.
         * @param {string} [areaName2] Specifies the secondary geographic area, typically a county or district.
         * @param {string} [areaName3] Specifies a city or town name.
         * @param {string} [areaName4] Specifies a city subdivision or locality/neighborhood.
         * @param {string} [postCode] Specifies the postcode (ZIP code) in the appropriate format for the country.
         * @param {string} [maxCandidates] Maximum number of addresses to be returned in response. Max. value is 100 for XML/JSON, and 2000 for CSV.
         * @param {string} [page] Response will indicate the page number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressesbyBoundaryName: async (country: string, areaName1?: string, areaName2?: string, areaName3?: string, areaName4?: string, postCode?: string, maxCandidates?: string, page?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('getAddressesbyBoundaryName', 'country', country)
            const localVarPath = `/addresses/v1/address/byboundaryname`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (areaName1 !== undefined) {
                localVarQueryParameter['areaName1'] = areaName1;
            }

            if (areaName2 !== undefined) {
                localVarQueryParameter['areaName2'] = areaName2;
            }

            if (areaName3 !== undefined) {
                localVarQueryParameter['areaName3'] = areaName3;
            }

            if (areaName4 !== undefined) {
                localVarQueryParameter['areaName4'] = areaName4;
            }

            if (postCode !== undefined) {
                localVarQueryParameter['postCode'] = postCode;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (maxCandidates !== undefined) {
                localVarQueryParameter['maxCandidates'] = maxCandidates;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressesServiceApi - functional programming interface
 * @export
 */
export const AddressesServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = AddressesServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * This service accepts zip code, neighborhood, county, or city names, and returns the total number of addresses associated with these names.
         * @summary Addresses Count by Boundary Name.
         * @param {string} country Name of country. Acceptable values are CAN, USA.
         * @param {string} [areaName1] Specifies the largest geographical area, typically a state or province.
         * @param {string} [areaName2] Specifies the secondary geographic area, typically a county or district.
         * @param {string} [areaName3] Specifies a city or town name.
         * @param {string} [areaName4] Specifies a city subdivision or locality/neighborhood.
         * @param {string} [postCode] Specifies the postcode (ZIP code) in the appropriate format for the country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressesCountByBoundaryName(country: string, areaName1?: string, areaName2?: string, areaName3?: string, areaName4?: string, postCode?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressesCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressesCountByBoundaryName(country, areaName1, areaName2, areaName3, areaName4, postCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This service accepts custom geographic boundaries or drive time & drive distance, returns the total number of addresses within these boundaries.
         * @summary Addresses count by Boundary.
         * @param {AddressesByBoundaryRequest} addressesByBoundaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressesCountbyBoundary(addressesByBoundaryRequest: AddressesByBoundaryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressesCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressesCountbyBoundary(addressesByBoundaryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This service accepts custom geographic boundaries or drive time & drive distance, returns all known & valid addresses within these boundaries.
         * @summary Addresses by Boundary.
         * @param {AddressesByBoundaryRequest} addressesByBoundaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressesbyBoundary(addressesByBoundaryRequest: AddressesByBoundaryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressesbyBoundary(addressesByBoundaryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This service accepts zip code, neighborhood, county, or city names, and returns all known & valid addresses associated with these names.
         * @summary Addresses by Boundary Name.
         * @param {string} country Name of country. Acceptable values are CAN, USA.
         * @param {string} [areaName1] Specifies the largest geographical area, typically a state or province.
         * @param {string} [areaName2] Specifies the secondary geographic area, typically a county or district.
         * @param {string} [areaName3] Specifies a city or town name.
         * @param {string} [areaName4] Specifies a city subdivision or locality/neighborhood.
         * @param {string} [postCode] Specifies the postcode (ZIP code) in the appropriate format for the country.
         * @param {string} [maxCandidates] Maximum number of addresses to be returned in response. Max. value is 100 for XML/JSON, and 2000 for CSV.
         * @param {string} [page] Response will indicate the page number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressesbyBoundaryName(country: string, areaName1?: string, areaName2?: string, areaName3?: string, areaName4?: string, postCode?: string, maxCandidates?: string, page?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressesbyBoundaryName(country, areaName1, areaName2, areaName3, areaName4, postCode, maxCandidates, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddressesServiceApi - factory interface
 * @export
 */
export const AddressesServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressesServiceApiFp(oAuth,configuration)
    return {
        /**
         * This service accepts zip code, neighborhood, county, or city names, and returns the total number of addresses associated with these names.
         * @summary Addresses Count by Boundary Name.
         * @param {string} country Name of country. Acceptable values are CAN, USA.
         * @param {string} [areaName1] Specifies the largest geographical area, typically a state or province.
         * @param {string} [areaName2] Specifies the secondary geographic area, typically a county or district.
         * @param {string} [areaName3] Specifies a city or town name.
         * @param {string} [areaName4] Specifies a city subdivision or locality/neighborhood.
         * @param {string} [postCode] Specifies the postcode (ZIP code) in the appropriate format for the country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressesCountByBoundaryName(country: string, areaName1?: string, areaName2?: string, areaName3?: string, areaName4?: string, postCode?: string, options?: any): AxiosPromise<AddressesCount> {
            return localVarFp.getAddressesCountByBoundaryName(country, areaName1, areaName2, areaName3, areaName4, postCode, options).then((request) => request(axios, basePath));
        },
        /**
         * This service accepts custom geographic boundaries or drive time & drive distance, returns the total number of addresses within these boundaries.
         * @summary Addresses count by Boundary.
         * @param {AddressesByBoundaryRequest} addressesByBoundaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressesCountbyBoundary(addressesByBoundaryRequest: AddressesByBoundaryRequest, options?: any): AxiosPromise<AddressesCount> {
            return localVarFp.getAddressesCountbyBoundary(addressesByBoundaryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This service accepts custom geographic boundaries or drive time & drive distance, returns all known & valid addresses within these boundaries.
         * @summary Addresses by Boundary.
         * @param {AddressesByBoundaryRequest} addressesByBoundaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressesbyBoundary(addressesByBoundaryRequest: AddressesByBoundaryRequest, options?: any): AxiosPromise<AddressesResponse> {
            return localVarFp.getAddressesbyBoundary(addressesByBoundaryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This service accepts zip code, neighborhood, county, or city names, and returns all known & valid addresses associated with these names.
         * @summary Addresses by Boundary Name.
         * @param {string} country Name of country. Acceptable values are CAN, USA.
         * @param {string} [areaName1] Specifies the largest geographical area, typically a state or province.
         * @param {string} [areaName2] Specifies the secondary geographic area, typically a county or district.
         * @param {string} [areaName3] Specifies a city or town name.
         * @param {string} [areaName4] Specifies a city subdivision or locality/neighborhood.
         * @param {string} [postCode] Specifies the postcode (ZIP code) in the appropriate format for the country.
         * @param {string} [maxCandidates] Maximum number of addresses to be returned in response. Max. value is 100 for XML/JSON, and 2000 for CSV.
         * @param {string} [page] Response will indicate the page number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressesbyBoundaryName(country: string, areaName1?: string, areaName2?: string, areaName3?: string, areaName4?: string, postCode?: string, maxCandidates?: string, page?: string, options?: any): AxiosPromise<AddressesResponse> {
            return localVarFp.getAddressesbyBoundaryName(country, areaName1, areaName2, areaName3, areaName4, postCode, maxCandidates, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressesServiceApi - object-oriented interface
 * @export
 * @class AddressesServiceApi
 * @extends {BaseAPI}
 */
export class AddressesServiceApi extends BaseAPI {
    /**
     * This service accepts zip code, neighborhood, county, or city names, and returns the total number of addresses associated with these names.
     * @summary Addresses Count by Boundary Name.
     * @param {string} country Name of country. Acceptable values are CAN, USA.
     * @param {string} [areaName1] Specifies the largest geographical area, typically a state or province.
     * @param {string} [areaName2] Specifies the secondary geographic area, typically a county or district.
     * @param {string} [areaName3] Specifies a city or town name.
     * @param {string} [areaName4] Specifies a city subdivision or locality/neighborhood.
     * @param {string} [postCode] Specifies the postcode (ZIP code) in the appropriate format for the country.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesServiceApi
     */
    public getAddressesCountByBoundaryName(country: string, areaName1?: string, areaName2?: string, areaName3?: string, areaName4?: string, postCode?: string, options?: AxiosRequestConfig) {
        return AddressesServiceApiFp(this.oAuthCred,this.configuration).getAddressesCountByBoundaryName(country, areaName1, areaName2, areaName3, areaName4, postCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service accepts custom geographic boundaries or drive time & drive distance, returns the total number of addresses within these boundaries.
     * @summary Addresses count by Boundary.
     * @param {AddressesByBoundaryRequest} addressesByBoundaryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesServiceApi
     */
    public getAddressesCountbyBoundary(addressesByBoundaryRequest: AddressesByBoundaryRequest, options?: AxiosRequestConfig) {
        return AddressesServiceApiFp(this.oAuthCred,this.configuration).getAddressesCountbyBoundary(addressesByBoundaryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service accepts custom geographic boundaries or drive time & drive distance, returns all known & valid addresses within these boundaries.
     * @summary Addresses by Boundary.
     * @param {AddressesByBoundaryRequest} addressesByBoundaryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesServiceApi
     */
    public getAddressesbyBoundary(addressesByBoundaryRequest: AddressesByBoundaryRequest, options?: AxiosRequestConfig) {
        return AddressesServiceApiFp(this.oAuthCred,this.configuration).getAddressesbyBoundary(addressesByBoundaryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service accepts zip code, neighborhood, county, or city names, and returns all known & valid addresses associated with these names.
     * @summary Addresses by Boundary Name.
     * @param {string} country Name of country. Acceptable values are CAN, USA.
     * @param {string} [areaName1] Specifies the largest geographical area, typically a state or province.
     * @param {string} [areaName2] Specifies the secondary geographic area, typically a county or district.
     * @param {string} [areaName3] Specifies a city or town name.
     * @param {string} [areaName4] Specifies a city subdivision or locality/neighborhood.
     * @param {string} [postCode] Specifies the postcode (ZIP code) in the appropriate format for the country.
     * @param {string} [maxCandidates] Maximum number of addresses to be returned in response. Max. value is 100 for XML/JSON, and 2000 for CSV.
     * @param {string} [page] Response will indicate the page number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesServiceApi
     */
    public getAddressesbyBoundaryName(country: string, areaName1?: string, areaName2?: string, areaName3?: string, areaName4?: string, postCode?: string, maxCandidates?: string, page?: string, options?: AxiosRequestConfig) {
        return AddressesServiceApiFp(this.oAuthCred,this.configuration).getAddressesbyBoundaryName(country, areaName1, areaName2, areaName3, areaName4, postCode, maxCandidates, page, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DemographicsServiceApi - axios parameter creator
 * @export
 */
export const DemographicsServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * Demographics Advanced Endpoint will return the aggregated values of the selected demographics variables of the regions falling inside a user provided geometry or travel time/distance boundaries. All the intersecting demographic boundaries will be snapped completely, and user will have option to request these boundaries in response.  
         * @summary Demographics Advanced Endpoint
         * @param {DemographicsAdvancedRequest} demographicsAdvancedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDemographicsAdvanced: async (demographicsAdvancedRequest: DemographicsAdvancedRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'demographicsAdvancedRequest' is not null or undefined
            assertParamExists('getDemographicsAdvanced', 'demographicsAdvancedRequest', demographicsAdvancedRequest)
            const localVarPath = `/demographics-segmentation/v1/advanced/demographics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(demographicsAdvancedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Demographics Basic Endpoint will return the aggregated values of the selected demographics variables of the regions falling inside the search radius. All the intersecting demographic boundaries will be snapped completely and user will have option to request these boundaries in response.  
         * @summary Demographics Basic
         * @param {string} [address] Address to be searched
         * @param {string} [longitude] Longitude of the location
         * @param {string} [latitude] Latitude of the location
         * @param {string} [searchRadius] Radius within which demographics details are required. Max. value is 52800 Feet or 10 miles
         * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters 
         * @param {string} [travelTime] Travel Time based on travelMode within which demographics details are required. Max. value is 1 hour.
         * @param {string} [travelTimeUnit] minutes,hours,seconds,milliseconds. Default is meters.Default is minutes.
         * @param {string} [travelDistance] Travel Distance based on travelMode within which demographics details are required. Max. value is 10 miles.
         * @param {string} [travelDistanceUnit] feet,kilometers,miles,meters.  Default is feet.
         * @param {string} [travelMode] Default is driving.
         * @param {string} [country] 3 digit ISO country code (Used in case address is mentioned).
         * @param {string} [profile] Applicable on ranged variables. Returns top sorted result based on the input value.
         * @param {string} [filter] If Y, demographic boundaries are returned in response.
         * @param {string} [includeGeometry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDemographicsBasic: async (address?: string, longitude?: string, latitude?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, country?: string, profile?: string, filter?: string, includeGeometry?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/demographics-segmentation/v1/basic/demographics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (searchRadius !== undefined) {
                localVarQueryParameter['searchRadius'] = searchRadius;
            }

            if (searchRadiusUnit !== undefined) {
                localVarQueryParameter['searchRadiusUnit'] = searchRadiusUnit;
            }

            if (travelTime !== undefined) {
                localVarQueryParameter['travelTime'] = travelTime;
            }

            if (travelTimeUnit !== undefined) {
                localVarQueryParameter['travelTimeUnit'] = travelTimeUnit;
            }

            if (travelDistance !== undefined) {
                localVarQueryParameter['travelDistance'] = travelDistance;
            }

            if (travelDistanceUnit !== undefined) {
                localVarQueryParameter['travelDistanceUnit'] = travelDistanceUnit;
            }

            if (travelMode !== undefined) {
                localVarQueryParameter['travelMode'] = travelMode;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (includeGeometry !== undefined) {
                localVarQueryParameter['includeGeometry'] = includeGeometry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides the demographic details around a specified address. GeoLife \'byaddress\' service accepts address as an input to return a specific population segment\'s age group, ethnicity, income, purchasing behaviour, commuter patterns and more.
         * @summary Demographics By Address.
         * @param {string} address The address to be searched.
         * @param {string} [country] 3 letter ISO code of the country to be searched.Allowed values USA,CAN,GBR,AUS.
         * @param {string} [profile] Retrieves the sorted demographic data on the basis of pre-defined profiles that can display the top 3 or top 5 results (by location) either in ascending or descending order.Allowed values Top5Ascending,Top5Descending,Top3Ascending,Top3Descending
         * @param {string} [filter] The \&#39;filter\&#39; parameter retrieves the demographic data based upon specified input themes.
         * @param {string} [valueFormat] The \&#39;valueFormat\&#39; parameter is applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
         * @param {string} [variableLevel] The \&#39;variableLevel\&#39; retrieves demographic facts in response based on the input value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDemographicsByAddress: async (address: string, country?: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getDemographicsByAddress', 'address', address)
            const localVarPath = `/demographics-segmentation/v1/demographics/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (valueFormat !== undefined) {
                localVarQueryParameter['valueFormat'] = valueFormat;
            }

            if (variableLevel !== undefined) {
                localVarQueryParameter['variableLevel'] = variableLevel;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will allow the user to request demographics details by census boundary id. Multiple comma separated boundary ids will be accepted. 
         * @summary Demographics By Boundaryids.
         * @param {string} [boundaryIds] Accepts comma separated multiple boundary ids.
         * @param {string} [profile] Applicable on ranged variables. Returns top sorted result based on the input value.
         * @param {string} [filter] Accept the comma separated theme names and filter response based on value. Maximum 10 can be provided.
         * @param {string} [valueFormat] Applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
         * @param {string} [variableLevel] Retrieves demographic facts in response based on the input value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDemographicsByBoundaryIds: async (boundaryIds?: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/demographics-segmentation/v1/demographics/byboundaryids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (boundaryIds !== undefined) {
                localVarQueryParameter['boundaryIds'] = boundaryIds;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (valueFormat !== undefined) {
                localVarQueryParameter['valueFormat'] = valueFormat;
            }

            if (variableLevel !== undefined) {
                localVarQueryParameter['variableLevel'] = variableLevel;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides the demographic details around a specified location. GeoLife \'bylocation\' service accepts longitude and latitude as an input to return a specific population segment\'s age group, ethnicity, income, purchasing behaviour, commuter patterns and more.
         * @summary Demographics By Location.
         * @param {string} [longitude] Longitude of the location.
         * @param {string} [latitude] Latitude of the location.
         * @param {string} [profile] Retrieves the sorted demographic data on the basis of pre-defined profiles that can display the top 3 or top 5 results (by location) either in ascending or descending order.Allowed values Top5Ascending,Top5Descending,Top3Ascending,Top3Descending
         * @param {string} [filter] The \&#39;filter\&#39; parameter retrieves the demographic data based upon specified input themes.
         * @param {string} [valueFormat] The \&#39;valueFormat\&#39; parameter is applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
         * @param {string} [variableLevel] The \&#39;variableLevel\&#39; retrieves demographic facts in response based on the input value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDemographicsByLocation: async (longitude?: string, latitude?: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/demographics-segmentation/v1/demographics/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (valueFormat !== undefined) {
                localVarQueryParameter['valueFormat'] = valueFormat;
            }

            if (variableLevel !== undefined) {
                localVarQueryParameter['variableLevel'] = variableLevel;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides the segmentation details around a specified address. GeoLife \'Segmentation by Address\' service accepts address as an input to return the lifestyle characteristics of households in terms of their family status, children characteristics, income behaviors, financial preferences and interests.
         * @summary Segmentation By Address.
         * @param {string} address The address to be searched.
         * @param {string} [country] 3 letter ISO code of the country to be searched.Allowed values USA,CAN,GBR,FRA,ITA,AUS,DEU.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentationByAddress: async (address: string, country?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getSegmentationByAddress', 'address', address)
            const localVarPath = `/demographics-segmentation/v1/segmentation/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides the segmentation details around a specified location. GeoLife \'segmentation bylocation\' service accepts longitude and latitude as an input to return the lifestyle characteristics of households in terms of their family status, children characteristics, income behaviors, financial preferences and interests.
         * @summary Segmentation By Location.
         * @param {string} longitude Longitude of the location.
         * @param {string} latitude Latitude of the location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentationByLocation: async (longitude: string, latitude: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('getSegmentationByLocation', 'longitude', longitude)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('getSegmentationByLocation', 'latitude', latitude)
            const localVarPath = `/demographics-segmentation/v1/segmentation/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DemographicsServiceApi - functional programming interface
 * @export
 */
export const DemographicsServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = DemographicsServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * Demographics Advanced Endpoint will return the aggregated values of the selected demographics variables of the regions falling inside a user provided geometry or travel time/distance boundaries. All the intersecting demographic boundaries will be snapped completely, and user will have option to request these boundaries in response.  
         * @summary Demographics Advanced Endpoint
         * @param {DemographicsAdvancedRequest} demographicsAdvancedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDemographicsAdvanced(demographicsAdvancedRequest: DemographicsAdvancedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Demographics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDemographicsAdvanced(demographicsAdvancedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Demographics Basic Endpoint will return the aggregated values of the selected demographics variables of the regions falling inside the search radius. All the intersecting demographic boundaries will be snapped completely and user will have option to request these boundaries in response.  
         * @summary Demographics Basic
         * @param {string} [address] Address to be searched
         * @param {string} [longitude] Longitude of the location
         * @param {string} [latitude] Latitude of the location
         * @param {string} [searchRadius] Radius within which demographics details are required. Max. value is 52800 Feet or 10 miles
         * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters 
         * @param {string} [travelTime] Travel Time based on travelMode within which demographics details are required. Max. value is 1 hour.
         * @param {string} [travelTimeUnit] minutes,hours,seconds,milliseconds. Default is meters.Default is minutes.
         * @param {string} [travelDistance] Travel Distance based on travelMode within which demographics details are required. Max. value is 10 miles.
         * @param {string} [travelDistanceUnit] feet,kilometers,miles,meters.  Default is feet.
         * @param {string} [travelMode] Default is driving.
         * @param {string} [country] 3 digit ISO country code (Used in case address is mentioned).
         * @param {string} [profile] Applicable on ranged variables. Returns top sorted result based on the input value.
         * @param {string} [filter] If Y, demographic boundaries are returned in response.
         * @param {string} [includeGeometry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDemographicsBasic(address?: string, longitude?: string, latitude?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, country?: string, profile?: string, filter?: string, includeGeometry?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Demographics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDemographicsBasic(address, longitude, latitude, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, country, profile, filter, includeGeometry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provides the demographic details around a specified address. GeoLife \'byaddress\' service accepts address as an input to return a specific population segment\'s age group, ethnicity, income, purchasing behaviour, commuter patterns and more.
         * @summary Demographics By Address.
         * @param {string} address The address to be searched.
         * @param {string} [country] 3 letter ISO code of the country to be searched.Allowed values USA,CAN,GBR,AUS.
         * @param {string} [profile] Retrieves the sorted demographic data on the basis of pre-defined profiles that can display the top 3 or top 5 results (by location) either in ascending or descending order.Allowed values Top5Ascending,Top5Descending,Top3Ascending,Top3Descending
         * @param {string} [filter] The \&#39;filter\&#39; parameter retrieves the demographic data based upon specified input themes.
         * @param {string} [valueFormat] The \&#39;valueFormat\&#39; parameter is applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
         * @param {string} [variableLevel] The \&#39;variableLevel\&#39; retrieves demographic facts in response based on the input value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDemographicsByAddress(address: string, country?: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Demographics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDemographicsByAddress(address, country, profile, filter, valueFormat, variableLevel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will allow the user to request demographics details by census boundary id. Multiple comma separated boundary ids will be accepted. 
         * @summary Demographics By Boundaryids.
         * @param {string} [boundaryIds] Accepts comma separated multiple boundary ids.
         * @param {string} [profile] Applicable on ranged variables. Returns top sorted result based on the input value.
         * @param {string} [filter] Accept the comma separated theme names and filter response based on value. Maximum 10 can be provided.
         * @param {string} [valueFormat] Applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
         * @param {string} [variableLevel] Retrieves demographic facts in response based on the input value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDemographicsByBoundaryIds(boundaryIds?: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Demographics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDemographicsByBoundaryIds(boundaryIds, profile, filter, valueFormat, variableLevel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provides the demographic details around a specified location. GeoLife \'bylocation\' service accepts longitude and latitude as an input to return a specific population segment\'s age group, ethnicity, income, purchasing behaviour, commuter patterns and more.
         * @summary Demographics By Location.
         * @param {string} [longitude] Longitude of the location.
         * @param {string} [latitude] Latitude of the location.
         * @param {string} [profile] Retrieves the sorted demographic data on the basis of pre-defined profiles that can display the top 3 or top 5 results (by location) either in ascending or descending order.Allowed values Top5Ascending,Top5Descending,Top3Ascending,Top3Descending
         * @param {string} [filter] The \&#39;filter\&#39; parameter retrieves the demographic data based upon specified input themes.
         * @param {string} [valueFormat] The \&#39;valueFormat\&#39; parameter is applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
         * @param {string} [variableLevel] The \&#39;variableLevel\&#39; retrieves demographic facts in response based on the input value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDemographicsByLocation(longitude?: string, latitude?: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Demographics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDemographicsByLocation(longitude, latitude, profile, filter, valueFormat, variableLevel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provides the segmentation details around a specified address. GeoLife \'Segmentation by Address\' service accepts address as an input to return the lifestyle characteristics of households in terms of their family status, children characteristics, income behaviors, financial preferences and interests.
         * @summary Segmentation By Address.
         * @param {string} address The address to be searched.
         * @param {string} [country] 3 letter ISO code of the country to be searched.Allowed values USA,CAN,GBR,FRA,ITA,AUS,DEU.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegmentationByAddress(address: string, country?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segmentation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegmentationByAddress(address, country, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provides the segmentation details around a specified location. GeoLife \'segmentation bylocation\' service accepts longitude and latitude as an input to return the lifestyle characteristics of households in terms of their family status, children characteristics, income behaviors, financial preferences and interests.
         * @summary Segmentation By Location.
         * @param {string} longitude Longitude of the location.
         * @param {string} latitude Latitude of the location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegmentationByLocation(longitude: string, latitude: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segmentation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegmentationByLocation(longitude, latitude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DemographicsServiceApi - factory interface
 * @export
 */
export const DemographicsServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DemographicsServiceApiFp(oAuth,configuration)
    return {
        /**
         * Demographics Advanced Endpoint will return the aggregated values of the selected demographics variables of the regions falling inside a user provided geometry or travel time/distance boundaries. All the intersecting demographic boundaries will be snapped completely, and user will have option to request these boundaries in response.  
         * @summary Demographics Advanced Endpoint
         * @param {DemographicsAdvancedRequest} demographicsAdvancedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDemographicsAdvanced(demographicsAdvancedRequest: DemographicsAdvancedRequest, options?: any): AxiosPromise<Demographics> {
            return localVarFp.getDemographicsAdvanced(demographicsAdvancedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Demographics Basic Endpoint will return the aggregated values of the selected demographics variables of the regions falling inside the search radius. All the intersecting demographic boundaries will be snapped completely and user will have option to request these boundaries in response.  
         * @summary Demographics Basic
         * @param {string} [address] Address to be searched
         * @param {string} [longitude] Longitude of the location
         * @param {string} [latitude] Latitude of the location
         * @param {string} [searchRadius] Radius within which demographics details are required. Max. value is 52800 Feet or 10 miles
         * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters 
         * @param {string} [travelTime] Travel Time based on travelMode within which demographics details are required. Max. value is 1 hour.
         * @param {string} [travelTimeUnit] minutes,hours,seconds,milliseconds. Default is meters.Default is minutes.
         * @param {string} [travelDistance] Travel Distance based on travelMode within which demographics details are required. Max. value is 10 miles.
         * @param {string} [travelDistanceUnit] feet,kilometers,miles,meters.  Default is feet.
         * @param {string} [travelMode] Default is driving.
         * @param {string} [country] 3 digit ISO country code (Used in case address is mentioned).
         * @param {string} [profile] Applicable on ranged variables. Returns top sorted result based on the input value.
         * @param {string} [filter] If Y, demographic boundaries are returned in response.
         * @param {string} [includeGeometry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDemographicsBasic(address?: string, longitude?: string, latitude?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, country?: string, profile?: string, filter?: string, includeGeometry?: string, options?: any): AxiosPromise<Demographics> {
            return localVarFp.getDemographicsBasic(address, longitude, latitude, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, country, profile, filter, includeGeometry, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides the demographic details around a specified address. GeoLife \'byaddress\' service accepts address as an input to return a specific population segment\'s age group, ethnicity, income, purchasing behaviour, commuter patterns and more.
         * @summary Demographics By Address.
         * @param {string} address The address to be searched.
         * @param {string} [country] 3 letter ISO code of the country to be searched.Allowed values USA,CAN,GBR,AUS.
         * @param {string} [profile] Retrieves the sorted demographic data on the basis of pre-defined profiles that can display the top 3 or top 5 results (by location) either in ascending or descending order.Allowed values Top5Ascending,Top5Descending,Top3Ascending,Top3Descending
         * @param {string} [filter] The \&#39;filter\&#39; parameter retrieves the demographic data based upon specified input themes.
         * @param {string} [valueFormat] The \&#39;valueFormat\&#39; parameter is applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
         * @param {string} [variableLevel] The \&#39;variableLevel\&#39; retrieves demographic facts in response based on the input value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDemographicsByAddress(address: string, country?: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string, options?: any): AxiosPromise<Demographics> {
            return localVarFp.getDemographicsByAddress(address, country, profile, filter, valueFormat, variableLevel, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will allow the user to request demographics details by census boundary id. Multiple comma separated boundary ids will be accepted. 
         * @summary Demographics By Boundaryids.
         * @param {string} [boundaryIds] Accepts comma separated multiple boundary ids.
         * @param {string} [profile] Applicable on ranged variables. Returns top sorted result based on the input value.
         * @param {string} [filter] Accept the comma separated theme names and filter response based on value. Maximum 10 can be provided.
         * @param {string} [valueFormat] Applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
         * @param {string} [variableLevel] Retrieves demographic facts in response based on the input value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDemographicsByBoundaryIds(boundaryIds?: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string, options?: any): AxiosPromise<Demographics> {
            return localVarFp.getDemographicsByBoundaryIds(boundaryIds, profile, filter, valueFormat, variableLevel, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides the demographic details around a specified location. GeoLife \'bylocation\' service accepts longitude and latitude as an input to return a specific population segment\'s age group, ethnicity, income, purchasing behaviour, commuter patterns and more.
         * @summary Demographics By Location.
         * @param {string} [longitude] Longitude of the location.
         * @param {string} [latitude] Latitude of the location.
         * @param {string} [profile] Retrieves the sorted demographic data on the basis of pre-defined profiles that can display the top 3 or top 5 results (by location) either in ascending or descending order.Allowed values Top5Ascending,Top5Descending,Top3Ascending,Top3Descending
         * @param {string} [filter] The \&#39;filter\&#39; parameter retrieves the demographic data based upon specified input themes.
         * @param {string} [valueFormat] The \&#39;valueFormat\&#39; parameter is applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
         * @param {string} [variableLevel] The \&#39;variableLevel\&#39; retrieves demographic facts in response based on the input value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDemographicsByLocation(longitude?: string, latitude?: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string, options?: any): AxiosPromise<Demographics> {
            return localVarFp.getDemographicsByLocation(longitude, latitude, profile, filter, valueFormat, variableLevel, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides the segmentation details around a specified address. GeoLife \'Segmentation by Address\' service accepts address as an input to return the lifestyle characteristics of households in terms of their family status, children characteristics, income behaviors, financial preferences and interests.
         * @summary Segmentation By Address.
         * @param {string} address The address to be searched.
         * @param {string} [country] 3 letter ISO code of the country to be searched.Allowed values USA,CAN,GBR,FRA,ITA,AUS,DEU.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentationByAddress(address: string, country?: string, options?: any): AxiosPromise<Segmentation> {
            return localVarFp.getSegmentationByAddress(address, country, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides the segmentation details around a specified location. GeoLife \'segmentation bylocation\' service accepts longitude and latitude as an input to return the lifestyle characteristics of households in terms of their family status, children characteristics, income behaviors, financial preferences and interests.
         * @summary Segmentation By Location.
         * @param {string} longitude Longitude of the location.
         * @param {string} latitude Latitude of the location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentationByLocation(longitude: string, latitude: string, options?: any): AxiosPromise<Segmentation> {
            return localVarFp.getSegmentationByLocation(longitude, latitude, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DemographicsServiceApi - object-oriented interface
 * @export
 * @class DemographicsServiceApi
 * @extends {BaseAPI}
 */
export class DemographicsServiceApi extends BaseAPI {
    /**
     * Demographics Advanced Endpoint will return the aggregated values of the selected demographics variables of the regions falling inside a user provided geometry or travel time/distance boundaries. All the intersecting demographic boundaries will be snapped completely, and user will have option to request these boundaries in response.  
     * @summary Demographics Advanced Endpoint
     * @param {DemographicsAdvancedRequest} demographicsAdvancedRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemographicsServiceApi
     */
    public getDemographicsAdvanced(demographicsAdvancedRequest: DemographicsAdvancedRequest, options?: AxiosRequestConfig) {
        return DemographicsServiceApiFp(this.oAuthCred,this.configuration).getDemographicsAdvanced(demographicsAdvancedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Demographics Basic Endpoint will return the aggregated values of the selected demographics variables of the regions falling inside the search radius. All the intersecting demographic boundaries will be snapped completely and user will have option to request these boundaries in response.  
     * @summary Demographics Basic
     * @param {string} [address] Address to be searched
     * @param {string} [longitude] Longitude of the location
     * @param {string} [latitude] Latitude of the location
     * @param {string} [searchRadius] Radius within which demographics details are required. Max. value is 52800 Feet or 10 miles
     * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters 
     * @param {string} [travelTime] Travel Time based on travelMode within which demographics details are required. Max. value is 1 hour.
     * @param {string} [travelTimeUnit] minutes,hours,seconds,milliseconds. Default is meters.Default is minutes.
     * @param {string} [travelDistance] Travel Distance based on travelMode within which demographics details are required. Max. value is 10 miles.
     * @param {string} [travelDistanceUnit] feet,kilometers,miles,meters.  Default is feet.
     * @param {string} [travelMode] Default is driving.
     * @param {string} [country] 3 digit ISO country code (Used in case address is mentioned).
     * @param {string} [profile] Applicable on ranged variables. Returns top sorted result based on the input value.
     * @param {string} [filter] If Y, demographic boundaries are returned in response.
     * @param {string} [includeGeometry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemographicsServiceApi
     */
    public getDemographicsBasic(address?: string, longitude?: string, latitude?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, country?: string, profile?: string, filter?: string, includeGeometry?: string, options?: AxiosRequestConfig) {
        return DemographicsServiceApiFp(this.oAuthCred,this.configuration).getDemographicsBasic(address, longitude, latitude, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, country, profile, filter, includeGeometry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides the demographic details around a specified address. GeoLife \'byaddress\' service accepts address as an input to return a specific population segment\'s age group, ethnicity, income, purchasing behaviour, commuter patterns and more.
     * @summary Demographics By Address.
     * @param {string} address The address to be searched.
     * @param {string} [country] 3 letter ISO code of the country to be searched.Allowed values USA,CAN,GBR,AUS.
     * @param {string} [profile] Retrieves the sorted demographic data on the basis of pre-defined profiles that can display the top 3 or top 5 results (by location) either in ascending or descending order.Allowed values Top5Ascending,Top5Descending,Top3Ascending,Top3Descending
     * @param {string} [filter] The \&#39;filter\&#39; parameter retrieves the demographic data based upon specified input themes.
     * @param {string} [valueFormat] The \&#39;valueFormat\&#39; parameter is applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
     * @param {string} [variableLevel] The \&#39;variableLevel\&#39; retrieves demographic facts in response based on the input value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemographicsServiceApi
     */
    public getDemographicsByAddress(address: string, country?: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string, options?: AxiosRequestConfig) {
        return DemographicsServiceApiFp(this.oAuthCred,this.configuration).getDemographicsByAddress(address, country, profile, filter, valueFormat, variableLevel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will allow the user to request demographics details by census boundary id. Multiple comma separated boundary ids will be accepted. 
     * @summary Demographics By Boundaryids.
     * @param {string} [boundaryIds] Accepts comma separated multiple boundary ids.
     * @param {string} [profile] Applicable on ranged variables. Returns top sorted result based on the input value.
     * @param {string} [filter] Accept the comma separated theme names and filter response based on value. Maximum 10 can be provided.
     * @param {string} [valueFormat] Applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
     * @param {string} [variableLevel] Retrieves demographic facts in response based on the input value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemographicsServiceApi
     */
    public getDemographicsByBoundaryIds(boundaryIds?: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string, options?: AxiosRequestConfig) {
        return DemographicsServiceApiFp(this.oAuthCred,this.configuration).getDemographicsByBoundaryIds(boundaryIds, profile, filter, valueFormat, variableLevel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides the demographic details around a specified location. GeoLife \'bylocation\' service accepts longitude and latitude as an input to return a specific population segment\'s age group, ethnicity, income, purchasing behaviour, commuter patterns and more.
     * @summary Demographics By Location.
     * @param {string} [longitude] Longitude of the location.
     * @param {string} [latitude] Latitude of the location.
     * @param {string} [profile] Retrieves the sorted demographic data on the basis of pre-defined profiles that can display the top 3 or top 5 results (by location) either in ascending or descending order.Allowed values Top5Ascending,Top5Descending,Top3Ascending,Top3Descending
     * @param {string} [filter] The \&#39;filter\&#39; parameter retrieves the demographic data based upon specified input themes.
     * @param {string} [valueFormat] The \&#39;valueFormat\&#39; parameter is applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
     * @param {string} [variableLevel] The \&#39;variableLevel\&#39; retrieves demographic facts in response based on the input value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemographicsServiceApi
     */
    public getDemographicsByLocation(longitude?: string, latitude?: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string, options?: AxiosRequestConfig) {
        return DemographicsServiceApiFp(this.oAuthCred,this.configuration).getDemographicsByLocation(longitude, latitude, profile, filter, valueFormat, variableLevel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides the segmentation details around a specified address. GeoLife \'Segmentation by Address\' service accepts address as an input to return the lifestyle characteristics of households in terms of their family status, children characteristics, income behaviors, financial preferences and interests.
     * @summary Segmentation By Address.
     * @param {string} address The address to be searched.
     * @param {string} [country] 3 letter ISO code of the country to be searched.Allowed values USA,CAN,GBR,FRA,ITA,AUS,DEU.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemographicsServiceApi
     */
    public getSegmentationByAddress(address: string, country?: string, options?: AxiosRequestConfig) {
        return DemographicsServiceApiFp(this.oAuthCred,this.configuration).getSegmentationByAddress(address, country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides the segmentation details around a specified location. GeoLife \'segmentation bylocation\' service accepts longitude and latitude as an input to return the lifestyle characteristics of households in terms of their family status, children characteristics, income behaviors, financial preferences and interests.
     * @summary Segmentation By Location.
     * @param {string} longitude Longitude of the location.
     * @param {string} latitude Latitude of the location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemographicsServiceApi
     */
    public getSegmentationByLocation(longitude: string, latitude: string, options?: AxiosRequestConfig) {
        return DemographicsServiceApiFp(this.oAuthCred,this.configuration).getSegmentationByLocation(longitude, latitude, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EmailVerificationServiceApi - axios parameter creator
 * @export
 */
export const EmailVerificationServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * Confirm that your customers mailing address exists and that mail and packages can be delivered to it.
         * @summary ValidateEmailAddress
         * @param {ValidateEmailAddressAPIRequest} inputEmailAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEmailAddress: async (inputEmailAddress: ValidateEmailAddressAPIRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inputEmailAddress' is not null or undefined
            assertParamExists('validateEmailAddress', 'inputEmailAddress', inputEmailAddress)
            const localVarPath = `/emailverification/v1/validateemailaddress/results.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inputEmailAddress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailVerificationServiceApi - functional programming interface
 * @export
 */
export const EmailVerificationServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = EmailVerificationServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * Confirm that your customers mailing address exists and that mail and packages can be delivered to it.
         * @summary ValidateEmailAddress
         * @param {ValidateEmailAddressAPIRequest} inputEmailAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateEmailAddress(inputEmailAddress: ValidateEmailAddressAPIRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateEmailAddressAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateEmailAddress(inputEmailAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EmailVerificationServiceApi - factory interface
 * @export
 */
export const EmailVerificationServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmailVerificationServiceApiFp(oAuth,configuration)
    return {
        /**
         * Confirm that your customers mailing address exists and that mail and packages can be delivered to it.
         * @summary ValidateEmailAddress
         * @param {ValidateEmailAddressAPIRequest} inputEmailAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEmailAddress(inputEmailAddress: ValidateEmailAddressAPIRequest, options?: any): AxiosPromise<ValidateEmailAddressAPIResponse> {
            return localVarFp.validateEmailAddress(inputEmailAddress, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmailVerificationServiceApi - object-oriented interface
 * @export
 * @class EmailVerificationServiceApi
 * @extends {BaseAPI}
 */
export class EmailVerificationServiceApi extends BaseAPI {
    /**
     * Confirm that your customers mailing address exists and that mail and packages can be delivered to it.
     * @summary ValidateEmailAddress
     * @param {ValidateEmailAddressAPIRequest} inputEmailAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailVerificationServiceApi
     */
    public validateEmailAddress(inputEmailAddress: ValidateEmailAddressAPIRequest, options?: AxiosRequestConfig) {
        return EmailVerificationServiceApiFp(this.oAuthCred,this.configuration).validateEmailAddress(inputEmailAddress, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GeocodeServiceApi - axios parameter creator
 * @export
 */
export const GeocodeServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * This service accepts an address and returns the location coordinates corresponding to that address. Premium offers the best accuracy and is a high precision geocoder leveraging Master Location Data - geocodes to Street or building level. Advanced offers advanced accuracy and geocodes to Street level.Basic offering will geocode to a Place or Postal level. Good accuracy.
         * @summary Get Forward Geocode(Basic/Premium/Advanced)
         * @param {'premium' | 'basic' | 'advanced'} datapackBundle datapackBundle
         * @param {string} [country] Country name or ISO code.
         * @param {string} [mainAddress] Single line input, treated as collection of field elements.
         * @param {'Exact' | 'Standard' | 'Relaxed' | 'Custom' | 'Interactive(USA Only)' | 'CASS(USA Only)'} [matchMode] Match modes determine the leniency used to make a match between the input address and the reference data.
         * @param {string} [fallbackGeo] Specifies whether to attempt to determine a geographic region centroid when an address-level geocode cannot be determined.
         * @param {string} [fallbackPostal] Specifies whether to attempt to determine a post code centroid when an address-level geocode cannot be determined.
         * @param {string} [maxCands] The maximum number of candidates to return.
         * @param {string} [streetOffset] Indicates the offset distance from the street segments to use in street-level geocoding.
         * @param {'METERS' | 'FEET'} [streetOffsetUnits] Specifies the unit of measurement for the street offset.
         * @param {string} [cornerOffset] Specifies the distance to offset the street end points in street-level matching.
         * @param {'METERS' | 'FEET'} [cornerOffsetUnits] Specifies the unit of measurement for the corner offset.
         * @param {string} [removeAccentMarks] Specifies whether to Suppress accents and other diacritical marks.
         * @param {string} [findDPV] Specifies if Delivery Point Validation is required. Note: This parameter is only applicable for USA addresses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geocode: async (datapackBundle: 'premium' | 'basic' | 'advanced', country?: string, mainAddress?: string, matchMode?: 'Exact' | 'Standard' | 'Relaxed' | 'Custom' | 'Interactive(USA Only)' | 'CASS(USA Only)', fallbackGeo?: string, fallbackPostal?: string, maxCands?: string, streetOffset?: string, streetOffsetUnits?: 'METERS' | 'FEET', cornerOffset?: string, cornerOffsetUnits?: 'METERS' | 'FEET', removeAccentMarks?: string, findDPV?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'datapackBundle' is not null or undefined
            assertParamExists('geocode', 'datapackBundle', datapackBundle)
            const localVarPath = `/geocode/v1/{datapackBundle}/geocode`
                .replace(`{${"datapackBundle"}}`, encodeURIComponent(String(datapackBundle)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (mainAddress !== undefined) {
                localVarQueryParameter['mainAddress'] = mainAddress;
            }

            if (matchMode !== undefined) {
                localVarQueryParameter['matchMode'] = matchMode;
            }

            if (fallbackGeo !== undefined) {
                localVarQueryParameter['fallbackGeo'] = fallbackGeo;
            }

            if (fallbackPostal !== undefined) {
                localVarQueryParameter['fallbackPostal'] = fallbackPostal;
            }

            if (maxCands !== undefined) {
                localVarQueryParameter['maxCands'] = maxCands;
            }

            if (streetOffset !== undefined) {
                localVarQueryParameter['streetOffset'] = streetOffset;
            }

            if (streetOffsetUnits !== undefined) {
                localVarQueryParameter['streetOffsetUnits'] = streetOffsetUnits;
            }

            if (cornerOffset !== undefined) {
                localVarQueryParameter['cornerOffset'] = cornerOffset;
            }

            if (cornerOffsetUnits !== undefined) {
                localVarQueryParameter['cornerOffsetUnits'] = cornerOffsetUnits;
            }

            if (removeAccentMarks !== undefined) {
                localVarQueryParameter['removeAccentMarks'] = removeAccentMarks;
            }

            if (findDPV !== undefined) {
                localVarQueryParameter['findDPV'] = findDPV;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a Batch offering for geocode service. It accepts a single address or a list of addresses and returns location coordinates
         * @summary Post Forward Geocode
         * @param {string} datapackBundle 
         * @param {GeocodeRequest} geocodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geocodeBatch: async (datapackBundle: string, geocodeRequest: GeocodeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'datapackBundle' is not null or undefined
            assertParamExists('geocodeBatch', 'datapackBundle', datapackBundle)
            // verify required parameter 'geocodeRequest' is not null or undefined
            assertParamExists('geocodeBatch', 'geocodeRequest', geocodeRequest)
            const localVarPath = `/geocode/v1/{datapackBundle}/geocode`
                .replace(`{${"datapackBundle"}}`, encodeURIComponent(String(datapackBundle)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(geocodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service accepts an address and returns the corresponding PreciselyID
         * @summary Get PreciselyID By Address
         * @param {string} address The address to be searched.
         * @param {string} [country] 3 letter ISO code of the country to be searched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPBKey: async (address: string, country?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getPBKey', 'address', address)
            const localVarPath = `/geocode/v1/key/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a Batch offering for \'PreciselyID By Address\' service. It accepts a single address or a list of addresses and returns the corresponding PreciselyID.
         * @summary Post PreciselyID By Address
         * @param {PBKeyAddressRequest} pBKeyAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPBKeys: async (pBKeyAddressRequest: PBKeyAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pBKeyAddressRequest' is not null or undefined
            assertParamExists('getPBKeys', 'pBKeyAddressRequest', pBKeyAddressRequest)
            const localVarPath = `/geocode/v1/key/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pBKeyAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service accepts a PreciselyID and returns the corresponding address associated with that PreciselyID.
         * @summary Get Key Lookup
         * @param {string} key PreciselyID which maps to a unique address.
         * @param {string} type Specifies the key type - PreciselyID and GNAF_PID for Aus.
         * @param {string} [country] 3 letter ISO code of the country to be searched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyLookup: async (key: string, type: string, country?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('keyLookup', 'key', key)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('keyLookup', 'type', type)
            const localVarPath = `/geocode/v1/keylookup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service accepts batches of PreciselyID\'s and returns the corresponding address associated with those PreciselyID\'s.
         * @summary Post Key Lookup
         * @param {KeyLookupRequest} keyLookupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyLookupBatch: async (keyLookupRequest: KeyLookupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyLookupRequest' is not null or undefined
            assertParamExists('keyLookupBatch', 'keyLookupRequest', keyLookupRequest)
            const localVarPath = `/geocode/v1/keylookup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyLookupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a Batch offering for geocode service. It accepts a single address or a list of addresses and returns location coordinates
         * @summary Post Reverse Geocode
         * @param {string} datapackBundle 
         * @param {ReverseGeocodeRequest} reverseGeocodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reverseGeocodBatch: async (datapackBundle: string, reverseGeocodeRequest: ReverseGeocodeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'datapackBundle' is not null or undefined
            assertParamExists('reverseGeocodBatch', 'datapackBundle', datapackBundle)
            // verify required parameter 'reverseGeocodeRequest' is not null or undefined
            assertParamExists('reverseGeocodBatch', 'reverseGeocodeRequest', reverseGeocodeRequest)
            const localVarPath = `/geocode/v1/{datapackBundle}/reverseGeocode`
                .replace(`{${"datapackBundle"}}`, encodeURIComponent(String(datapackBundle)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reverseGeocodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service accepts location coordinate and returns an address.
         * @summary Get Reverse Geocode(Basic/Premium/Advanced)
         * @param {'premium' | 'basic' | 'advanced'} datapackBundle datapackBundle
         * @param {string} x Longitude of the location.
         * @param {string} y Latitude of the location.
         * @param {string} [country] Country name or ISO code.
         * @param {string} [coordSysName] Coordinate system to convert geometry to in format codespace:code.
         * @param {string} [distance] Radius in which search is performed.
         * @param {'METERS' | 'FEET'} [distanceUnits] Unit of measurement.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reverseGeocode: async (datapackBundle: 'premium' | 'basic' | 'advanced', x: string, y: string, country?: string, coordSysName?: string, distance?: string, distanceUnits?: 'METERS' | 'FEET', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'datapackBundle' is not null or undefined
            assertParamExists('reverseGeocode', 'datapackBundle', datapackBundle)
            // verify required parameter 'x' is not null or undefined
            assertParamExists('reverseGeocode', 'x', x)
            // verify required parameter 'y' is not null or undefined
            assertParamExists('reverseGeocode', 'y', y)
            const localVarPath = `/geocode/v1/{datapackBundle}/reverseGeocode`
                .replace(`{${"datapackBundle"}}`, encodeURIComponent(String(datapackBundle)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (x !== undefined) {
                localVarQueryParameter['x'] = x;
            }

            if (y !== undefined) {
                localVarQueryParameter['y'] = y;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (coordSysName !== undefined) {
                localVarQueryParameter['coordSysName'] = coordSysName;
            }

            if (distance !== undefined) {
                localVarQueryParameter['distance'] = distance;
            }

            if (distanceUnits !== undefined) {
                localVarQueryParameter['distanceUnits'] = distanceUnits;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeocodeServiceApi - functional programming interface
 * @export
 */
export const GeocodeServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = GeocodeServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * This service accepts an address and returns the location coordinates corresponding to that address. Premium offers the best accuracy and is a high precision geocoder leveraging Master Location Data - geocodes to Street or building level. Advanced offers advanced accuracy and geocodes to Street level.Basic offering will geocode to a Place or Postal level. Good accuracy.
         * @summary Get Forward Geocode(Basic/Premium/Advanced)
         * @param {'premium' | 'basic' | 'advanced'} datapackBundle datapackBundle
         * @param {string} [country] Country name or ISO code.
         * @param {string} [mainAddress] Single line input, treated as collection of field elements.
         * @param {'Exact' | 'Standard' | 'Relaxed' | 'Custom' | 'Interactive(USA Only)' | 'CASS(USA Only)'} [matchMode] Match modes determine the leniency used to make a match between the input address and the reference data.
         * @param {string} [fallbackGeo] Specifies whether to attempt to determine a geographic region centroid when an address-level geocode cannot be determined.
         * @param {string} [fallbackPostal] Specifies whether to attempt to determine a post code centroid when an address-level geocode cannot be determined.
         * @param {string} [maxCands] The maximum number of candidates to return.
         * @param {string} [streetOffset] Indicates the offset distance from the street segments to use in street-level geocoding.
         * @param {'METERS' | 'FEET'} [streetOffsetUnits] Specifies the unit of measurement for the street offset.
         * @param {string} [cornerOffset] Specifies the distance to offset the street end points in street-level matching.
         * @param {'METERS' | 'FEET'} [cornerOffsetUnits] Specifies the unit of measurement for the corner offset.
         * @param {string} [removeAccentMarks] Specifies whether to Suppress accents and other diacritical marks.
         * @param {string} [findDPV] Specifies if Delivery Point Validation is required. Note: This parameter is only applicable for USA addresses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geocode(datapackBundle: 'premium' | 'basic' | 'advanced', country?: string, mainAddress?: string, matchMode?: 'Exact' | 'Standard' | 'Relaxed' | 'Custom' | 'Interactive(USA Only)' | 'CASS(USA Only)', fallbackGeo?: string, fallbackPostal?: string, maxCands?: string, streetOffset?: string, streetOffsetUnits?: 'METERS' | 'FEET', cornerOffset?: string, cornerOffsetUnits?: 'METERS' | 'FEET', removeAccentMarks?: string, findDPV?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeocodeServiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geocode(datapackBundle, country, mainAddress, matchMode, fallbackGeo, fallbackPostal, maxCands, streetOffset, streetOffsetUnits, cornerOffset, cornerOffsetUnits, removeAccentMarks, findDPV, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a Batch offering for geocode service. It accepts a single address or a list of addresses and returns location coordinates
         * @summary Post Forward Geocode
         * @param {string} datapackBundle 
         * @param {GeocodeRequest} geocodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geocodeBatch(datapackBundle: string, geocodeRequest: GeocodeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeocodeServiceResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geocodeBatch(datapackBundle, geocodeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This service accepts an address and returns the corresponding PreciselyID
         * @summary Get PreciselyID By Address
         * @param {string} address The address to be searched.
         * @param {string} [country] 3 letter ISO code of the country to be searched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPBKey(address: string, country?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PBKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPBKey(address, country, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a Batch offering for \'PreciselyID By Address\' service. It accepts a single address or a list of addresses and returns the corresponding PreciselyID.
         * @summary Post PreciselyID By Address
         * @param {PBKeyAddressRequest} pBKeyAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPBKeys(pBKeyAddressRequest: PBKeyAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PBKeyResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPBKeys(pBKeyAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This service accepts a PreciselyID and returns the corresponding address associated with that PreciselyID.
         * @summary Get Key Lookup
         * @param {string} key PreciselyID which maps to a unique address.
         * @param {string} type Specifies the key type - PreciselyID and GNAF_PID for Aus.
         * @param {string} [country] 3 letter ISO code of the country to be searched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyLookup(key: string, type: string, country?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeocodeServiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyLookup(key, type, country, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This service accepts batches of PreciselyID\'s and returns the corresponding address associated with those PreciselyID\'s.
         * @summary Post Key Lookup
         * @param {KeyLookupRequest} keyLookupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyLookupBatch(keyLookupRequest: KeyLookupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeocodeServiceResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyLookupBatch(keyLookupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a Batch offering for geocode service. It accepts a single address or a list of addresses and returns location coordinates
         * @summary Post Reverse Geocode
         * @param {string} datapackBundle 
         * @param {ReverseGeocodeRequest} reverseGeocodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reverseGeocodBatch(datapackBundle: string, reverseGeocodeRequest: ReverseGeocodeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeocodeServiceResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reverseGeocodBatch(datapackBundle, reverseGeocodeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This service accepts location coordinate and returns an address.
         * @summary Get Reverse Geocode(Basic/Premium/Advanced)
         * @param {'premium' | 'basic' | 'advanced'} datapackBundle datapackBundle
         * @param {string} x Longitude of the location.
         * @param {string} y Latitude of the location.
         * @param {string} [country] Country name or ISO code.
         * @param {string} [coordSysName] Coordinate system to convert geometry to in format codespace:code.
         * @param {string} [distance] Radius in which search is performed.
         * @param {'METERS' | 'FEET'} [distanceUnits] Unit of measurement.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reverseGeocode(datapackBundle: 'premium' | 'basic' | 'advanced', x: string, y: string, country?: string, coordSysName?: string, distance?: string, distanceUnits?: 'METERS' | 'FEET', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeocodeServiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reverseGeocode(datapackBundle, x, y, country, coordSysName, distance, distanceUnits, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GeocodeServiceApi - factory interface
 * @export
 */
export const GeocodeServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GeocodeServiceApiFp(oAuth,configuration)
    return {
        /**
         * This service accepts an address and returns the location coordinates corresponding to that address. Premium offers the best accuracy and is a high precision geocoder leveraging Master Location Data - geocodes to Street or building level. Advanced offers advanced accuracy and geocodes to Street level.Basic offering will geocode to a Place or Postal level. Good accuracy.
         * @summary Get Forward Geocode(Basic/Premium/Advanced)
         * @param {'premium' | 'basic' | 'advanced'} datapackBundle datapackBundle
         * @param {string} [country] Country name or ISO code.
         * @param {string} [mainAddress] Single line input, treated as collection of field elements.
         * @param {'Exact' | 'Standard' | 'Relaxed' | 'Custom' | 'Interactive(USA Only)' | 'CASS(USA Only)'} [matchMode] Match modes determine the leniency used to make a match between the input address and the reference data.
         * @param {string} [fallbackGeo] Specifies whether to attempt to determine a geographic region centroid when an address-level geocode cannot be determined.
         * @param {string} [fallbackPostal] Specifies whether to attempt to determine a post code centroid when an address-level geocode cannot be determined.
         * @param {string} [maxCands] The maximum number of candidates to return.
         * @param {string} [streetOffset] Indicates the offset distance from the street segments to use in street-level geocoding.
         * @param {'METERS' | 'FEET'} [streetOffsetUnits] Specifies the unit of measurement for the street offset.
         * @param {string} [cornerOffset] Specifies the distance to offset the street end points in street-level matching.
         * @param {'METERS' | 'FEET'} [cornerOffsetUnits] Specifies the unit of measurement for the corner offset.
         * @param {string} [removeAccentMarks] Specifies whether to Suppress accents and other diacritical marks.
         * @param {string} [findDPV] Specifies if Delivery Point Validation is required. Note: This parameter is only applicable for USA addresses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geocode(datapackBundle: 'premium' | 'basic' | 'advanced', country?: string, mainAddress?: string, matchMode?: 'Exact' | 'Standard' | 'Relaxed' | 'Custom' | 'Interactive(USA Only)' | 'CASS(USA Only)', fallbackGeo?: string, fallbackPostal?: string, maxCands?: string, streetOffset?: string, streetOffsetUnits?: 'METERS' | 'FEET', cornerOffset?: string, cornerOffsetUnits?: 'METERS' | 'FEET', removeAccentMarks?: string, findDPV?: string, options?: any): AxiosPromise<GeocodeServiceResponse> {
            return localVarFp.geocode(datapackBundle, country, mainAddress, matchMode, fallbackGeo, fallbackPostal, maxCands, streetOffset, streetOffsetUnits, cornerOffset, cornerOffsetUnits, removeAccentMarks, findDPV, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a Batch offering for geocode service. It accepts a single address or a list of addresses and returns location coordinates
         * @summary Post Forward Geocode
         * @param {string} datapackBundle 
         * @param {GeocodeRequest} geocodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geocodeBatch(datapackBundle: string, geocodeRequest: GeocodeRequest, options?: any): AxiosPromise<GeocodeServiceResponseList> {
            return localVarFp.geocodeBatch(datapackBundle, geocodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This service accepts an address and returns the corresponding PreciselyID
         * @summary Get PreciselyID By Address
         * @param {string} address The address to be searched.
         * @param {string} [country] 3 letter ISO code of the country to be searched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPBKey(address: string, country?: string, options?: any): AxiosPromise<PBKeyResponse> {
            return localVarFp.getPBKey(address, country, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a Batch offering for \'PreciselyID By Address\' service. It accepts a single address or a list of addresses and returns the corresponding PreciselyID.
         * @summary Post PreciselyID By Address
         * @param {PBKeyAddressRequest} pBKeyAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPBKeys(pBKeyAddressRequest: PBKeyAddressRequest, options?: any): AxiosPromise<PBKeyResponseList> {
            return localVarFp.getPBKeys(pBKeyAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This service accepts a PreciselyID and returns the corresponding address associated with that PreciselyID.
         * @summary Get Key Lookup
         * @param {string} key PreciselyID which maps to a unique address.
         * @param {string} type Specifies the key type - PreciselyID and GNAF_PID for Aus.
         * @param {string} [country] 3 letter ISO code of the country to be searched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyLookup(key: string, type: string, country?: string, options?: any): AxiosPromise<GeocodeServiceResponse> {
            return localVarFp.keyLookup(key, type, country, options).then((request) => request(axios, basePath));
        },
        /**
         * This service accepts batches of PreciselyID\'s and returns the corresponding address associated with those PreciselyID\'s.
         * @summary Post Key Lookup
         * @param {KeyLookupRequest} keyLookupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyLookupBatch(keyLookupRequest: KeyLookupRequest, options?: any): AxiosPromise<GeocodeServiceResponseList> {
            return localVarFp.keyLookupBatch(keyLookupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a Batch offering for geocode service. It accepts a single address or a list of addresses and returns location coordinates
         * @summary Post Reverse Geocode
         * @param {string} datapackBundle 
         * @param {ReverseGeocodeRequest} reverseGeocodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reverseGeocodBatch(datapackBundle: string, reverseGeocodeRequest: ReverseGeocodeRequest, options?: any): AxiosPromise<GeocodeServiceResponseList> {
            return localVarFp.reverseGeocodBatch(datapackBundle, reverseGeocodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This service accepts location coordinate and returns an address.
         * @summary Get Reverse Geocode(Basic/Premium/Advanced)
         * @param {'premium' | 'basic' | 'advanced'} datapackBundle datapackBundle
         * @param {string} x Longitude of the location.
         * @param {string} y Latitude of the location.
         * @param {string} [country] Country name or ISO code.
         * @param {string} [coordSysName] Coordinate system to convert geometry to in format codespace:code.
         * @param {string} [distance] Radius in which search is performed.
         * @param {'METERS' | 'FEET'} [distanceUnits] Unit of measurement.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reverseGeocode(datapackBundle: 'premium' | 'basic' | 'advanced', x: string, y: string, country?: string, coordSysName?: string, distance?: string, distanceUnits?: 'METERS' | 'FEET', options?: any): AxiosPromise<GeocodeServiceResponse> {
            return localVarFp.reverseGeocode(datapackBundle, x, y, country, coordSysName, distance, distanceUnits, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GeocodeServiceApi - object-oriented interface
 * @export
 * @class GeocodeServiceApi
 * @extends {BaseAPI}
 */
export class GeocodeServiceApi extends BaseAPI {
    /**
     * This service accepts an address and returns the location coordinates corresponding to that address. Premium offers the best accuracy and is a high precision geocoder leveraging Master Location Data - geocodes to Street or building level. Advanced offers advanced accuracy and geocodes to Street level.Basic offering will geocode to a Place or Postal level. Good accuracy.
     * @summary Get Forward Geocode(Basic/Premium/Advanced)
     * @param {'premium' | 'basic' | 'advanced'} datapackBundle datapackBundle
     * @param {string} [country] Country name or ISO code.
     * @param {string} [mainAddress] Single line input, treated as collection of field elements.
     * @param {'Exact' | 'Standard' | 'Relaxed' | 'Custom' | 'Interactive(USA Only)' | 'CASS(USA Only)'} [matchMode] Match modes determine the leniency used to make a match between the input address and the reference data.
     * @param {string} [fallbackGeo] Specifies whether to attempt to determine a geographic region centroid when an address-level geocode cannot be determined.
     * @param {string} [fallbackPostal] Specifies whether to attempt to determine a post code centroid when an address-level geocode cannot be determined.
     * @param {string} [maxCands] The maximum number of candidates to return.
     * @param {string} [streetOffset] Indicates the offset distance from the street segments to use in street-level geocoding.
     * @param {'METERS' | 'FEET'} [streetOffsetUnits] Specifies the unit of measurement for the street offset.
     * @param {string} [cornerOffset] Specifies the distance to offset the street end points in street-level matching.
     * @param {'METERS' | 'FEET'} [cornerOffsetUnits] Specifies the unit of measurement for the corner offset.
     * @param {string} [removeAccentMarks] Specifies whether to Suppress accents and other diacritical marks.
     * @param {string} [findDPV] Specifies if Delivery Point Validation is required. Note: This parameter is only applicable for USA addresses.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeocodeServiceApi
     */
    public geocode(datapackBundle: 'premium' | 'basic' | 'advanced', country?: string, mainAddress?: string, matchMode?: 'Exact' | 'Standard' | 'Relaxed' | 'Custom' | 'Interactive(USA Only)' | 'CASS(USA Only)', fallbackGeo?: string, fallbackPostal?: string, maxCands?: string, streetOffset?: string, streetOffsetUnits?: 'METERS' | 'FEET', cornerOffset?: string, cornerOffsetUnits?: 'METERS' | 'FEET', removeAccentMarks?: string, findDPV?: string, options?: AxiosRequestConfig) {
        return GeocodeServiceApiFp(this.oAuthCred,this.configuration).geocode(datapackBundle, country, mainAddress, matchMode, fallbackGeo, fallbackPostal, maxCands, streetOffset, streetOffsetUnits, cornerOffset, cornerOffsetUnits, removeAccentMarks, findDPV, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a Batch offering for geocode service. It accepts a single address or a list of addresses and returns location coordinates
     * @summary Post Forward Geocode
     * @param {string} datapackBundle 
     * @param {GeocodeRequest} geocodeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeocodeServiceApi
     */
    public geocodeBatch(datapackBundle: string, geocodeRequest: GeocodeRequest, options?: AxiosRequestConfig) {
        return GeocodeServiceApiFp(this.oAuthCred,this.configuration).geocodeBatch(datapackBundle, geocodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service accepts an address and returns the corresponding PreciselyID
     * @summary Get PreciselyID By Address
     * @param {string} address The address to be searched.
     * @param {string} [country] 3 letter ISO code of the country to be searched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeocodeServiceApi
     */
    public getPBKey(address: string, country?: string, options?: AxiosRequestConfig) {
        return GeocodeServiceApiFp(this.oAuthCred,this.configuration).getPBKey(address, country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a Batch offering for \'PreciselyID By Address\' service. It accepts a single address or a list of addresses and returns the corresponding PreciselyID.
     * @summary Post PreciselyID By Address
     * @param {PBKeyAddressRequest} pBKeyAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeocodeServiceApi
     */
    public getPBKeys(pBKeyAddressRequest: PBKeyAddressRequest, options?: AxiosRequestConfig) {
        return GeocodeServiceApiFp(this.oAuthCred,this.configuration).getPBKeys(pBKeyAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service accepts a PreciselyID and returns the corresponding address associated with that PreciselyID.
     * @summary Get Key Lookup
     * @param {string} key PreciselyID which maps to a unique address.
     * @param {string} type Specifies the key type - PreciselyID and GNAF_PID for Aus.
     * @param {string} [country] 3 letter ISO code of the country to be searched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeocodeServiceApi
     */
    public keyLookup(key: string, type: string, country?: string, options?: AxiosRequestConfig) {
        return GeocodeServiceApiFp(this.oAuthCred,this.configuration).keyLookup(key, type, country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service accepts batches of PreciselyID\'s and returns the corresponding address associated with those PreciselyID\'s.
     * @summary Post Key Lookup
     * @param {KeyLookupRequest} keyLookupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeocodeServiceApi
     */
    public keyLookupBatch(keyLookupRequest: KeyLookupRequest, options?: AxiosRequestConfig) {
        return GeocodeServiceApiFp(this.oAuthCred,this.configuration).keyLookupBatch(keyLookupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a Batch offering for geocode service. It accepts a single address or a list of addresses and returns location coordinates
     * @summary Post Reverse Geocode
     * @param {string} datapackBundle 
     * @param {ReverseGeocodeRequest} reverseGeocodeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeocodeServiceApi
     */
    public reverseGeocodBatch(datapackBundle: string, reverseGeocodeRequest: ReverseGeocodeRequest, options?: AxiosRequestConfig) {
        return GeocodeServiceApiFp(this.oAuthCred,this.configuration).reverseGeocodBatch(datapackBundle, reverseGeocodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service accepts location coordinate and returns an address.
     * @summary Get Reverse Geocode(Basic/Premium/Advanced)
     * @param {'premium' | 'basic' | 'advanced'} datapackBundle datapackBundle
     * @param {string} x Longitude of the location.
     * @param {string} y Latitude of the location.
     * @param {string} [country] Country name or ISO code.
     * @param {string} [coordSysName] Coordinate system to convert geometry to in format codespace:code.
     * @param {string} [distance] Radius in which search is performed.
     * @param {'METERS' | 'FEET'} [distanceUnits] Unit of measurement.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeocodeServiceApi
     */
    public reverseGeocode(datapackBundle: 'premium' | 'basic' | 'advanced', x: string, y: string, country?: string, coordSysName?: string, distance?: string, distanceUnits?: 'METERS' | 'FEET', options?: AxiosRequestConfig) {
        return GeocodeServiceApiFp(this.oAuthCred,this.configuration).reverseGeocode(datapackBundle, x, y, country, coordSysName, distance, distanceUnits, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GeolocationServiceApi - axios parameter creator
 * @export
 */
export const GeolocationServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * This service accepts an IP address and returns the location coordinates corresponding to that IP address.
         * @summary Location By IP Address.
         * @param {string} ipAddress This is the ip address of network connected device. It must be a standard IPv4 octet and a valid external address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocationByIPAddress: async (ipAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipAddress' is not null or undefined
            assertParamExists('getLocationByIPAddress', 'ipAddress', ipAddress)
            const localVarPath = `/geolocation/v1/location/byipaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (ipAddress !== undefined) {
                localVarQueryParameter['ipAddress'] = ipAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service accepts a WiFi access point MAC address and returns the location coordinates corresponding to that access point. Only mac or accessPoint are mandatory parameters (one of them has to be provided), rest are optional.
         * @summary Location by WiFi Access Point.
         * @param {string} [mac] This should be the 48 bit mac address (or BSSID) of wireless access point. Accepted format is Six groups of two hexadecimal digits, separated by hyphens (-) or colons.
         * @param {string} [ssid] The service set identifier for wi-fi access point. It should be alphanumeric with maximum 32 characters.
         * @param {string} [rsid] This is the received signal strength indicator from particular wi-fi access point. It should be a number from -113 to 0 and the unit of this strength is dBm.
         * @param {string} [speed] This is the connection speed for wi-fi. It should be a number from 0 to 6930 and the unit should be Mbps.
         * @param {string} [accessPoint] This is the JSON based list of wifi access points in the vicinity of device to be located. This parameter is helpful in case, multiple wifi points are visible and we want to make sure that the location of device is best calculated considering all the access points location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocationByWiFiAccessPoint: async (mac?: string, ssid?: string, rsid?: string, speed?: string, accessPoint?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/geolocation/v1/location/byaccesspoint`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (mac !== undefined) {
                localVarQueryParameter['mac'] = mac;
            }

            if (ssid !== undefined) {
                localVarQueryParameter['ssid'] = ssid;
            }

            if (rsid !== undefined) {
                localVarQueryParameter['rsid'] = rsid;
            }

            if (speed !== undefined) {
                localVarQueryParameter['speed'] = speed;
            }

            if (accessPoint !== undefined) {
                localVarQueryParameter['accessPoint'] = accessPoint;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeolocationServiceApi - functional programming interface
 * @export
 */
export const GeolocationServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = GeolocationServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * This service accepts an IP address and returns the location coordinates corresponding to that IP address.
         * @summary Location By IP Address.
         * @param {string} ipAddress This is the ip address of network connected device. It must be a standard IPv4 octet and a valid external address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocationByIPAddress(ipAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeoLocationIpAddr>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLocationByIPAddress(ipAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This service accepts a WiFi access point MAC address and returns the location coordinates corresponding to that access point. Only mac or accessPoint are mandatory parameters (one of them has to be provided), rest are optional.
         * @summary Location by WiFi Access Point.
         * @param {string} [mac] This should be the 48 bit mac address (or BSSID) of wireless access point. Accepted format is Six groups of two hexadecimal digits, separated by hyphens (-) or colons.
         * @param {string} [ssid] The service set identifier for wi-fi access point. It should be alphanumeric with maximum 32 characters.
         * @param {string} [rsid] This is the received signal strength indicator from particular wi-fi access point. It should be a number from -113 to 0 and the unit of this strength is dBm.
         * @param {string} [speed] This is the connection speed for wi-fi. It should be a number from 0 to 6930 and the unit should be Mbps.
         * @param {string} [accessPoint] This is the JSON based list of wifi access points in the vicinity of device to be located. This parameter is helpful in case, multiple wifi points are visible and we want to make sure that the location of device is best calculated considering all the access points location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocationByWiFiAccessPoint(mac?: string, ssid?: string, rsid?: string, speed?: string, accessPoint?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeoLocationAccessPoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLocationByWiFiAccessPoint(mac, ssid, rsid, speed, accessPoint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GeolocationServiceApi - factory interface
 * @export
 */
export const GeolocationServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GeolocationServiceApiFp(oAuth,configuration)
    return {
        /**
         * This service accepts an IP address and returns the location coordinates corresponding to that IP address.
         * @summary Location By IP Address.
         * @param {string} ipAddress This is the ip address of network connected device. It must be a standard IPv4 octet and a valid external address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocationByIPAddress(ipAddress: string, options?: any): AxiosPromise<GeoLocationIpAddr> {
            return localVarFp.getLocationByIPAddress(ipAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * This service accepts a WiFi access point MAC address and returns the location coordinates corresponding to that access point. Only mac or accessPoint are mandatory parameters (one of them has to be provided), rest are optional.
         * @summary Location by WiFi Access Point.
         * @param {string} [mac] This should be the 48 bit mac address (or BSSID) of wireless access point. Accepted format is Six groups of two hexadecimal digits, separated by hyphens (-) or colons.
         * @param {string} [ssid] The service set identifier for wi-fi access point. It should be alphanumeric with maximum 32 characters.
         * @param {string} [rsid] This is the received signal strength indicator from particular wi-fi access point. It should be a number from -113 to 0 and the unit of this strength is dBm.
         * @param {string} [speed] This is the connection speed for wi-fi. It should be a number from 0 to 6930 and the unit should be Mbps.
         * @param {string} [accessPoint] This is the JSON based list of wifi access points in the vicinity of device to be located. This parameter is helpful in case, multiple wifi points are visible and we want to make sure that the location of device is best calculated considering all the access points location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocationByWiFiAccessPoint(mac?: string, ssid?: string, rsid?: string, speed?: string, accessPoint?: string, options?: any): AxiosPromise<GeoLocationAccessPoint> {
            return localVarFp.getLocationByWiFiAccessPoint(mac, ssid, rsid, speed, accessPoint, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GeolocationServiceApi - object-oriented interface
 * @export
 * @class GeolocationServiceApi
 * @extends {BaseAPI}
 */
export class GeolocationServiceApi extends BaseAPI {
    /**
     * This service accepts an IP address and returns the location coordinates corresponding to that IP address.
     * @summary Location By IP Address.
     * @param {string} ipAddress This is the ip address of network connected device. It must be a standard IPv4 octet and a valid external address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeolocationServiceApi
     */
    public getLocationByIPAddress(ipAddress: string, options?: AxiosRequestConfig) {
        return GeolocationServiceApiFp(this.oAuthCred,this.configuration).getLocationByIPAddress(ipAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service accepts a WiFi access point MAC address and returns the location coordinates corresponding to that access point. Only mac or accessPoint are mandatory parameters (one of them has to be provided), rest are optional.
     * @summary Location by WiFi Access Point.
     * @param {string} [mac] This should be the 48 bit mac address (or BSSID) of wireless access point. Accepted format is Six groups of two hexadecimal digits, separated by hyphens (-) or colons.
     * @param {string} [ssid] The service set identifier for wi-fi access point. It should be alphanumeric with maximum 32 characters.
     * @param {string} [rsid] This is the received signal strength indicator from particular wi-fi access point. It should be a number from -113 to 0 and the unit of this strength is dBm.
     * @param {string} [speed] This is the connection speed for wi-fi. It should be a number from 0 to 6930 and the unit should be Mbps.
     * @param {string} [accessPoint] This is the JSON based list of wifi access points in the vicinity of device to be located. This parameter is helpful in case, multiple wifi points are visible and we want to make sure that the location of device is best calculated considering all the access points location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeolocationServiceApi
     */
    public getLocationByWiFiAccessPoint(mac?: string, ssid?: string, rsid?: string, speed?: string, accessPoint?: string, options?: AxiosRequestConfig) {
        return GeolocationServiceApiFp(this.oAuthCred,this.configuration).getLocationByWiFiAccessPoint(mac, ssid, rsid, speed, accessPoint, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LocalTaxServiceApi - axios parameter creator
 * @export
 */
export const LocalTaxServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * This is a Batch offering for \'Tax By Address\' service. It accepts a single address, purchase amount or a list of addresses, purchase amounts and retrieve applicable taxes.
         * @summary Post Tax By Address
         * @param {string} taxRateTypeId 
         * @param {TaxAddressRequest} taxAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchTaxByAddress: async (taxRateTypeId: string, taxAddressRequest: TaxAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taxRateTypeId' is not null or undefined
            assertParamExists('getBatchTaxByAddress', 'taxRateTypeId', taxRateTypeId)
            // verify required parameter 'taxAddressRequest' is not null or undefined
            assertParamExists('getBatchTaxByAddress', 'taxAddressRequest', taxAddressRequest)
            const localVarPath = `/localtax/v1/tax/{taxRateTypeId}/byaddress`
                .replace(`{${"taxRateTypeId"}}`, encodeURIComponent(String(taxRateTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taxAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a Batch offering for \'Tax By Location\' service. It accepts a single location coordinate, purchase amount or a list of location coordinates, purchase amounts and retrieve applicable tax.
         * @summary Post Tax By Location
         * @param {string} taxRateTypeId 
         * @param {TaxLocationRequest} taxLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchTaxByLocation: async (taxRateTypeId: string, taxLocationRequest: TaxLocationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taxRateTypeId' is not null or undefined
            assertParamExists('getBatchTaxByLocation', 'taxRateTypeId', taxRateTypeId)
            // verify required parameter 'taxLocationRequest' is not null or undefined
            assertParamExists('getBatchTaxByLocation', 'taxLocationRequest', taxLocationRequest)
            const localVarPath = `/localtax/v1/tax/{taxRateTypeId}/bylocation`
                .replace(`{${"taxRateTypeId"}}`, encodeURIComponent(String(taxRateTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taxLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a Batch offering for \'Taxrate By Address\' service. It accepts a single address or a list of addresses and retrieve applicable tax rates.
         * @summary Post Taxrate By Address
         * @param {string} taxRateTypeId 
         * @param {TaxRateAddressRequest} taxRateAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchTaxRateByAddress: async (taxRateTypeId: string, taxRateAddressRequest: TaxRateAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taxRateTypeId' is not null or undefined
            assertParamExists('getBatchTaxRateByAddress', 'taxRateTypeId', taxRateTypeId)
            // verify required parameter 'taxRateAddressRequest' is not null or undefined
            assertParamExists('getBatchTaxRateByAddress', 'taxRateAddressRequest', taxRateAddressRequest)
            const localVarPath = `/localtax/v1/taxrate/{taxRateTypeId}/byaddress`
                .replace(`{${"taxRateTypeId"}}`, encodeURIComponent(String(taxRateTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taxRateAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a Batch offering for \'Taxrate By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve applicable tax rates.
         * @summary Post Taxrate By Location
         * @param {string} taxRateTypeId 
         * @param {TaxRateLocationRequest} taxRateLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchTaxRateByLocation: async (taxRateTypeId: string, taxRateLocationRequest: TaxRateLocationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taxRateTypeId' is not null or undefined
            assertParamExists('getBatchTaxRateByLocation', 'taxRateTypeId', taxRateTypeId)
            // verify required parameter 'taxRateLocationRequest' is not null or undefined
            assertParamExists('getBatchTaxRateByLocation', 'taxRateLocationRequest', taxRateLocationRequest)
            const localVarPath = `/localtax/v1/taxrate/{taxRateTypeId}/bylocation`
                .replace(`{${"taxRateTypeId"}}`, encodeURIComponent(String(taxRateTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taxRateLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves IPD (Insurance Premium District) tax rates applicable to a specific address. This service accepts address as input and returns one or many IPD tax rate details for that region in which address falls.
         * @summary Get IPD Tax by Address
         * @param {string} address The address to be searched.
         * @param {string} [returnLatLongFields] Y or N (default is N) - Returns Latitude Longitude Fields.
         * @param {string} [latLongFormat] (default is Decimal) - Returns Desired Latitude Longitude Format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIPDTaxByAddress: async (address: string, returnLatLongFields?: string, latLongFormat?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getIPDTaxByAddress', 'address', address)
            const localVarPath = `/localtax/v1/taxdistrict/ipd/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (returnLatLongFields !== undefined) {
                localVarQueryParameter['returnLatLongFields'] = returnLatLongFields;
            }

            if (latLongFormat !== undefined) {
                localVarQueryParameter['latLongFormat'] = latLongFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a Batch offering for \'IPD Tax rates By Address\'. It accepts multiple addresses as parameters along with geocoding and matching preferences and returns one or many IPD tax rate details for each address.
         * @summary Get IPD Tax for batch requests.
         * @param {IPDTaxByAddressBatchRequest} iPDTaxByAddressBatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIPDTaxByAddressBatch: async (iPDTaxByAddressBatchRequest: IPDTaxByAddressBatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iPDTaxByAddressBatchRequest' is not null or undefined
            assertParamExists('getIPDTaxByAddressBatch', 'iPDTaxByAddressBatchRequest', iPDTaxByAddressBatchRequest)
            const localVarPath = `/localtax/v1/taxdistrict/ipd/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPDTaxByAddressBatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service calculates and returns taxes applicable at a specific address. Address, purchase amount and supported tax rate type are inputs to the service.
         * @summary Get Tax By Address
         * @param {string} taxRateTypeId The tax rate id
         * @param {string} address The address to be searched.
         * @param {string} purchaseAmount The amount on which tax to be calculated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecificTaxByAddress: async (taxRateTypeId: string, address: string, purchaseAmount: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taxRateTypeId' is not null or undefined
            assertParamExists('getSpecificTaxByAddress', 'taxRateTypeId', taxRateTypeId)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getSpecificTaxByAddress', 'address', address)
            // verify required parameter 'purchaseAmount' is not null or undefined
            assertParamExists('getSpecificTaxByAddress', 'purchaseAmount', purchaseAmount)
            const localVarPath = `/localtax/v1/tax/{taxRateTypeId}/byaddress`
                .replace(`{${"taxRateTypeId"}}`, encodeURIComponent(String(taxRateTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (purchaseAmount !== undefined) {
                localVarQueryParameter['purchaseAmount'] = purchaseAmount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service calculates and returns tax applicable at a specific location. Longitude, latitude, purchase amount and supported tax rate type are inputs to the service.
         * @summary Get Tax By Location
         * @param {string} taxRateTypeId The tax rate id
         * @param {string} latitude Latitude of the location
         * @param {string} longitude Longitude of the location
         * @param {string} purchaseAmount The amount on which tax to be calculated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecificTaxByLocation: async (taxRateTypeId: string, latitude: string, longitude: string, purchaseAmount: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taxRateTypeId' is not null or undefined
            assertParamExists('getSpecificTaxByLocation', 'taxRateTypeId', taxRateTypeId)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('getSpecificTaxByLocation', 'latitude', latitude)
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('getSpecificTaxByLocation', 'longitude', longitude)
            // verify required parameter 'purchaseAmount' is not null or undefined
            assertParamExists('getSpecificTaxByLocation', 'purchaseAmount', purchaseAmount)
            const localVarPath = `/localtax/v1/tax/{taxRateTypeId}/bylocation`
                .replace(`{${"taxRateTypeId"}}`, encodeURIComponent(String(taxRateTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (purchaseAmount !== undefined) {
                localVarQueryParameter['purchaseAmount'] = purchaseAmount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves tax rates applicable to a specific address. This service accepts address and supported tax rate type as inputs to retrieve applicable tax rates.
         * @summary Get Taxrate By Address
         * @param {string} taxRateTypeId The tax rate id
         * @param {string} address The address to be searched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecificTaxRateByAddress: async (taxRateTypeId: string, address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taxRateTypeId' is not null or undefined
            assertParamExists('getSpecificTaxRateByAddress', 'taxRateTypeId', taxRateTypeId)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getSpecificTaxRateByAddress', 'address', address)
            const localVarPath = `/localtax/v1/taxrate/{taxRateTypeId}/byaddress`
                .replace(`{${"taxRateTypeId"}}`, encodeURIComponent(String(taxRateTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves tax rates applicable to a specific location. This service accepts longitude, latitude and supported tax rate type as inputs to retrieve applicable tax rates.
         * @summary Get Taxrate By Location
         * @param {string} taxRateTypeId The tax rate id
         * @param {string} latitude Latitude of the location
         * @param {string} longitude Longitude of the location
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecificTaxRateByLocation: async (taxRateTypeId: string, latitude: string, longitude: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taxRateTypeId' is not null or undefined
            assertParamExists('getSpecificTaxRateByLocation', 'taxRateTypeId', taxRateTypeId)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('getSpecificTaxRateByLocation', 'latitude', latitude)
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('getSpecificTaxRateByLocation', 'longitude', longitude)
            const localVarPath = `/localtax/v1/taxrate/{taxRateTypeId}/bylocation`
                .replace(`{${"taxRateTypeId"}}`, encodeURIComponent(String(taxRateTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocalTaxServiceApi - functional programming interface
 * @export
 */
export const LocalTaxServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = LocalTaxServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * This is a Batch offering for \'Tax By Address\' service. It accepts a single address, purchase amount or a list of addresses, purchase amounts and retrieve applicable taxes.
         * @summary Post Tax By Address
         * @param {string} taxRateTypeId 
         * @param {TaxAddressRequest} taxAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchTaxByAddress(taxRateTypeId: string, taxAddressRequest: TaxAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxResponses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchTaxByAddress(taxRateTypeId, taxAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a Batch offering for \'Tax By Location\' service. It accepts a single location coordinate, purchase amount or a list of location coordinates, purchase amounts and retrieve applicable tax.
         * @summary Post Tax By Location
         * @param {string} taxRateTypeId 
         * @param {TaxLocationRequest} taxLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchTaxByLocation(taxRateTypeId: string, taxLocationRequest: TaxLocationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxResponses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchTaxByLocation(taxRateTypeId, taxLocationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a Batch offering for \'Taxrate By Address\' service. It accepts a single address or a list of addresses and retrieve applicable tax rates.
         * @summary Post Taxrate By Address
         * @param {string} taxRateTypeId 
         * @param {TaxRateAddressRequest} taxRateAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchTaxRateByAddress(taxRateTypeId: string, taxRateAddressRequest: TaxRateAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxResponses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchTaxRateByAddress(taxRateTypeId, taxRateAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a Batch offering for \'Taxrate By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve applicable tax rates.
         * @summary Post Taxrate By Location
         * @param {string} taxRateTypeId 
         * @param {TaxRateLocationRequest} taxRateLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchTaxRateByLocation(taxRateTypeId: string, taxRateLocationRequest: TaxRateLocationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxResponses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchTaxRateByLocation(taxRateTypeId, taxRateLocationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves IPD (Insurance Premium District) tax rates applicable to a specific address. This service accepts address as input and returns one or many IPD tax rate details for that region in which address falls.
         * @summary Get IPD Tax by Address
         * @param {string} address The address to be searched.
         * @param {string} [returnLatLongFields] Y or N (default is N) - Returns Latitude Longitude Fields.
         * @param {string} [latLongFormat] (default is Decimal) - Returns Desired Latitude Longitude Format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIPDTaxByAddress(address: string, returnLatLongFields?: string, latLongFormat?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxDistrictResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIPDTaxByAddress(address, returnLatLongFields, latLongFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a Batch offering for \'IPD Tax rates By Address\'. It accepts multiple addresses as parameters along with geocoding and matching preferences and returns one or many IPD tax rate details for each address.
         * @summary Get IPD Tax for batch requests.
         * @param {IPDTaxByAddressBatchRequest} iPDTaxByAddressBatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIPDTaxByAddressBatch(iPDTaxByAddressBatchRequest: IPDTaxByAddressBatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxDistrictResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIPDTaxByAddressBatch(iPDTaxByAddressBatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This service calculates and returns taxes applicable at a specific address. Address, purchase amount and supported tax rate type are inputs to the service.
         * @summary Get Tax By Address
         * @param {string} taxRateTypeId The tax rate id
         * @param {string} address The address to be searched.
         * @param {string} purchaseAmount The amount on which tax to be calculated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpecificTaxByAddress(taxRateTypeId: string, address: string, purchaseAmount: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxRateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpecificTaxByAddress(taxRateTypeId, address, purchaseAmount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This service calculates and returns tax applicable at a specific location. Longitude, latitude, purchase amount and supported tax rate type are inputs to the service.
         * @summary Get Tax By Location
         * @param {string} taxRateTypeId The tax rate id
         * @param {string} latitude Latitude of the location
         * @param {string} longitude Longitude of the location
         * @param {string} purchaseAmount The amount on which tax to be calculated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpecificTaxByLocation(taxRateTypeId: string, latitude: string, longitude: string, purchaseAmount: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxRateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpecificTaxByLocation(taxRateTypeId, latitude, longitude, purchaseAmount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves tax rates applicable to a specific address. This service accepts address and supported tax rate type as inputs to retrieve applicable tax rates.
         * @summary Get Taxrate By Address
         * @param {string} taxRateTypeId The tax rate id
         * @param {string} address The address to be searched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpecificTaxRateByAddress(taxRateTypeId: string, address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxRateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpecificTaxRateByAddress(taxRateTypeId, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves tax rates applicable to a specific location. This service accepts longitude, latitude and supported tax rate type as inputs to retrieve applicable tax rates.
         * @summary Get Taxrate By Location
         * @param {string} taxRateTypeId The tax rate id
         * @param {string} latitude Latitude of the location
         * @param {string} longitude Longitude of the location
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpecificTaxRateByLocation(taxRateTypeId: string, latitude: string, longitude: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxRateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpecificTaxRateByLocation(taxRateTypeId, latitude, longitude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LocalTaxServiceApi - factory interface
 * @export
 */
export const LocalTaxServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocalTaxServiceApiFp(oAuth,configuration)
    return {
        /**
         * This is a Batch offering for \'Tax By Address\' service. It accepts a single address, purchase amount or a list of addresses, purchase amounts and retrieve applicable taxes.
         * @summary Post Tax By Address
         * @param {string} taxRateTypeId 
         * @param {TaxAddressRequest} taxAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchTaxByAddress(taxRateTypeId: string, taxAddressRequest: TaxAddressRequest, options?: any): AxiosPromise<TaxResponses> {
            return localVarFp.getBatchTaxByAddress(taxRateTypeId, taxAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a Batch offering for \'Tax By Location\' service. It accepts a single location coordinate, purchase amount or a list of location coordinates, purchase amounts and retrieve applicable tax.
         * @summary Post Tax By Location
         * @param {string} taxRateTypeId 
         * @param {TaxLocationRequest} taxLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchTaxByLocation(taxRateTypeId: string, taxLocationRequest: TaxLocationRequest, options?: any): AxiosPromise<TaxResponses> {
            return localVarFp.getBatchTaxByLocation(taxRateTypeId, taxLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a Batch offering for \'Taxrate By Address\' service. It accepts a single address or a list of addresses and retrieve applicable tax rates.
         * @summary Post Taxrate By Address
         * @param {string} taxRateTypeId 
         * @param {TaxRateAddressRequest} taxRateAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchTaxRateByAddress(taxRateTypeId: string, taxRateAddressRequest: TaxRateAddressRequest, options?: any): AxiosPromise<TaxResponses> {
            return localVarFp.getBatchTaxRateByAddress(taxRateTypeId, taxRateAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a Batch offering for \'Taxrate By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve applicable tax rates.
         * @summary Post Taxrate By Location
         * @param {string} taxRateTypeId 
         * @param {TaxRateLocationRequest} taxRateLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchTaxRateByLocation(taxRateTypeId: string, taxRateLocationRequest: TaxRateLocationRequest, options?: any): AxiosPromise<TaxResponses> {
            return localVarFp.getBatchTaxRateByLocation(taxRateTypeId, taxRateLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves IPD (Insurance Premium District) tax rates applicable to a specific address. This service accepts address as input and returns one or many IPD tax rate details for that region in which address falls.
         * @summary Get IPD Tax by Address
         * @param {string} address The address to be searched.
         * @param {string} [returnLatLongFields] Y or N (default is N) - Returns Latitude Longitude Fields.
         * @param {string} [latLongFormat] (default is Decimal) - Returns Desired Latitude Longitude Format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIPDTaxByAddress(address: string, returnLatLongFields?: string, latLongFormat?: string, options?: any): AxiosPromise<TaxDistrictResponse> {
            return localVarFp.getIPDTaxByAddress(address, returnLatLongFields, latLongFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a Batch offering for \'IPD Tax rates By Address\'. It accepts multiple addresses as parameters along with geocoding and matching preferences and returns one or many IPD tax rate details for each address.
         * @summary Get IPD Tax for batch requests.
         * @param {IPDTaxByAddressBatchRequest} iPDTaxByAddressBatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIPDTaxByAddressBatch(iPDTaxByAddressBatchRequest: IPDTaxByAddressBatchRequest, options?: any): AxiosPromise<TaxDistrictResponseList> {
            return localVarFp.getIPDTaxByAddressBatch(iPDTaxByAddressBatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This service calculates and returns taxes applicable at a specific address. Address, purchase amount and supported tax rate type are inputs to the service.
         * @summary Get Tax By Address
         * @param {string} taxRateTypeId The tax rate id
         * @param {string} address The address to be searched.
         * @param {string} purchaseAmount The amount on which tax to be calculated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecificTaxByAddress(taxRateTypeId: string, address: string, purchaseAmount: string, options?: any): AxiosPromise<TaxRateResponse> {
            return localVarFp.getSpecificTaxByAddress(taxRateTypeId, address, purchaseAmount, options).then((request) => request(axios, basePath));
        },
        /**
         * This service calculates and returns tax applicable at a specific location. Longitude, latitude, purchase amount and supported tax rate type are inputs to the service.
         * @summary Get Tax By Location
         * @param {string} taxRateTypeId The tax rate id
         * @param {string} latitude Latitude of the location
         * @param {string} longitude Longitude of the location
         * @param {string} purchaseAmount The amount on which tax to be calculated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecificTaxByLocation(taxRateTypeId: string, latitude: string, longitude: string, purchaseAmount: string, options?: any): AxiosPromise<TaxRateResponse> {
            return localVarFp.getSpecificTaxByLocation(taxRateTypeId, latitude, longitude, purchaseAmount, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves tax rates applicable to a specific address. This service accepts address and supported tax rate type as inputs to retrieve applicable tax rates.
         * @summary Get Taxrate By Address
         * @param {string} taxRateTypeId The tax rate id
         * @param {string} address The address to be searched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecificTaxRateByAddress(taxRateTypeId: string, address: string, options?: any): AxiosPromise<TaxRateResponse> {
            return localVarFp.getSpecificTaxRateByAddress(taxRateTypeId, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves tax rates applicable to a specific location. This service accepts longitude, latitude and supported tax rate type as inputs to retrieve applicable tax rates.
         * @summary Get Taxrate By Location
         * @param {string} taxRateTypeId The tax rate id
         * @param {string} latitude Latitude of the location
         * @param {string} longitude Longitude of the location
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecificTaxRateByLocation(taxRateTypeId: string, latitude: string, longitude: string, options?: any): AxiosPromise<TaxRateResponse> {
            return localVarFp.getSpecificTaxRateByLocation(taxRateTypeId, latitude, longitude, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocalTaxServiceApi - object-oriented interface
 * @export
 * @class LocalTaxServiceApi
 * @extends {BaseAPI}
 */
export class LocalTaxServiceApi extends BaseAPI {
    /**
     * This is a Batch offering for \'Tax By Address\' service. It accepts a single address, purchase amount or a list of addresses, purchase amounts and retrieve applicable taxes.
     * @summary Post Tax By Address
     * @param {string} taxRateTypeId 
     * @param {TaxAddressRequest} taxAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalTaxServiceApi
     */
    public getBatchTaxByAddress(taxRateTypeId: string, taxAddressRequest: TaxAddressRequest, options?: AxiosRequestConfig) {
        return LocalTaxServiceApiFp(this.oAuthCred,this.configuration).getBatchTaxByAddress(taxRateTypeId, taxAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a Batch offering for \'Tax By Location\' service. It accepts a single location coordinate, purchase amount or a list of location coordinates, purchase amounts and retrieve applicable tax.
     * @summary Post Tax By Location
     * @param {string} taxRateTypeId 
     * @param {TaxLocationRequest} taxLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalTaxServiceApi
     */
    public getBatchTaxByLocation(taxRateTypeId: string, taxLocationRequest: TaxLocationRequest, options?: AxiosRequestConfig) {
        return LocalTaxServiceApiFp(this.oAuthCred,this.configuration).getBatchTaxByLocation(taxRateTypeId, taxLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a Batch offering for \'Taxrate By Address\' service. It accepts a single address or a list of addresses and retrieve applicable tax rates.
     * @summary Post Taxrate By Address
     * @param {string} taxRateTypeId 
     * @param {TaxRateAddressRequest} taxRateAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalTaxServiceApi
     */
    public getBatchTaxRateByAddress(taxRateTypeId: string, taxRateAddressRequest: TaxRateAddressRequest, options?: AxiosRequestConfig) {
        return LocalTaxServiceApiFp(this.oAuthCred,this.configuration).getBatchTaxRateByAddress(taxRateTypeId, taxRateAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a Batch offering for \'Taxrate By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve applicable tax rates.
     * @summary Post Taxrate By Location
     * @param {string} taxRateTypeId 
     * @param {TaxRateLocationRequest} taxRateLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalTaxServiceApi
     */
    public getBatchTaxRateByLocation(taxRateTypeId: string, taxRateLocationRequest: TaxRateLocationRequest, options?: AxiosRequestConfig) {
        return LocalTaxServiceApiFp(this.oAuthCred,this.configuration).getBatchTaxRateByLocation(taxRateTypeId, taxRateLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves IPD (Insurance Premium District) tax rates applicable to a specific address. This service accepts address as input and returns one or many IPD tax rate details for that region in which address falls.
     * @summary Get IPD Tax by Address
     * @param {string} address The address to be searched.
     * @param {string} [returnLatLongFields] Y or N (default is N) - Returns Latitude Longitude Fields.
     * @param {string} [latLongFormat] (default is Decimal) - Returns Desired Latitude Longitude Format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalTaxServiceApi
     */
    public getIPDTaxByAddress(address: string, returnLatLongFields?: string, latLongFormat?: string, options?: AxiosRequestConfig) {
        return LocalTaxServiceApiFp(this.oAuthCred,this.configuration).getIPDTaxByAddress(address, returnLatLongFields, latLongFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a Batch offering for \'IPD Tax rates By Address\'. It accepts multiple addresses as parameters along with geocoding and matching preferences and returns one or many IPD tax rate details for each address.
     * @summary Get IPD Tax for batch requests.
     * @param {IPDTaxByAddressBatchRequest} iPDTaxByAddressBatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalTaxServiceApi
     */
    public getIPDTaxByAddressBatch(iPDTaxByAddressBatchRequest: IPDTaxByAddressBatchRequest, options?: AxiosRequestConfig) {
        return LocalTaxServiceApiFp(this.oAuthCred,this.configuration).getIPDTaxByAddressBatch(iPDTaxByAddressBatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service calculates and returns taxes applicable at a specific address. Address, purchase amount and supported tax rate type are inputs to the service.
     * @summary Get Tax By Address
     * @param {string} taxRateTypeId The tax rate id
     * @param {string} address The address to be searched.
     * @param {string} purchaseAmount The amount on which tax to be calculated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalTaxServiceApi
     */
    public getSpecificTaxByAddress(taxRateTypeId: string, address: string, purchaseAmount: string, options?: AxiosRequestConfig) {
        return LocalTaxServiceApiFp(this.oAuthCred,this.configuration).getSpecificTaxByAddress(taxRateTypeId, address, purchaseAmount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service calculates and returns tax applicable at a specific location. Longitude, latitude, purchase amount and supported tax rate type are inputs to the service.
     * @summary Get Tax By Location
     * @param {string} taxRateTypeId The tax rate id
     * @param {string} latitude Latitude of the location
     * @param {string} longitude Longitude of the location
     * @param {string} purchaseAmount The amount on which tax to be calculated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalTaxServiceApi
     */
    public getSpecificTaxByLocation(taxRateTypeId: string, latitude: string, longitude: string, purchaseAmount: string, options?: AxiosRequestConfig) {
        return LocalTaxServiceApiFp(this.oAuthCred,this.configuration).getSpecificTaxByLocation(taxRateTypeId, latitude, longitude, purchaseAmount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves tax rates applicable to a specific address. This service accepts address and supported tax rate type as inputs to retrieve applicable tax rates.
     * @summary Get Taxrate By Address
     * @param {string} taxRateTypeId The tax rate id
     * @param {string} address The address to be searched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalTaxServiceApi
     */
    public getSpecificTaxRateByAddress(taxRateTypeId: string, address: string, options?: AxiosRequestConfig) {
        return LocalTaxServiceApiFp(this.oAuthCred,this.configuration).getSpecificTaxRateByAddress(taxRateTypeId, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves tax rates applicable to a specific location. This service accepts longitude, latitude and supported tax rate type as inputs to retrieve applicable tax rates.
     * @summary Get Taxrate By Location
     * @param {string} taxRateTypeId The tax rate id
     * @param {string} latitude Latitude of the location
     * @param {string} longitude Longitude of the location
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalTaxServiceApi
     */
    public getSpecificTaxRateByLocation(taxRateTypeId: string, latitude: string, longitude: string, options?: AxiosRequestConfig) {
        return LocalTaxServiceApiFp(this.oAuthCred,this.configuration).getSpecificTaxRateByLocation(taxRateTypeId, latitude, longitude, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NeighborhoodsServiceApi - axios parameter creator
 * @export
 */
export const NeighborhoodsServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * Identifies and retrieves the nearest neighborhood around a specific location. This service accepts latitude & longitude as input and returns a place name.
         * @summary Place By Location.
         * @param {string} [longitude] Longitude of the location.
         * @param {string} [latitude] Latitude of the location.
         * @param {string} [levelHint] Numeric code of geographic hierarchy level which is classified at six levels.Allowed values 1,2,3,4,5,6
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaceByLocation: async (longitude?: string, latitude?: string, levelHint?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/neighborhoods/v1/place/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (levelHint !== undefined) {
                localVarQueryParameter['levelHint'] = levelHint;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NeighborhoodsServiceApi - functional programming interface
 * @export
 */
export const NeighborhoodsServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = NeighborhoodsServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * Identifies and retrieves the nearest neighborhood around a specific location. This service accepts latitude & longitude as input and returns a place name.
         * @summary Place By Location.
         * @param {string} [longitude] Longitude of the location.
         * @param {string} [latitude] Latitude of the location.
         * @param {string} [levelHint] Numeric code of geographic hierarchy level which is classified at six levels.Allowed values 1,2,3,4,5,6
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaceByLocation(longitude?: string, latitude?: string, levelHint?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NeighborhoodsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaceByLocation(longitude, latitude, levelHint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NeighborhoodsServiceApi - factory interface
 * @export
 */
export const NeighborhoodsServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NeighborhoodsServiceApiFp(oAuth,configuration)
    return {
        /**
         * Identifies and retrieves the nearest neighborhood around a specific location. This service accepts latitude & longitude as input and returns a place name.
         * @summary Place By Location.
         * @param {string} [longitude] Longitude of the location.
         * @param {string} [latitude] Latitude of the location.
         * @param {string} [levelHint] Numeric code of geographic hierarchy level which is classified at six levels.Allowed values 1,2,3,4,5,6
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaceByLocation(longitude?: string, latitude?: string, levelHint?: string, options?: any): AxiosPromise<NeighborhoodsResponse> {
            return localVarFp.getPlaceByLocation(longitude, latitude, levelHint, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NeighborhoodsServiceApi - object-oriented interface
 * @export
 * @class NeighborhoodsServiceApi
 * @extends {BaseAPI}
 */
export class NeighborhoodsServiceApi extends BaseAPI {
    /**
     * Identifies and retrieves the nearest neighborhood around a specific location. This service accepts latitude & longitude as input and returns a place name.
     * @summary Place By Location.
     * @param {string} [longitude] Longitude of the location.
     * @param {string} [latitude] Latitude of the location.
     * @param {string} [levelHint] Numeric code of geographic hierarchy level which is classified at six levels.Allowed values 1,2,3,4,5,6
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeighborhoodsServiceApi
     */
    public getPlaceByLocation(longitude?: string, latitude?: string, levelHint?: string, options?: AxiosRequestConfig) {
        return NeighborhoodsServiceApiFp(this.oAuthCred,this.configuration).getPlaceByLocation(longitude, latitude, levelHint, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PSAP911ServiceApi - axios parameter creator
 * @export
 */
export const PSAP911ServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * Accepts addresses as input and Returns contact details for Authorities Having Jurisdiction (AHJ) on-behalf-of local Public Safety Answering Points (PSAP). 911/PSAP accepts an address and returns PSAP contact data plus contact data for an AHJ to communicate directly with a PSAP. Details include agency name, phone number, city name, coverage, contact person\'s details, site details and mailing addresses for EMS, Fire, and Police PSAP contacts.
         * @summary AHJ & PSAP By Address.
         * @param {string} address The address to be searched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAHJPlusPSAPByAddress: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAHJPlusPSAPByAddress', 'address', address)
            const localVarPath = `/911/v1/ahj-psap/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts latitude & longitude as input and Returns contact details for Authorities Having Jurisdiction (AHJ) on-behalf-of local Public Safety Answering Points (PSAP). 911/PSAP accepts a location coordinate and returns PSAP contact data plus contact data for an AHJ to communicate directly with a PSAP. Details include agency name, phone number, city name, coverage, contact person\'s details, site details and mailing addresses for EMS, Fire, and Police PSAP contacts.
         * @summary AHJ & PSAP By Location
         * @param {string} longitude Longitude of the location.
         * @param {string} latitude Latitude of the location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAHJPlusPSAPByLocation: async (longitude: string, latitude: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('getAHJPlusPSAPByLocation', 'longitude', longitude)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('getAHJPlusPSAPByLocation', 'latitude', latitude)
            const localVarPath = `/911/v1/ahj-psap/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts addresses as input and Returns contact details for local Public Safety Answering Points (PSAP). 911/PSAP accepts an address as input and returns the relevant PSAP address and contact details including agency name, phone number, county name, coverage, contact person\'s details, site details and mailing address.
         * @summary PSAP By Address.
         * @param {string} address The address to be searched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPSAPByAddress: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getPSAPByAddress', 'address', address)
            const localVarPath = `/911/v1/psap/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts latitude & longitude as input and Returns contact details for local Public Safety Answering Points (PSAP). 911/PSAP accepts a location coordinate and returns the relevant PSAP address and contact details including dispatch name, phone number, county name, coverage, contact person\'s details, site details and mailing address.
         * @summary PSAP By Location.
         * @param {string} longitude Longitude of the location.
         * @param {string} latitude Latitude of the location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPSAPByLocation: async (longitude: string, latitude: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('getPSAPByLocation', 'longitude', longitude)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('getPSAPByLocation', 'latitude', latitude)
            const localVarPath = `/911/v1/psap/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts fccid as input and Returns contact details for Authorities Having Jurisdiction (AHJ) on-behalf-of local Public Safety Answering Points (PSAP). 911/PSAP accepts a location coordinate and returns PSAP contact data plus contact data for an AHJ to communicate directly with a PSAP. Details include agency name, phone number, city name, coverage, contact person\'s details, site details and mailing addresses for EMS, Fire, and Police PSAP contacts.
         * @summary AHJ & PSAP By Fccid
         * @param {string} fccId fccId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchByFccId: async (fccId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fccId' is not null or undefined
            assertParamExists('searchByFccId', 'fccId', fccId)
            const localVarPath = `/911/v1/ahj-psap/byfccid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (fccId !== undefined) {
                localVarQueryParameter['fccId'] = fccId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PSAP911ServiceApi - functional programming interface
 * @export
 */
export const PSAP911ServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = PSAP911ServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * Accepts addresses as input and Returns contact details for Authorities Having Jurisdiction (AHJ) on-behalf-of local Public Safety Answering Points (PSAP). 911/PSAP accepts an address and returns PSAP contact data plus contact data for an AHJ to communicate directly with a PSAP. Details include agency name, phone number, city name, coverage, contact person\'s details, site details and mailing addresses for EMS, Fire, and Police PSAP contacts.
         * @summary AHJ & PSAP By Address.
         * @param {string} address The address to be searched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAHJPlusPSAPByAddress(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AHJPlusPSAPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAHJPlusPSAPByAddress(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts latitude & longitude as input and Returns contact details for Authorities Having Jurisdiction (AHJ) on-behalf-of local Public Safety Answering Points (PSAP). 911/PSAP accepts a location coordinate and returns PSAP contact data plus contact data for an AHJ to communicate directly with a PSAP. Details include agency name, phone number, city name, coverage, contact person\'s details, site details and mailing addresses for EMS, Fire, and Police PSAP contacts.
         * @summary AHJ & PSAP By Location
         * @param {string} longitude Longitude of the location.
         * @param {string} latitude Latitude of the location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAHJPlusPSAPByLocation(longitude: string, latitude: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AHJPlusPSAPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAHJPlusPSAPByLocation(longitude, latitude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts addresses as input and Returns contact details for local Public Safety Answering Points (PSAP). 911/PSAP accepts an address as input and returns the relevant PSAP address and contact details including agency name, phone number, county name, coverage, contact person\'s details, site details and mailing address.
         * @summary PSAP By Address.
         * @param {string} address The address to be searched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPSAPByAddress(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PSAPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPSAPByAddress(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts latitude & longitude as input and Returns contact details for local Public Safety Answering Points (PSAP). 911/PSAP accepts a location coordinate and returns the relevant PSAP address and contact details including dispatch name, phone number, county name, coverage, contact person\'s details, site details and mailing address.
         * @summary PSAP By Location.
         * @param {string} longitude Longitude of the location.
         * @param {string} latitude Latitude of the location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPSAPByLocation(longitude: string, latitude: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PSAPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPSAPByLocation(longitude, latitude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts fccid as input and Returns contact details for Authorities Having Jurisdiction (AHJ) on-behalf-of local Public Safety Answering Points (PSAP). 911/PSAP accepts a location coordinate and returns PSAP contact data plus contact data for an AHJ to communicate directly with a PSAP. Details include agency name, phone number, city name, coverage, contact person\'s details, site details and mailing addresses for EMS, Fire, and Police PSAP contacts.
         * @summary AHJ & PSAP By Fccid
         * @param {string} fccId fccId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchByFccId(fccId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AHJPlusPSAPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchByFccId(fccId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PSAP911ServiceApi - factory interface
 * @export
 */
export const PSAP911ServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PSAP911ServiceApiFp(oAuth,configuration)
    return {
        /**
         * Accepts addresses as input and Returns contact details for Authorities Having Jurisdiction (AHJ) on-behalf-of local Public Safety Answering Points (PSAP). 911/PSAP accepts an address and returns PSAP contact data plus contact data for an AHJ to communicate directly with a PSAP. Details include agency name, phone number, city name, coverage, contact person\'s details, site details and mailing addresses for EMS, Fire, and Police PSAP contacts.
         * @summary AHJ & PSAP By Address.
         * @param {string} address The address to be searched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAHJPlusPSAPByAddress(address: string, options?: any): AxiosPromise<AHJPlusPSAPResponse> {
            return localVarFp.getAHJPlusPSAPByAddress(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts latitude & longitude as input and Returns contact details for Authorities Having Jurisdiction (AHJ) on-behalf-of local Public Safety Answering Points (PSAP). 911/PSAP accepts a location coordinate and returns PSAP contact data plus contact data for an AHJ to communicate directly with a PSAP. Details include agency name, phone number, city name, coverage, contact person\'s details, site details and mailing addresses for EMS, Fire, and Police PSAP contacts.
         * @summary AHJ & PSAP By Location
         * @param {string} longitude Longitude of the location.
         * @param {string} latitude Latitude of the location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAHJPlusPSAPByLocation(longitude: string, latitude: string, options?: any): AxiosPromise<AHJPlusPSAPResponse> {
            return localVarFp.getAHJPlusPSAPByLocation(longitude, latitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts addresses as input and Returns contact details for local Public Safety Answering Points (PSAP). 911/PSAP accepts an address as input and returns the relevant PSAP address and contact details including agency name, phone number, county name, coverage, contact person\'s details, site details and mailing address.
         * @summary PSAP By Address.
         * @param {string} address The address to be searched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPSAPByAddress(address: string, options?: any): AxiosPromise<PSAPResponse> {
            return localVarFp.getPSAPByAddress(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts latitude & longitude as input and Returns contact details for local Public Safety Answering Points (PSAP). 911/PSAP accepts a location coordinate and returns the relevant PSAP address and contact details including dispatch name, phone number, county name, coverage, contact person\'s details, site details and mailing address.
         * @summary PSAP By Location.
         * @param {string} longitude Longitude of the location.
         * @param {string} latitude Latitude of the location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPSAPByLocation(longitude: string, latitude: string, options?: any): AxiosPromise<PSAPResponse> {
            return localVarFp.getPSAPByLocation(longitude, latitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts fccid as input and Returns contact details for Authorities Having Jurisdiction (AHJ) on-behalf-of local Public Safety Answering Points (PSAP). 911/PSAP accepts a location coordinate and returns PSAP contact data plus contact data for an AHJ to communicate directly with a PSAP. Details include agency name, phone number, city name, coverage, contact person\'s details, site details and mailing addresses for EMS, Fire, and Police PSAP contacts.
         * @summary AHJ & PSAP By Fccid
         * @param {string} fccId fccId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchByFccId(fccId: string, options?: any): AxiosPromise<AHJPlusPSAPResponse> {
            return localVarFp.searchByFccId(fccId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PSAP911ServiceApi - object-oriented interface
 * @export
 * @class PSAP911ServiceApi
 * @extends {BaseAPI}
 */
export class PSAP911ServiceApi extends BaseAPI {
    /**
     * Accepts addresses as input and Returns contact details for Authorities Having Jurisdiction (AHJ) on-behalf-of local Public Safety Answering Points (PSAP). 911/PSAP accepts an address and returns PSAP contact data plus contact data for an AHJ to communicate directly with a PSAP. Details include agency name, phone number, city name, coverage, contact person\'s details, site details and mailing addresses for EMS, Fire, and Police PSAP contacts.
     * @summary AHJ & PSAP By Address.
     * @param {string} address The address to be searched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PSAP911ServiceApi
     */
    public getAHJPlusPSAPByAddress(address: string, options?: AxiosRequestConfig) {
        return PSAP911ServiceApiFp(this.oAuthCred,this.configuration).getAHJPlusPSAPByAddress(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts latitude & longitude as input and Returns contact details for Authorities Having Jurisdiction (AHJ) on-behalf-of local Public Safety Answering Points (PSAP). 911/PSAP accepts a location coordinate and returns PSAP contact data plus contact data for an AHJ to communicate directly with a PSAP. Details include agency name, phone number, city name, coverage, contact person\'s details, site details and mailing addresses for EMS, Fire, and Police PSAP contacts.
     * @summary AHJ & PSAP By Location
     * @param {string} longitude Longitude of the location.
     * @param {string} latitude Latitude of the location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PSAP911ServiceApi
     */
    public getAHJPlusPSAPByLocation(longitude: string, latitude: string, options?: AxiosRequestConfig) {
        return PSAP911ServiceApiFp(this.oAuthCred,this.configuration).getAHJPlusPSAPByLocation(longitude, latitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts addresses as input and Returns contact details for local Public Safety Answering Points (PSAP). 911/PSAP accepts an address as input and returns the relevant PSAP address and contact details including agency name, phone number, county name, coverage, contact person\'s details, site details and mailing address.
     * @summary PSAP By Address.
     * @param {string} address The address to be searched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PSAP911ServiceApi
     */
    public getPSAPByAddress(address: string, options?: AxiosRequestConfig) {
        return PSAP911ServiceApiFp(this.oAuthCred,this.configuration).getPSAPByAddress(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts latitude & longitude as input and Returns contact details for local Public Safety Answering Points (PSAP). 911/PSAP accepts a location coordinate and returns the relevant PSAP address and contact details including dispatch name, phone number, county name, coverage, contact person\'s details, site details and mailing address.
     * @summary PSAP By Location.
     * @param {string} longitude Longitude of the location.
     * @param {string} latitude Latitude of the location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PSAP911ServiceApi
     */
    public getPSAPByLocation(longitude: string, latitude: string, options?: AxiosRequestConfig) {
        return PSAP911ServiceApiFp(this.oAuthCred,this.configuration).getPSAPByLocation(longitude, latitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts fccid as input and Returns contact details for Authorities Having Jurisdiction (AHJ) on-behalf-of local Public Safety Answering Points (PSAP). 911/PSAP accepts a location coordinate and returns PSAP contact data plus contact data for an AHJ to communicate directly with a PSAP. Details include agency name, phone number, city name, coverage, contact person\'s details, site details and mailing addresses for EMS, Fire, and Police PSAP contacts.
     * @summary AHJ & PSAP By Fccid
     * @param {string} fccId fccId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PSAP911ServiceApi
     */
    public searchByFccId(fccId: string, options?: AxiosRequestConfig) {
        return PSAP911ServiceApiFp(this.oAuthCred,this.configuration).searchByFccId(fccId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PhoneVerificationServiceApi - axios parameter creator
 * @export
 */
export const PhoneVerificationServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * This service accepts a phone number as input and returns details distinguishing landline and wireless numbers.
         * @summary Phone verification.
         * @param {ValidatePhoneNumberAPIRequest} validatePhoneNumberAPIRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatephonenumber: async (validatePhoneNumberAPIRequest: ValidatePhoneNumberAPIRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatePhoneNumberAPIRequest' is not null or undefined
            assertParamExists('validatephonenumber', 'validatePhoneNumberAPIRequest', validatePhoneNumberAPIRequest)
            const localVarPath = `/phoneverification/v2/validatephonenumber/results.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validatePhoneNumberAPIRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PhoneVerificationServiceApi - functional programming interface
 * @export
 */
export const PhoneVerificationServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = PhoneVerificationServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * This service accepts a phone number as input and returns details distinguishing landline and wireless numbers.
         * @summary Phone verification.
         * @param {ValidatePhoneNumberAPIRequest} validatePhoneNumberAPIRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatephonenumber(validatePhoneNumberAPIRequest: ValidatePhoneNumberAPIRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhoneVerification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatephonenumber(validatePhoneNumberAPIRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PhoneVerificationServiceApi - factory interface
 * @export
 */
export const PhoneVerificationServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PhoneVerificationServiceApiFp(oAuth,configuration)
    return {
        /**
         * This service accepts a phone number as input and returns details distinguishing landline and wireless numbers.
         * @summary Phone verification.
         * @param {ValidatePhoneNumberAPIRequest} validatePhoneNumberAPIRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatephonenumber(validatePhoneNumberAPIRequest: ValidatePhoneNumberAPIRequest, options?: any): AxiosPromise<PhoneVerification> {
            return localVarFp.validatephonenumber(validatePhoneNumberAPIRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PhoneVerificationServiceApi - object-oriented interface
 * @export
 * @class PhoneVerificationServiceApi
 * @extends {BaseAPI}
 */
export class PhoneVerificationServiceApi extends BaseAPI {
    /**
     * This service accepts a phone number as input and returns details distinguishing landline and wireless numbers.
     * @summary Phone verification.
     * @param {ValidatePhoneNumberAPIRequest} validatePhoneNumberAPIRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhoneVerificationServiceApi
     */
    public validatephonenumber(validatePhoneNumberAPIRequest: ValidatePhoneNumberAPIRequest, options?: AxiosRequestConfig) {
        return PhoneVerificationServiceApiFp(this.oAuthCred,this.configuration).validatephonenumber(validatePhoneNumberAPIRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlacesServiceApi - axios parameter creator
 * @export
 */
export const PlacesServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * This service returns a list of Category codes & associated metadata which can then be used as inputs for querying the Points of Interest By Address or Location methods listed above.
         * @summary Category Code Metadata.
         * @param {string} [categoryCode] 4, 6, or 11 digits category code to filter the response.
         * @param {string} [level] 1, 2, or 3.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryCodeMetadata: async (categoryCode?: string, level?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/places/v1/metadata/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (categoryCode !== undefined) {
                localVarQueryParameter['categoryCode'] = categoryCode;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service returns complete details of a chosen point of interest by an identifier. The identifier could be selected from Autocomplete API response.
         * @summary Points Of Interest Details By Id
         * @param {string} id POI unique Identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPOIById', 'id', id)
            const localVarPath = `/places/v1/poi/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service accepts an address as input and returns nearby points-of-interest places around that address. Additional input features include retrieving data by name, type, standard industrial classifications and category codes, as well as geographic filtering by radius, travel times and travel distances. Response features include JSON/XML as well as CSV download.
         * @summary Get POIs By Address.
         * @param {string} [address] The address to be searched.
         * @param {string} [country] Country ISO code.
         * @param {string} [name] Specifies the name of the place (POI) to be searched. Also performs search on partially specified names. It requires minimum 3 characters to search.
         * @param {string} [type] Filters the points of interest (POIs) by place types.
         * @param {string} [categoryCode] Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values.
         * @param {string} [sicCode] Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values
         * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved
         * @param {string} [searchRadius] Radius range within which search is performed.
         * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters (default).
         * @param {string} [travelTime] Travel time within which search is performed (POIs which can be reached within travel time).
         * @param {string} [travelTimeUnit] Travel time unit such as minutes (default), hours, seconds or milliseconds.
         * @param {string} [travelDistance] Travel distance within which search is performed (POIs which can be reached within travel distance).
         * @param {string} [travelDistanceUnit] Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
         * @param {string} [travelMode] Mode of commute.
         * @param {string} [sortBy] Whether to sort the results based on relevance (best match) or by nearest distance from input location.
         * @param {string} [fuzzyOnName] Whether to allow fuzzy seacrh on name input.
         * @param {string} [page] Specifies the page number of results where page size is the value of maxCandidates input in request.
         * @param {string} [matchMode] Determine the leniency used to make a match between the input name and the reference data.
         * @param {string} [specificMatchOn] Specifies the field for the Specific Match Mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIsByAddress: async (address?: string, country?: string, name?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, sortBy?: string, fuzzyOnName?: string, page?: string, matchMode?: string, specificMatchOn?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/places/v1/poi/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (categoryCode !== undefined) {
                localVarQueryParameter['categoryCode'] = categoryCode;
            }

            if (sicCode !== undefined) {
                localVarQueryParameter['sicCode'] = sicCode;
            }

            if (maxCandidates !== undefined) {
                localVarQueryParameter['maxCandidates'] = maxCandidates;
            }

            if (searchRadius !== undefined) {
                localVarQueryParameter['searchRadius'] = searchRadius;
            }

            if (searchRadiusUnit !== undefined) {
                localVarQueryParameter['searchRadiusUnit'] = searchRadiusUnit;
            }

            if (travelTime !== undefined) {
                localVarQueryParameter['travelTime'] = travelTime;
            }

            if (travelTimeUnit !== undefined) {
                localVarQueryParameter['travelTimeUnit'] = travelTimeUnit;
            }

            if (travelDistance !== undefined) {
                localVarQueryParameter['travelDistance'] = travelDistance;
            }

            if (travelDistanceUnit !== undefined) {
                localVarQueryParameter['travelDistanceUnit'] = travelDistanceUnit;
            }

            if (travelMode !== undefined) {
                localVarQueryParameter['travelMode'] = travelMode;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (fuzzyOnName !== undefined) {
                localVarQueryParameter['fuzzyOnName'] = fuzzyOnName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (matchMode !== undefined) {
                localVarQueryParameter['matchMode'] = matchMode;
            }

            if (specificMatchOn !== undefined) {
                localVarQueryParameter['specificMatchOn'] = specificMatchOn;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service accepts city or postcode (alongwith country) and returns points-of-interest places within a city or postcode. Additional input features include retrieving data by name, type, standard industrial classifications and category codes, as well as geographic filtering by radius, travel times and travel distances. Response features include JSON/XML as well as CSV download.
         * @summary GET Points Of Interest By Area.
         * @param {string} [areaName1] Specifies the largest geographical area, typically a state or province
         * @param {string} [areaName3] Specifies a city or town name
         * @param {string} [postcode1] Specifies the postcode(ZIP code) in the appropriate format for the country
         * @param {string} [postcode2] Specifies the postcode(ZIP code) extension
         * @param {string} [country] Country ISO code
         * @param {string} [name] Specifies the name of the place (POI) to be searched. Also performs search on partially specified names. It requires minimum 3 characters to search
         * @param {string} [type] Filters the points of interest (POIs) by place types
         * @param {string} [categoryCode] Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values
         * @param {string} [sicCode] Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values
         * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved
         * @param {string} [fuzzyOnName] Whether to allow fuzzy seacrh on name input
         * @param {string} [page] Specifies the page number of results where page size is the value of maxCandidates input in request
         * @param {string} [matchMode] Determine the leniency used to make a match between the input name and the reference data
         * @param {string} [specificMatchOn] Specifies the field for the Specific Match Mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIsByArea: async (areaName1?: string, areaName3?: string, postcode1?: string, postcode2?: string, country?: string, name?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, fuzzyOnName?: string, page?: string, matchMode?: string, specificMatchOn?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/places/v1/poi/byarea`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (areaName1 !== undefined) {
                localVarQueryParameter['areaName1'] = areaName1;
            }

            if (areaName3 !== undefined) {
                localVarQueryParameter['areaName3'] = areaName3;
            }

            if (postcode1 !== undefined) {
                localVarQueryParameter['postcode1'] = postcode1;
            }

            if (postcode2 !== undefined) {
                localVarQueryParameter['postcode2'] = postcode2;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (categoryCode !== undefined) {
                localVarQueryParameter['categoryCode'] = categoryCode;
            }

            if (sicCode !== undefined) {
                localVarQueryParameter['sicCode'] = sicCode;
            }

            if (maxCandidates !== undefined) {
                localVarQueryParameter['maxCandidates'] = maxCandidates;
            }

            if (fuzzyOnName !== undefined) {
                localVarQueryParameter['fuzzyOnName'] = fuzzyOnName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (matchMode !== undefined) {
                localVarQueryParameter['matchMode'] = matchMode;
            }

            if (specificMatchOn !== undefined) {
                localVarQueryParameter['specificMatchOn'] = specificMatchOn;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts a user-defined boundary as input and returns all Points of Interest within the boundary. Additionally, user can filter the response by name, type, standard industrial classifications and category codes.
         * @summary Points Of Interest By Boundary
         * @param {POIByGeometryRequest} pOIByGeometryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIsByGeometry: async (pOIByGeometryRequest: POIByGeometryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pOIByGeometryRequest' is not null or undefined
            assertParamExists('getPOIsByGeometry', 'pOIByGeometryRequest', pOIByGeometryRequest)
            const localVarPath = `/places/v1/poi/byboundary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pOIByGeometryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service accepts latitude/longitude as input and returns nearby points-of-interest places around that location. Additional input features include retrieving data by name, type, standard industrial classifications and category codes, as well as geographic filtering by radius, travel times and travel distances. Response features include JSON/XML as well as CSV download
         * @summary Get POIs By Location.
         * @param {string} longitude Longitude of the location.
         * @param {string} latitude Latitude of the location.
         * @param {string} [name] Specifies the name of the place (POI) to be searched. Also performs search on partially specified names. It requires minimum 3 characters to search.
         * @param {string} [type] Filters the points of interest (POIs) by place types.
         * @param {string} [categoryCode] Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values.
         * @param {string} [sicCode] Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values
         * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved
         * @param {string} [searchRadius] Radius range within which search is performed.
         * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters (default).
         * @param {string} [travelTime] Travel time within which search is performed (POIs which can be reached within travel time).
         * @param {string} [travelTimeUnit] Travel time unit such as minutes (default), hours, seconds or milliseconds.
         * @param {string} [travelDistance] Travel distance within which search is performed (POIs which can be reached within travel distance).
         * @param {string} [travelDistanceUnit] Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
         * @param {string} [travelMode] Mode of commute.
         * @param {string} [sortBy] Whether to sort the results based on relevance (best match) or by nearest distance from input location.
         * @param {string} [fuzzyOnName] Whether to allow fuzzy seacrh on name input.
         * @param {string} [page] Specifies the page number of results where page size is the value of maxCandidates input in request.
         * @param {string} [matchMode] Determine the leniency used to make a match between the input name and the reference data.
         * @param {string} [specificMatchOn] Specifies the field for the Specific Match Mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIsByLocation: async (longitude: string, latitude: string, name?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, sortBy?: string, fuzzyOnName?: string, page?: string, matchMode?: string, specificMatchOn?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('getPOIsByLocation', 'longitude', longitude)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('getPOIsByLocation', 'latitude', latitude)
            const localVarPath = `/places/v1/poi/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (categoryCode !== undefined) {
                localVarQueryParameter['categoryCode'] = categoryCode;
            }

            if (sicCode !== undefined) {
                localVarQueryParameter['sicCode'] = sicCode;
            }

            if (maxCandidates !== undefined) {
                localVarQueryParameter['maxCandidates'] = maxCandidates;
            }

            if (searchRadius !== undefined) {
                localVarQueryParameter['searchRadius'] = searchRadius;
            }

            if (searchRadiusUnit !== undefined) {
                localVarQueryParameter['searchRadiusUnit'] = searchRadiusUnit;
            }

            if (travelTime !== undefined) {
                localVarQueryParameter['travelTime'] = travelTime;
            }

            if (travelTimeUnit !== undefined) {
                localVarQueryParameter['travelTimeUnit'] = travelTimeUnit;
            }

            if (travelDistance !== undefined) {
                localVarQueryParameter['travelDistance'] = travelDistance;
            }

            if (travelDistanceUnit !== undefined) {
                localVarQueryParameter['travelDistanceUnit'] = travelDistanceUnit;
            }

            if (travelMode !== undefined) {
                localVarQueryParameter['travelMode'] = travelMode;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (fuzzyOnName !== undefined) {
                localVarQueryParameter['fuzzyOnName'] = fuzzyOnName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (matchMode !== undefined) {
                localVarQueryParameter['matchMode'] = matchMode;
            }

            if (specificMatchOn !== undefined) {
                localVarQueryParameter['specificMatchOn'] = specificMatchOn;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts a user-defined boundary as input and returns the Count number of POIs within the boundary. Additionally, user can request the count of filtered POIs by name, type, standard industrial classifications and category codes within the given polygon.
         * @summary Points Of Interest Count
         * @param {string} contentType 
         * @param {PoiCountRequest} poiCountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIsCount: async (contentType: string, poiCountRequest: PoiCountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getPOIsCount', 'contentType', contentType)
            // verify required parameter 'poiCountRequest' is not null or undefined
            assertParamExists('getPOIsCount', 'poiCountRequest', poiCountRequest)
            const localVarPath = `/places/v1/poicount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(poiCountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service returns a list of standard industrial classification codes & associated metadata which can then be used as inputs for querying the Points of Interest By Address or Location methods listed above.
         * @summary Get SIC Metadata
         * @param {string} [sicCode] 4 or 8 digits SIC code to filter the response.
         * @param {string} [level] 1 or 2.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSICMetadata: async (sicCode?: string, level?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/places/v1/metadata/sic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (sicCode !== undefined) {
                localVarQueryParameter['sicCode'] = sicCode;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service accepts partial text input and returns matching points of interest, sorted by relevance or distance.
         * @summary Points Of Interest Autocomplete
         * @param {string} [xForwardedFor] 
         * @param {string} [longitude] Longitude of the location.
         * @param {string} [latitude] Latitude of the location.
         * @param {string} [searchText] Free text which will accept a multi-word string. Combination of POI name and address is possible.
         * @param {string} [searchOnNameOnly] 
         * @param {string} [searchRadius] Radius range within which search is performed.
         * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters (default).
         * @param {string} [travelTime] Travel time within which search is performed (POIs which can be reached within travel time).
         * @param {string} [travelTimeUnit] Travel time unit such as minutes (default), hours, seconds or milliseconds.
         * @param {string} [travelDistance] Travel distance within which search is performed (POIs which can be reached within travel distance).
         * @param {string} [travelDistanceUnit] Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
         * @param {string} [travelMode] Mode of commute.
         * @param {string} [country] Country ISO code.
         * @param {string} [areaName1] Specifies the largest geographical area, typically a state or province.
         * @param {string} [areaName3] Specifies a city or town name.
         * @param {string} [postcode1] Specifies the postcode(ZIP code) in the appropriate format for the country.
         * @param {string} [postcode2] Specifies the postcode(ZIP code) extension.
         * @param {string} [ipAddress] IP address which will be used to auto detect the location in order to serve contextually relevant results.
         * @param {string} [autoDetectLocation] Specifies whether to detect client\&#39;s location using IP address. If IP address(below) is not provided and autoDetectLocation is set \&#39;True\&#39; then IP address will be picked from HTTP request automatically.
         * @param {string} [type] Filters the points of interest (POIs) by place types.
         * @param {string} [categoryCode] Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values.
         * @param {string} [sicCode] Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values.
         * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved.
         * @param {string} [sortBy] sortBy
         * @param {string} [matchMode] Determine the leniency used to make a match between the input name and the reference data.
         * @param {string} [specificMatchOn] Specifies the field for the Specific Match Mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poisAutocomplete: async (xForwardedFor?: string, longitude?: string, latitude?: string, searchText?: string, searchOnNameOnly?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, country?: string, areaName1?: string, areaName3?: string, postcode1?: string, postcode2?: string, ipAddress?: string, autoDetectLocation?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, sortBy?: string, matchMode?: string, specificMatchOn?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/places/v1/poi/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (searchOnNameOnly !== undefined) {
                localVarQueryParameter['searchOnNameOnly'] = searchOnNameOnly;
            }

            if (searchRadius !== undefined) {
                localVarQueryParameter['searchRadius'] = searchRadius;
            }

            if (searchRadiusUnit !== undefined) {
                localVarQueryParameter['searchRadiusUnit'] = searchRadiusUnit;
            }

            if (travelTime !== undefined) {
                localVarQueryParameter['travelTime'] = travelTime;
            }

            if (travelTimeUnit !== undefined) {
                localVarQueryParameter['travelTimeUnit'] = travelTimeUnit;
            }

            if (travelDistance !== undefined) {
                localVarQueryParameter['travelDistance'] = travelDistance;
            }

            if (travelDistanceUnit !== undefined) {
                localVarQueryParameter['travelDistanceUnit'] = travelDistanceUnit;
            }

            if (travelMode !== undefined) {
                localVarQueryParameter['travelMode'] = travelMode;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (areaName1 !== undefined) {
                localVarQueryParameter['areaName1'] = areaName1;
            }

            if (areaName3 !== undefined) {
                localVarQueryParameter['areaName3'] = areaName3;
            }

            if (postcode1 !== undefined) {
                localVarQueryParameter['postcode1'] = postcode1;
            }

            if (postcode2 !== undefined) {
                localVarQueryParameter['postcode2'] = postcode2;
            }

            if (ipAddress !== undefined) {
                localVarQueryParameter['ipAddress'] = ipAddress;
            }

            if (autoDetectLocation !== undefined) {
                localVarQueryParameter['autoDetectLocation'] = autoDetectLocation;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (categoryCode !== undefined) {
                localVarQueryParameter['categoryCode'] = categoryCode;
            }

            if (sicCode !== undefined) {
                localVarQueryParameter['sicCode'] = sicCode;
            }

            if (maxCandidates !== undefined) {
                localVarQueryParameter['maxCandidates'] = maxCandidates;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (matchMode !== undefined) {
                localVarQueryParameter['matchMode'] = matchMode;
            }

            if (specificMatchOn !== undefined) {
                localVarQueryParameter['specificMatchOn'] = specificMatchOn;
            }

            if (xForwardedFor != null) {
                localVarHeaderParameter['X-Forwarded-For'] = String(xForwardedFor);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlacesServiceApi - functional programming interface
 * @export
 */
export const PlacesServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = PlacesServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * This service returns a list of Category codes & associated metadata which can then be used as inputs for querying the Points of Interest By Address or Location methods listed above.
         * @summary Category Code Metadata.
         * @param {string} [categoryCode] 4, 6, or 11 digits category code to filter the response.
         * @param {string} [level] 1, 2, or 3.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryCodeMetadata(categoryCode?: string, level?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryCodeMetadata(categoryCode, level, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This service returns complete details of a chosen point of interest by an identifier. The identifier could be selected from Autocomplete API response.
         * @summary Points Of Interest Details By Id
         * @param {string} id POI unique Identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPOIById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Poi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPOIById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This service accepts an address as input and returns nearby points-of-interest places around that address. Additional input features include retrieving data by name, type, standard industrial classifications and category codes, as well as geographic filtering by radius, travel times and travel distances. Response features include JSON/XML as well as CSV download.
         * @summary Get POIs By Address.
         * @param {string} [address] The address to be searched.
         * @param {string} [country] Country ISO code.
         * @param {string} [name] Specifies the name of the place (POI) to be searched. Also performs search on partially specified names. It requires minimum 3 characters to search.
         * @param {string} [type] Filters the points of interest (POIs) by place types.
         * @param {string} [categoryCode] Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values.
         * @param {string} [sicCode] Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values
         * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved
         * @param {string} [searchRadius] Radius range within which search is performed.
         * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters (default).
         * @param {string} [travelTime] Travel time within which search is performed (POIs which can be reached within travel time).
         * @param {string} [travelTimeUnit] Travel time unit such as minutes (default), hours, seconds or milliseconds.
         * @param {string} [travelDistance] Travel distance within which search is performed (POIs which can be reached within travel distance).
         * @param {string} [travelDistanceUnit] Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
         * @param {string} [travelMode] Mode of commute.
         * @param {string} [sortBy] Whether to sort the results based on relevance (best match) or by nearest distance from input location.
         * @param {string} [fuzzyOnName] Whether to allow fuzzy seacrh on name input.
         * @param {string} [page] Specifies the page number of results where page size is the value of maxCandidates input in request.
         * @param {string} [matchMode] Determine the leniency used to make a match between the input name and the reference data.
         * @param {string} [specificMatchOn] Specifies the field for the Specific Match Mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPOIsByAddress(address?: string, country?: string, name?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, sortBy?: string, fuzzyOnName?: string, page?: string, matchMode?: string, specificMatchOn?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlacesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPOIsByAddress(address, country, name, type, categoryCode, sicCode, maxCandidates, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, sortBy, fuzzyOnName, page, matchMode, specificMatchOn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This service accepts city or postcode (alongwith country) and returns points-of-interest places within a city or postcode. Additional input features include retrieving data by name, type, standard industrial classifications and category codes, as well as geographic filtering by radius, travel times and travel distances. Response features include JSON/XML as well as CSV download.
         * @summary GET Points Of Interest By Area.
         * @param {string} [areaName1] Specifies the largest geographical area, typically a state or province
         * @param {string} [areaName3] Specifies a city or town name
         * @param {string} [postcode1] Specifies the postcode(ZIP code) in the appropriate format for the country
         * @param {string} [postcode2] Specifies the postcode(ZIP code) extension
         * @param {string} [country] Country ISO code
         * @param {string} [name] Specifies the name of the place (POI) to be searched. Also performs search on partially specified names. It requires minimum 3 characters to search
         * @param {string} [type] Filters the points of interest (POIs) by place types
         * @param {string} [categoryCode] Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values
         * @param {string} [sicCode] Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values
         * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved
         * @param {string} [fuzzyOnName] Whether to allow fuzzy seacrh on name input
         * @param {string} [page] Specifies the page number of results where page size is the value of maxCandidates input in request
         * @param {string} [matchMode] Determine the leniency used to make a match between the input name and the reference data
         * @param {string} [specificMatchOn] Specifies the field for the Specific Match Mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPOIsByArea(areaName1?: string, areaName3?: string, postcode1?: string, postcode2?: string, country?: string, name?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, fuzzyOnName?: string, page?: string, matchMode?: string, specificMatchOn?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlacesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPOIsByArea(areaName1, areaName3, postcode1, postcode2, country, name, type, categoryCode, sicCode, maxCandidates, fuzzyOnName, page, matchMode, specificMatchOn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts a user-defined boundary as input and returns all Points of Interest within the boundary. Additionally, user can filter the response by name, type, standard industrial classifications and category codes.
         * @summary Points Of Interest By Boundary
         * @param {POIByGeometryRequest} pOIByGeometryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPOIsByGeometry(pOIByGeometryRequest: POIByGeometryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlacesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPOIsByGeometry(pOIByGeometryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This service accepts latitude/longitude as input and returns nearby points-of-interest places around that location. Additional input features include retrieving data by name, type, standard industrial classifications and category codes, as well as geographic filtering by radius, travel times and travel distances. Response features include JSON/XML as well as CSV download
         * @summary Get POIs By Location.
         * @param {string} longitude Longitude of the location.
         * @param {string} latitude Latitude of the location.
         * @param {string} [name] Specifies the name of the place (POI) to be searched. Also performs search on partially specified names. It requires minimum 3 characters to search.
         * @param {string} [type] Filters the points of interest (POIs) by place types.
         * @param {string} [categoryCode] Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values.
         * @param {string} [sicCode] Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values
         * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved
         * @param {string} [searchRadius] Radius range within which search is performed.
         * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters (default).
         * @param {string} [travelTime] Travel time within which search is performed (POIs which can be reached within travel time).
         * @param {string} [travelTimeUnit] Travel time unit such as minutes (default), hours, seconds or milliseconds.
         * @param {string} [travelDistance] Travel distance within which search is performed (POIs which can be reached within travel distance).
         * @param {string} [travelDistanceUnit] Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
         * @param {string} [travelMode] Mode of commute.
         * @param {string} [sortBy] Whether to sort the results based on relevance (best match) or by nearest distance from input location.
         * @param {string} [fuzzyOnName] Whether to allow fuzzy seacrh on name input.
         * @param {string} [page] Specifies the page number of results where page size is the value of maxCandidates input in request.
         * @param {string} [matchMode] Determine the leniency used to make a match between the input name and the reference data.
         * @param {string} [specificMatchOn] Specifies the field for the Specific Match Mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPOIsByLocation(longitude: string, latitude: string, name?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, sortBy?: string, fuzzyOnName?: string, page?: string, matchMode?: string, specificMatchOn?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlacesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPOIsByLocation(longitude, latitude, name, type, categoryCode, sicCode, maxCandidates, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, sortBy, fuzzyOnName, page, matchMode, specificMatchOn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts a user-defined boundary as input and returns the Count number of POIs within the boundary. Additionally, user can request the count of filtered POIs by name, type, standard industrial classifications and category codes within the given polygon.
         * @summary Points Of Interest Count
         * @param {string} contentType 
         * @param {PoiCountRequest} poiCountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPOIsCount(contentType: string, poiCountRequest: PoiCountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoiCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPOIsCount(contentType, poiCountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This service returns a list of standard industrial classification codes & associated metadata which can then be used as inputs for querying the Points of Interest By Address or Location methods listed above.
         * @summary Get SIC Metadata
         * @param {string} [sicCode] 4 or 8 digits SIC code to filter the response.
         * @param {string} [level] 1 or 2.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSICMetadata(sicCode?: string, level?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSICMetadata(sicCode, level, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This service accepts partial text input and returns matching points of interest, sorted by relevance or distance.
         * @summary Points Of Interest Autocomplete
         * @param {string} [xForwardedFor] 
         * @param {string} [longitude] Longitude of the location.
         * @param {string} [latitude] Latitude of the location.
         * @param {string} [searchText] Free text which will accept a multi-word string. Combination of POI name and address is possible.
         * @param {string} [searchOnNameOnly] 
         * @param {string} [searchRadius] Radius range within which search is performed.
         * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters (default).
         * @param {string} [travelTime] Travel time within which search is performed (POIs which can be reached within travel time).
         * @param {string} [travelTimeUnit] Travel time unit such as minutes (default), hours, seconds or milliseconds.
         * @param {string} [travelDistance] Travel distance within which search is performed (POIs which can be reached within travel distance).
         * @param {string} [travelDistanceUnit] Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
         * @param {string} [travelMode] Mode of commute.
         * @param {string} [country] Country ISO code.
         * @param {string} [areaName1] Specifies the largest geographical area, typically a state or province.
         * @param {string} [areaName3] Specifies a city or town name.
         * @param {string} [postcode1] Specifies the postcode(ZIP code) in the appropriate format for the country.
         * @param {string} [postcode2] Specifies the postcode(ZIP code) extension.
         * @param {string} [ipAddress] IP address which will be used to auto detect the location in order to serve contextually relevant results.
         * @param {string} [autoDetectLocation] Specifies whether to detect client\&#39;s location using IP address. If IP address(below) is not provided and autoDetectLocation is set \&#39;True\&#39; then IP address will be picked from HTTP request automatically.
         * @param {string} [type] Filters the points of interest (POIs) by place types.
         * @param {string} [categoryCode] Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values.
         * @param {string} [sicCode] Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values.
         * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved.
         * @param {string} [sortBy] sortBy
         * @param {string} [matchMode] Determine the leniency used to make a match between the input name and the reference data.
         * @param {string} [specificMatchOn] Specifies the field for the Specific Match Mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async poisAutocomplete(xForwardedFor?: string, longitude?: string, latitude?: string, searchText?: string, searchOnNameOnly?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, country?: string, areaName1?: string, areaName3?: string, postcode1?: string, postcode2?: string, ipAddress?: string, autoDetectLocation?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, sortBy?: string, matchMode?: string, specificMatchOn?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlacesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.poisAutocomplete(xForwardedFor, longitude, latitude, searchText, searchOnNameOnly, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, country, areaName1, areaName3, postcode1, postcode2, ipAddress, autoDetectLocation, type, categoryCode, sicCode, maxCandidates, sortBy, matchMode, specificMatchOn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlacesServiceApi - factory interface
 * @export
 */
export const PlacesServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlacesServiceApiFp(oAuth,configuration)
    return {
        /**
         * This service returns a list of Category codes & associated metadata which can then be used as inputs for querying the Points of Interest By Address or Location methods listed above.
         * @summary Category Code Metadata.
         * @param {string} [categoryCode] 4, 6, or 11 digits category code to filter the response.
         * @param {string} [level] 1, 2, or 3.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryCodeMetadata(categoryCode?: string, level?: string, options?: any): AxiosPromise<MetadataResponse> {
            return localVarFp.getCategoryCodeMetadata(categoryCode, level, options).then((request) => request(axios, basePath));
        },
        /**
         * This service returns complete details of a chosen point of interest by an identifier. The identifier could be selected from Autocomplete API response.
         * @summary Points Of Interest Details By Id
         * @param {string} id POI unique Identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIById(id: string, options?: any): AxiosPromise<Poi> {
            return localVarFp.getPOIById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This service accepts an address as input and returns nearby points-of-interest places around that address. Additional input features include retrieving data by name, type, standard industrial classifications and category codes, as well as geographic filtering by radius, travel times and travel distances. Response features include JSON/XML as well as CSV download.
         * @summary Get POIs By Address.
         * @param {string} [address] The address to be searched.
         * @param {string} [country] Country ISO code.
         * @param {string} [name] Specifies the name of the place (POI) to be searched. Also performs search on partially specified names. It requires minimum 3 characters to search.
         * @param {string} [type] Filters the points of interest (POIs) by place types.
         * @param {string} [categoryCode] Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values.
         * @param {string} [sicCode] Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values
         * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved
         * @param {string} [searchRadius] Radius range within which search is performed.
         * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters (default).
         * @param {string} [travelTime] Travel time within which search is performed (POIs which can be reached within travel time).
         * @param {string} [travelTimeUnit] Travel time unit such as minutes (default), hours, seconds or milliseconds.
         * @param {string} [travelDistance] Travel distance within which search is performed (POIs which can be reached within travel distance).
         * @param {string} [travelDistanceUnit] Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
         * @param {string} [travelMode] Mode of commute.
         * @param {string} [sortBy] Whether to sort the results based on relevance (best match) or by nearest distance from input location.
         * @param {string} [fuzzyOnName] Whether to allow fuzzy seacrh on name input.
         * @param {string} [page] Specifies the page number of results where page size is the value of maxCandidates input in request.
         * @param {string} [matchMode] Determine the leniency used to make a match between the input name and the reference data.
         * @param {string} [specificMatchOn] Specifies the field for the Specific Match Mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIsByAddress(address?: string, country?: string, name?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, sortBy?: string, fuzzyOnName?: string, page?: string, matchMode?: string, specificMatchOn?: string, options?: any): AxiosPromise<PlacesResponse> {
            return localVarFp.getPOIsByAddress(address, country, name, type, categoryCode, sicCode, maxCandidates, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, sortBy, fuzzyOnName, page, matchMode, specificMatchOn, options).then((request) => request(axios, basePath));
        },
        /**
         * This service accepts city or postcode (alongwith country) and returns points-of-interest places within a city or postcode. Additional input features include retrieving data by name, type, standard industrial classifications and category codes, as well as geographic filtering by radius, travel times and travel distances. Response features include JSON/XML as well as CSV download.
         * @summary GET Points Of Interest By Area.
         * @param {string} [areaName1] Specifies the largest geographical area, typically a state or province
         * @param {string} [areaName3] Specifies a city or town name
         * @param {string} [postcode1] Specifies the postcode(ZIP code) in the appropriate format for the country
         * @param {string} [postcode2] Specifies the postcode(ZIP code) extension
         * @param {string} [country] Country ISO code
         * @param {string} [name] Specifies the name of the place (POI) to be searched. Also performs search on partially specified names. It requires minimum 3 characters to search
         * @param {string} [type] Filters the points of interest (POIs) by place types
         * @param {string} [categoryCode] Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values
         * @param {string} [sicCode] Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values
         * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved
         * @param {string} [fuzzyOnName] Whether to allow fuzzy seacrh on name input
         * @param {string} [page] Specifies the page number of results where page size is the value of maxCandidates input in request
         * @param {string} [matchMode] Determine the leniency used to make a match between the input name and the reference data
         * @param {string} [specificMatchOn] Specifies the field for the Specific Match Mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIsByArea(areaName1?: string, areaName3?: string, postcode1?: string, postcode2?: string, country?: string, name?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, fuzzyOnName?: string, page?: string, matchMode?: string, specificMatchOn?: string, options?: any): AxiosPromise<PlacesResponse> {
            return localVarFp.getPOIsByArea(areaName1, areaName3, postcode1, postcode2, country, name, type, categoryCode, sicCode, maxCandidates, fuzzyOnName, page, matchMode, specificMatchOn, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts a user-defined boundary as input and returns all Points of Interest within the boundary. Additionally, user can filter the response by name, type, standard industrial classifications and category codes.
         * @summary Points Of Interest By Boundary
         * @param {POIByGeometryRequest} pOIByGeometryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIsByGeometry(pOIByGeometryRequest: POIByGeometryRequest, options?: any): AxiosPromise<PlacesResponse> {
            return localVarFp.getPOIsByGeometry(pOIByGeometryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This service accepts latitude/longitude as input and returns nearby points-of-interest places around that location. Additional input features include retrieving data by name, type, standard industrial classifications and category codes, as well as geographic filtering by radius, travel times and travel distances. Response features include JSON/XML as well as CSV download
         * @summary Get POIs By Location.
         * @param {string} longitude Longitude of the location.
         * @param {string} latitude Latitude of the location.
         * @param {string} [name] Specifies the name of the place (POI) to be searched. Also performs search on partially specified names. It requires minimum 3 characters to search.
         * @param {string} [type] Filters the points of interest (POIs) by place types.
         * @param {string} [categoryCode] Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values.
         * @param {string} [sicCode] Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values
         * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved
         * @param {string} [searchRadius] Radius range within which search is performed.
         * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters (default).
         * @param {string} [travelTime] Travel time within which search is performed (POIs which can be reached within travel time).
         * @param {string} [travelTimeUnit] Travel time unit such as minutes (default), hours, seconds or milliseconds.
         * @param {string} [travelDistance] Travel distance within which search is performed (POIs which can be reached within travel distance).
         * @param {string} [travelDistanceUnit] Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
         * @param {string} [travelMode] Mode of commute.
         * @param {string} [sortBy] Whether to sort the results based on relevance (best match) or by nearest distance from input location.
         * @param {string} [fuzzyOnName] Whether to allow fuzzy seacrh on name input.
         * @param {string} [page] Specifies the page number of results where page size is the value of maxCandidates input in request.
         * @param {string} [matchMode] Determine the leniency used to make a match between the input name and the reference data.
         * @param {string} [specificMatchOn] Specifies the field for the Specific Match Mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIsByLocation(longitude: string, latitude: string, name?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, sortBy?: string, fuzzyOnName?: string, page?: string, matchMode?: string, specificMatchOn?: string, options?: any): AxiosPromise<PlacesResponse> {
            return localVarFp.getPOIsByLocation(longitude, latitude, name, type, categoryCode, sicCode, maxCandidates, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, sortBy, fuzzyOnName, page, matchMode, specificMatchOn, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts a user-defined boundary as input and returns the Count number of POIs within the boundary. Additionally, user can request the count of filtered POIs by name, type, standard industrial classifications and category codes within the given polygon.
         * @summary Points Of Interest Count
         * @param {string} contentType 
         * @param {PoiCountRequest} poiCountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIsCount(contentType: string, poiCountRequest: PoiCountRequest, options?: any): AxiosPromise<PoiCount> {
            return localVarFp.getPOIsCount(contentType, poiCountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This service returns a list of standard industrial classification codes & associated metadata which can then be used as inputs for querying the Points of Interest By Address or Location methods listed above.
         * @summary Get SIC Metadata
         * @param {string} [sicCode] 4 or 8 digits SIC code to filter the response.
         * @param {string} [level] 1 or 2.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSICMetadata(sicCode?: string, level?: string, options?: any): AxiosPromise<MetadataResponse> {
            return localVarFp.getSICMetadata(sicCode, level, options).then((request) => request(axios, basePath));
        },
        /**
         * This service accepts partial text input and returns matching points of interest, sorted by relevance or distance.
         * @summary Points Of Interest Autocomplete
         * @param {string} [xForwardedFor] 
         * @param {string} [longitude] Longitude of the location.
         * @param {string} [latitude] Latitude of the location.
         * @param {string} [searchText] Free text which will accept a multi-word string. Combination of POI name and address is possible.
         * @param {string} [searchOnNameOnly] 
         * @param {string} [searchRadius] Radius range within which search is performed.
         * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters (default).
         * @param {string} [travelTime] Travel time within which search is performed (POIs which can be reached within travel time).
         * @param {string} [travelTimeUnit] Travel time unit such as minutes (default), hours, seconds or milliseconds.
         * @param {string} [travelDistance] Travel distance within which search is performed (POIs which can be reached within travel distance).
         * @param {string} [travelDistanceUnit] Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
         * @param {string} [travelMode] Mode of commute.
         * @param {string} [country] Country ISO code.
         * @param {string} [areaName1] Specifies the largest geographical area, typically a state or province.
         * @param {string} [areaName3] Specifies a city or town name.
         * @param {string} [postcode1] Specifies the postcode(ZIP code) in the appropriate format for the country.
         * @param {string} [postcode2] Specifies the postcode(ZIP code) extension.
         * @param {string} [ipAddress] IP address which will be used to auto detect the location in order to serve contextually relevant results.
         * @param {string} [autoDetectLocation] Specifies whether to detect client\&#39;s location using IP address. If IP address(below) is not provided and autoDetectLocation is set \&#39;True\&#39; then IP address will be picked from HTTP request automatically.
         * @param {string} [type] Filters the points of interest (POIs) by place types.
         * @param {string} [categoryCode] Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values.
         * @param {string} [sicCode] Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values.
         * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved.
         * @param {string} [sortBy] sortBy
         * @param {string} [matchMode] Determine the leniency used to make a match between the input name and the reference data.
         * @param {string} [specificMatchOn] Specifies the field for the Specific Match Mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poisAutocomplete(xForwardedFor?: string, longitude?: string, latitude?: string, searchText?: string, searchOnNameOnly?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, country?: string, areaName1?: string, areaName3?: string, postcode1?: string, postcode2?: string, ipAddress?: string, autoDetectLocation?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, sortBy?: string, matchMode?: string, specificMatchOn?: string, options?: any): AxiosPromise<PlacesResponse> {
            return localVarFp.poisAutocomplete(xForwardedFor, longitude, latitude, searchText, searchOnNameOnly, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, country, areaName1, areaName3, postcode1, postcode2, ipAddress, autoDetectLocation, type, categoryCode, sicCode, maxCandidates, sortBy, matchMode, specificMatchOn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlacesServiceApi - object-oriented interface
 * @export
 * @class PlacesServiceApi
 * @extends {BaseAPI}
 */
export class PlacesServiceApi extends BaseAPI {
    /**
     * This service returns a list of Category codes & associated metadata which can then be used as inputs for querying the Points of Interest By Address or Location methods listed above.
     * @summary Category Code Metadata.
     * @param {string} [categoryCode] 4, 6, or 11 digits category code to filter the response.
     * @param {string} [level] 1, 2, or 3.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesServiceApi
     */
    public getCategoryCodeMetadata(categoryCode?: string, level?: string, options?: AxiosRequestConfig) {
        return PlacesServiceApiFp(this.oAuthCred,this.configuration).getCategoryCodeMetadata(categoryCode, level, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service returns complete details of a chosen point of interest by an identifier. The identifier could be selected from Autocomplete API response.
     * @summary Points Of Interest Details By Id
     * @param {string} id POI unique Identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesServiceApi
     */
    public getPOIById(id: string, options?: AxiosRequestConfig) {
        return PlacesServiceApiFp(this.oAuthCred,this.configuration).getPOIById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service accepts an address as input and returns nearby points-of-interest places around that address. Additional input features include retrieving data by name, type, standard industrial classifications and category codes, as well as geographic filtering by radius, travel times and travel distances. Response features include JSON/XML as well as CSV download.
     * @summary Get POIs By Address.
     * @param {string} [address] The address to be searched.
     * @param {string} [country] Country ISO code.
     * @param {string} [name] Specifies the name of the place (POI) to be searched. Also performs search on partially specified names. It requires minimum 3 characters to search.
     * @param {string} [type] Filters the points of interest (POIs) by place types.
     * @param {string} [categoryCode] Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values.
     * @param {string} [sicCode] Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values
     * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved
     * @param {string} [searchRadius] Radius range within which search is performed.
     * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters (default).
     * @param {string} [travelTime] Travel time within which search is performed (POIs which can be reached within travel time).
     * @param {string} [travelTimeUnit] Travel time unit such as minutes (default), hours, seconds or milliseconds.
     * @param {string} [travelDistance] Travel distance within which search is performed (POIs which can be reached within travel distance).
     * @param {string} [travelDistanceUnit] Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
     * @param {string} [travelMode] Mode of commute.
     * @param {string} [sortBy] Whether to sort the results based on relevance (best match) or by nearest distance from input location.
     * @param {string} [fuzzyOnName] Whether to allow fuzzy seacrh on name input.
     * @param {string} [page] Specifies the page number of results where page size is the value of maxCandidates input in request.
     * @param {string} [matchMode] Determine the leniency used to make a match between the input name and the reference data.
     * @param {string} [specificMatchOn] Specifies the field for the Specific Match Mode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesServiceApi
     */
    public getPOIsByAddress(address?: string, country?: string, name?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, sortBy?: string, fuzzyOnName?: string, page?: string, matchMode?: string, specificMatchOn?: string, options?: AxiosRequestConfig) {
        return PlacesServiceApiFp(this.oAuthCred,this.configuration).getPOIsByAddress(address, country, name, type, categoryCode, sicCode, maxCandidates, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, sortBy, fuzzyOnName, page, matchMode, specificMatchOn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service accepts city or postcode (alongwith country) and returns points-of-interest places within a city or postcode. Additional input features include retrieving data by name, type, standard industrial classifications and category codes, as well as geographic filtering by radius, travel times and travel distances. Response features include JSON/XML as well as CSV download.
     * @summary GET Points Of Interest By Area.
     * @param {string} [areaName1] Specifies the largest geographical area, typically a state or province
     * @param {string} [areaName3] Specifies a city or town name
     * @param {string} [postcode1] Specifies the postcode(ZIP code) in the appropriate format for the country
     * @param {string} [postcode2] Specifies the postcode(ZIP code) extension
     * @param {string} [country] Country ISO code
     * @param {string} [name] Specifies the name of the place (POI) to be searched. Also performs search on partially specified names. It requires minimum 3 characters to search
     * @param {string} [type] Filters the points of interest (POIs) by place types
     * @param {string} [categoryCode] Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values
     * @param {string} [sicCode] Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values
     * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved
     * @param {string} [fuzzyOnName] Whether to allow fuzzy seacrh on name input
     * @param {string} [page] Specifies the page number of results where page size is the value of maxCandidates input in request
     * @param {string} [matchMode] Determine the leniency used to make a match between the input name and the reference data
     * @param {string} [specificMatchOn] Specifies the field for the Specific Match Mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesServiceApi
     */
    public getPOIsByArea(areaName1?: string, areaName3?: string, postcode1?: string, postcode2?: string, country?: string, name?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, fuzzyOnName?: string, page?: string, matchMode?: string, specificMatchOn?: string, options?: AxiosRequestConfig) {
        return PlacesServiceApiFp(this.oAuthCred,this.configuration).getPOIsByArea(areaName1, areaName3, postcode1, postcode2, country, name, type, categoryCode, sicCode, maxCandidates, fuzzyOnName, page, matchMode, specificMatchOn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts a user-defined boundary as input and returns all Points of Interest within the boundary. Additionally, user can filter the response by name, type, standard industrial classifications and category codes.
     * @summary Points Of Interest By Boundary
     * @param {POIByGeometryRequest} pOIByGeometryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesServiceApi
     */
    public getPOIsByGeometry(pOIByGeometryRequest: POIByGeometryRequest, options?: AxiosRequestConfig) {
        return PlacesServiceApiFp(this.oAuthCred,this.configuration).getPOIsByGeometry(pOIByGeometryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service accepts latitude/longitude as input and returns nearby points-of-interest places around that location. Additional input features include retrieving data by name, type, standard industrial classifications and category codes, as well as geographic filtering by radius, travel times and travel distances. Response features include JSON/XML as well as CSV download
     * @summary Get POIs By Location.
     * @param {string} longitude Longitude of the location.
     * @param {string} latitude Latitude of the location.
     * @param {string} [name] Specifies the name of the place (POI) to be searched. Also performs search on partially specified names. It requires minimum 3 characters to search.
     * @param {string} [type] Filters the points of interest (POIs) by place types.
     * @param {string} [categoryCode] Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values.
     * @param {string} [sicCode] Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values
     * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved
     * @param {string} [searchRadius] Radius range within which search is performed.
     * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters (default).
     * @param {string} [travelTime] Travel time within which search is performed (POIs which can be reached within travel time).
     * @param {string} [travelTimeUnit] Travel time unit such as minutes (default), hours, seconds or milliseconds.
     * @param {string} [travelDistance] Travel distance within which search is performed (POIs which can be reached within travel distance).
     * @param {string} [travelDistanceUnit] Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
     * @param {string} [travelMode] Mode of commute.
     * @param {string} [sortBy] Whether to sort the results based on relevance (best match) or by nearest distance from input location.
     * @param {string} [fuzzyOnName] Whether to allow fuzzy seacrh on name input.
     * @param {string} [page] Specifies the page number of results where page size is the value of maxCandidates input in request.
     * @param {string} [matchMode] Determine the leniency used to make a match between the input name and the reference data.
     * @param {string} [specificMatchOn] Specifies the field for the Specific Match Mode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesServiceApi
     */
    public getPOIsByLocation(longitude: string, latitude: string, name?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, sortBy?: string, fuzzyOnName?: string, page?: string, matchMode?: string, specificMatchOn?: string, options?: AxiosRequestConfig) {
        return PlacesServiceApiFp(this.oAuthCred,this.configuration).getPOIsByLocation(longitude, latitude, name, type, categoryCode, sicCode, maxCandidates, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, sortBy, fuzzyOnName, page, matchMode, specificMatchOn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts a user-defined boundary as input and returns the Count number of POIs within the boundary. Additionally, user can request the count of filtered POIs by name, type, standard industrial classifications and category codes within the given polygon.
     * @summary Points Of Interest Count
     * @param {string} contentType 
     * @param {PoiCountRequest} poiCountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesServiceApi
     */
    public getPOIsCount(contentType: string, poiCountRequest: PoiCountRequest, options?: AxiosRequestConfig) {
        return PlacesServiceApiFp(this.oAuthCred,this.configuration).getPOIsCount(contentType, poiCountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service returns a list of standard industrial classification codes & associated metadata which can then be used as inputs for querying the Points of Interest By Address or Location methods listed above.
     * @summary Get SIC Metadata
     * @param {string} [sicCode] 4 or 8 digits SIC code to filter the response.
     * @param {string} [level] 1 or 2.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesServiceApi
     */
    public getSICMetadata(sicCode?: string, level?: string, options?: AxiosRequestConfig) {
        return PlacesServiceApiFp(this.oAuthCred,this.configuration).getSICMetadata(sicCode, level, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service accepts partial text input and returns matching points of interest, sorted by relevance or distance.
     * @summary Points Of Interest Autocomplete
     * @param {string} [xForwardedFor] 
     * @param {string} [longitude] Longitude of the location.
     * @param {string} [latitude] Latitude of the location.
     * @param {string} [searchText] Free text which will accept a multi-word string. Combination of POI name and address is possible.
     * @param {string} [searchOnNameOnly] 
     * @param {string} [searchRadius] Radius range within which search is performed.
     * @param {string} [searchRadiusUnit] Radius unit such as Feet, Kilometers, Miles or Meters (default).
     * @param {string} [travelTime] Travel time within which search is performed (POIs which can be reached within travel time).
     * @param {string} [travelTimeUnit] Travel time unit such as minutes (default), hours, seconds or milliseconds.
     * @param {string} [travelDistance] Travel distance within which search is performed (POIs which can be reached within travel distance).
     * @param {string} [travelDistanceUnit] Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
     * @param {string} [travelMode] Mode of commute.
     * @param {string} [country] Country ISO code.
     * @param {string} [areaName1] Specifies the largest geographical area, typically a state or province.
     * @param {string} [areaName3] Specifies a city or town name.
     * @param {string} [postcode1] Specifies the postcode(ZIP code) in the appropriate format for the country.
     * @param {string} [postcode2] Specifies the postcode(ZIP code) extension.
     * @param {string} [ipAddress] IP address which will be used to auto detect the location in order to serve contextually relevant results.
     * @param {string} [autoDetectLocation] Specifies whether to detect client\&#39;s location using IP address. If IP address(below) is not provided and autoDetectLocation is set \&#39;True\&#39; then IP address will be picked from HTTP request automatically.
     * @param {string} [type] Filters the points of interest (POIs) by place types.
     * @param {string} [categoryCode] Acts as a filter to narrow down and refine POI search results. The category codes are unique 4, 6, or 11 digit numeric values.
     * @param {string} [sicCode] Acts as a filter to narrow down and refine POI search results. The SIC codes are unique 4 or 8 digit numerical values.
     * @param {string} [maxCandidates] Maximum number of POIs that can be retrieved.
     * @param {string} [sortBy] sortBy
     * @param {string} [matchMode] Determine the leniency used to make a match between the input name and the reference data.
     * @param {string} [specificMatchOn] Specifies the field for the Specific Match Mode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesServiceApi
     */
    public poisAutocomplete(xForwardedFor?: string, longitude?: string, latitude?: string, searchText?: string, searchOnNameOnly?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, country?: string, areaName1?: string, areaName3?: string, postcode1?: string, postcode2?: string, ipAddress?: string, autoDetectLocation?: string, type?: string, categoryCode?: string, sicCode?: string, maxCandidates?: string, sortBy?: string, matchMode?: string, specificMatchOn?: string, options?: AxiosRequestConfig) {
        return PlacesServiceApiFp(this.oAuthCred,this.configuration).poisAutocomplete(xForwardedFor, longitude, latitude, searchText, searchOnNameOnly, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, country, areaName1, areaName3, postcode1, postcode2, ipAddress, autoDetectLocation, type, categoryCode, sicCode, maxCandidates, sortBy, matchMode, specificMatchOn, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PropertyInformationServiceApi - axios parameter creator
 * @export
 */
export const PropertyInformationServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * Accepts address as input and returns property parcel boundary around that address.
         * @summary Get Parcel Boundary By Address
         * @param {string} address free form address text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParcelBoundaryByAddress: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getParcelBoundaryByAddress', 'address', address)
            const localVarPath = `/property/v2/parcelboundary/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts latitude/longitude as input and returns property parcel boundary around that location.
         * @summary Get Parcel Boundary By Location
         * @param {string} longitude Longitude of Location
         * @param {string} latitude Latitude of Location
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParcelBoundaryByLocation: async (longitude: string, latitude: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('getParcelBoundaryByLocation', 'longitude', longitude)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('getParcelBoundaryByLocation', 'latitude', latitude)
            const localVarPath = `/property/v2/parcelboundary/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts PB key as input and returns property attributes for the matched address.
         * @summary Get Parcel Boundary By PreciselyID
         * @param {string} preciselyID precisely ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParcelBoundaryByPreciselyID: async (preciselyID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'preciselyID' is not null or undefined
            assertParamExists('getParcelBoundaryByPreciselyID', 'preciselyID', preciselyID)
            const localVarPath = `/property/v2/parcelboundary/bypreciselyID`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (preciselyID !== undefined) {
                localVarQueryParameter['preciselyID'] = preciselyID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GetPropertyAttributesbyAddress Endpoint will take address as an input and will return key property attributes in response. Optionally user will have the option to filter the attributes and will pay for only returned attributes.
         * @summary PropertyV2 Attributes By Address.
         * @param {string} [address] free form address text
         * @param {string} [attributes] Case-insensitive comma separated values of property attributes. Response will contain only the input attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyAttributesByAddress: async (address?: string, attributes?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/property/v2/attributes/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (attributes !== undefined) {
                localVarQueryParameter['attributes'] = attributes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GetPropertyAttributesbyAddressBatch Endpoint will take the list of addresses as an input and will return key property attributes for the given addresses in response. Optionally user will have the option to filter the attributes and will pay for only returned attributes.
         * @summary PropertyV2 Attributes By Address Batch.
         * @param {PropertyInfoAddressRequest} propertyInfoAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyAttributesByAddressBatch: async (propertyInfoAddressRequest: PropertyInfoAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyInfoAddressRequest' is not null or undefined
            assertParamExists('getPropertyAttributesByAddressBatch', 'propertyInfoAddressRequest', propertyInfoAddressRequest)
            const localVarPath = `/property/v2/attributes/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyInfoAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyInformationServiceApi - functional programming interface
 * @export
 */
export const PropertyInformationServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = PropertyInformationServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * Accepts address as input and returns property parcel boundary around that address.
         * @summary Get Parcel Boundary By Address
         * @param {string} address free form address text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParcelBoundaryByAddress(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParcelBoundaryV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParcelBoundaryByAddress(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts latitude/longitude as input and returns property parcel boundary around that location.
         * @summary Get Parcel Boundary By Location
         * @param {string} longitude Longitude of Location
         * @param {string} latitude Latitude of Location
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParcelBoundaryByLocation(longitude: string, latitude: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParcelBoundaryV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParcelBoundaryByLocation(longitude, latitude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts PB key as input and returns property attributes for the matched address.
         * @summary Get Parcel Boundary By PreciselyID
         * @param {string} preciselyID precisely ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParcelBoundaryByPreciselyID(preciselyID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParcelBoundaryV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParcelBoundaryByPreciselyID(preciselyID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * GetPropertyAttributesbyAddress Endpoint will take address as an input and will return key property attributes in response. Optionally user will have the option to filter the attributes and will pay for only returned attributes.
         * @summary PropertyV2 Attributes By Address.
         * @param {string} [address] free form address text
         * @param {string} [attributes] Case-insensitive comma separated values of property attributes. Response will contain only the input attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyAttributesByAddress(address?: string, attributes?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyAttributesByAddress(address, attributes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * GetPropertyAttributesbyAddressBatch Endpoint will take the list of addresses as an input and will return key property attributes for the given addresses in response. Optionally user will have the option to filter the attributes and will pay for only returned attributes.
         * @summary PropertyV2 Attributes By Address Batch.
         * @param {PropertyInfoAddressRequest} propertyInfoAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyAttributesByAddressBatch(propertyInfoAddressRequest: PropertyInfoAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyInfoResponses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyAttributesByAddressBatch(propertyInfoAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PropertyInformationServiceApi - factory interface
 * @export
 */
export const PropertyInformationServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyInformationServiceApiFp(oAuth,configuration)
    return {
        /**
         * Accepts address as input and returns property parcel boundary around that address.
         * @summary Get Parcel Boundary By Address
         * @param {string} address free form address text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParcelBoundaryByAddress(address: string, options?: any): AxiosPromise<ParcelBoundaryV2> {
            return localVarFp.getParcelBoundaryByAddress(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts latitude/longitude as input and returns property parcel boundary around that location.
         * @summary Get Parcel Boundary By Location
         * @param {string} longitude Longitude of Location
         * @param {string} latitude Latitude of Location
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParcelBoundaryByLocation(longitude: string, latitude: string, options?: any): AxiosPromise<ParcelBoundaryV2> {
            return localVarFp.getParcelBoundaryByLocation(longitude, latitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts PB key as input and returns property attributes for the matched address.
         * @summary Get Parcel Boundary By PreciselyID
         * @param {string} preciselyID precisely ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParcelBoundaryByPreciselyID(preciselyID: string, options?: any): AxiosPromise<ParcelBoundaryV2> {
            return localVarFp.getParcelBoundaryByPreciselyID(preciselyID, options).then((request) => request(axios, basePath));
        },
        /**
         * GetPropertyAttributesbyAddress Endpoint will take address as an input and will return key property attributes in response. Optionally user will have the option to filter the attributes and will pay for only returned attributes.
         * @summary PropertyV2 Attributes By Address.
         * @param {string} [address] free form address text
         * @param {string} [attributes] Case-insensitive comma separated values of property attributes. Response will contain only the input attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyAttributesByAddress(address?: string, attributes?: string, options?: any): AxiosPromise<PropertyInfoResponse> {
            return localVarFp.getPropertyAttributesByAddress(address, attributes, options).then((request) => request(axios, basePath));
        },
        /**
         * GetPropertyAttributesbyAddressBatch Endpoint will take the list of addresses as an input and will return key property attributes for the given addresses in response. Optionally user will have the option to filter the attributes and will pay for only returned attributes.
         * @summary PropertyV2 Attributes By Address Batch.
         * @param {PropertyInfoAddressRequest} propertyInfoAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyAttributesByAddressBatch(propertyInfoAddressRequest: PropertyInfoAddressRequest, options?: any): AxiosPromise<PropertyInfoResponses> {
            return localVarFp.getPropertyAttributesByAddressBatch(propertyInfoAddressRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertyInformationServiceApi - object-oriented interface
 * @export
 * @class PropertyInformationServiceApi
 * @extends {BaseAPI}
 */
export class PropertyInformationServiceApi extends BaseAPI {
    /**
     * Accepts address as input and returns property parcel boundary around that address.
     * @summary Get Parcel Boundary By Address
     * @param {string} address free form address text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyInformationServiceApi
     */
    public getParcelBoundaryByAddress(address: string, options?: AxiosRequestConfig) {
        return PropertyInformationServiceApiFp(this.oAuthCred,this.configuration).getParcelBoundaryByAddress(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts latitude/longitude as input and returns property parcel boundary around that location.
     * @summary Get Parcel Boundary By Location
     * @param {string} longitude Longitude of Location
     * @param {string} latitude Latitude of Location
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyInformationServiceApi
     */
    public getParcelBoundaryByLocation(longitude: string, latitude: string, options?: AxiosRequestConfig) {
        return PropertyInformationServiceApiFp(this.oAuthCred,this.configuration).getParcelBoundaryByLocation(longitude, latitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts PB key as input and returns property attributes for the matched address.
     * @summary Get Parcel Boundary By PreciselyID
     * @param {string} preciselyID precisely ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyInformationServiceApi
     */
    public getParcelBoundaryByPreciselyID(preciselyID: string, options?: AxiosRequestConfig) {
        return PropertyInformationServiceApiFp(this.oAuthCred,this.configuration).getParcelBoundaryByPreciselyID(preciselyID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GetPropertyAttributesbyAddress Endpoint will take address as an input and will return key property attributes in response. Optionally user will have the option to filter the attributes and will pay for only returned attributes.
     * @summary PropertyV2 Attributes By Address.
     * @param {string} [address] free form address text
     * @param {string} [attributes] Case-insensitive comma separated values of property attributes. Response will contain only the input attributes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyInformationServiceApi
     */
    public getPropertyAttributesByAddress(address?: string, attributes?: string, options?: AxiosRequestConfig) {
        return PropertyInformationServiceApiFp(this.oAuthCred,this.configuration).getPropertyAttributesByAddress(address, attributes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GetPropertyAttributesbyAddressBatch Endpoint will take the list of addresses as an input and will return key property attributes for the given addresses in response. Optionally user will have the option to filter the attributes and will pay for only returned attributes.
     * @summary PropertyV2 Attributes By Address Batch.
     * @param {PropertyInfoAddressRequest} propertyInfoAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyInformationServiceApi
     */
    public getPropertyAttributesByAddressBatch(propertyInfoAddressRequest: PropertyInfoAddressRequest, options?: AxiosRequestConfig) {
        return PropertyInformationServiceApiFp(this.oAuthCred,this.configuration).getPropertyAttributesByAddressBatch(propertyInfoAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RisksServiceApi - axios parameter creator
 * @export
 */
export const RisksServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * Accepts addresses as input and Returns local crime indexes.
         * @summary Get Crime Risk By Address
         * @param {string} address free form address text
         * @param {string} [type] this is crime type; valid values are following 11 crime types with \&#39;all\&#39; as default (more than one can also be given as comma separated types)
         * @param {string} [includeGeometry] Y or N (default is N) - if it is Y, then geometry will be part of response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrimeRiskByAddress: async (address: string, type?: string, includeGeometry?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getCrimeRiskByAddress', 'address', address)
            const localVarPath = `/risks/v1/crime/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (includeGeometry !== undefined) {
                localVarQueryParameter['includeGeometry'] = includeGeometry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a Batch offering for \'Crime Risk By Address\' service. It accepts a single address or a list of addresses and retrieve local crime indexes.
         * @summary Post Crime Risk By Address
         * @param {CrimeRiskByAddressBatchRequest} crimeRiskByAddressBatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrimeRiskByAddressBatch: async (crimeRiskByAddressBatchRequest: CrimeRiskByAddressBatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'crimeRiskByAddressBatchRequest' is not null or undefined
            assertParamExists('getCrimeRiskByAddressBatch', 'crimeRiskByAddressBatchRequest', crimeRiskByAddressBatchRequest)
            const localVarPath = `/risks/v1/crime/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(crimeRiskByAddressBatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts latitude/longitude as input and returns and Returns local crime indexes.
         * @summary Get Crime Risk By  Location
         * @param {string} longitude The longitude of the location
         * @param {string} latitude The latitude of the location
         * @param {string} [type] this is crime type; valid values are following 11 crime types with \&#39;all\&#39; as default (more than one can also be given as comma separated types)
         * @param {string} [includeGeometry] Y or N (default is N) - if it is Y, then geometry will be part of response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrimeRiskByLocation: async (longitude: string, latitude: string, type?: string, includeGeometry?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('getCrimeRiskByLocation', 'longitude', longitude)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('getCrimeRiskByLocation', 'latitude', latitude)
            const localVarPath = `/risks/v1/crime/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (includeGeometry !== undefined) {
                localVarQueryParameter['includeGeometry'] = includeGeometry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a Batch offering for \'Crime Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve local crime indexes.
         * @summary Post Crime Risk By Location
         * @param {CrimeRiskByLocationBatchRequest} crimeRiskByLocationBatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrimeRiskByLocationBatch: async (crimeRiskByLocationBatchRequest: CrimeRiskByLocationBatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'crimeRiskByLocationBatchRequest' is not null or undefined
            assertParamExists('getCrimeRiskByLocationBatch', 'crimeRiskByLocationBatchRequest', crimeRiskByLocationBatchRequest)
            const localVarPath = `/risks/v1/crime/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(crimeRiskByLocationBatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts addresses as input and Returns the distance from nearest water bodies along with body name and location.
         * @summary Get Distance To Flood Hazard By Address
         * @param {string} [address] The address of the location
         * @param {string} [maxCandidates] This specifies the value of maxCandidates
         * @param {string} [waterBodyType] This specifies the value of waterBodyType
         * @param {string} [searchDistance] This specifies the search distance
         * @param {string} [searchDistanceUnit] miles (default value),feet, kilometers, meters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistanceToCoastByAddress: async (address?: string, maxCandidates?: string, waterBodyType?: string, searchDistance?: string, searchDistanceUnit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/risks/v1/shoreline/distancetofloodhazard/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (maxCandidates !== undefined) {
                localVarQueryParameter['maxCandidates'] = maxCandidates;
            }

            if (waterBodyType !== undefined) {
                localVarQueryParameter['waterBodyType'] = waterBodyType;
            }

            if (searchDistance !== undefined) {
                localVarQueryParameter['searchDistance'] = searchDistance;
            }

            if (searchDistanceUnit !== undefined) {
                localVarQueryParameter['searchDistanceUnit'] = searchDistanceUnit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a Batch offering for \'Distance To Flood Hazard By Address\' service. It accepts a single address or a list of addresses and retrieve the distance from nearest water bodies along with body name and location.
         * @summary Post Distance To Flood Hazard By Address
         * @param {DistanceToFloodHazardAddressRequest} distanceToFloodHazardAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistanceToCoastByAddressBatch: async (distanceToFloodHazardAddressRequest: DistanceToFloodHazardAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'distanceToFloodHazardAddressRequest' is not null or undefined
            assertParamExists('getDistanceToCoastByAddressBatch', 'distanceToFloodHazardAddressRequest', distanceToFloodHazardAddressRequest)
            const localVarPath = `/risks/v1/shoreline/distancetofloodhazard/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(distanceToFloodHazardAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts latitude & longitude as input and Returns the distance from nearest water bodies along with body name and location.
         * @summary Get Distance To Flood Hazard By Location
         * @param {string} [longitude] The longitude of the location
         * @param {string} [latitude] The latitude of the location
         * @param {string} [maxCandidates] This specifies the value of maxCandidates
         * @param {string} [waterBodyType] This specifies the value of waterBodyType
         * @param {string} [searchDistance] This specifies the search distance
         * @param {string} [searchDistanceUnit] miles (default value),feet, kilometers, meters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistanceToCoastByLocation: async (longitude?: string, latitude?: string, maxCandidates?: string, waterBodyType?: string, searchDistance?: string, searchDistanceUnit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/risks/v1/shoreline/distancetofloodhazard/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (maxCandidates !== undefined) {
                localVarQueryParameter['maxCandidates'] = maxCandidates;
            }

            if (waterBodyType !== undefined) {
                localVarQueryParameter['waterBodyType'] = waterBodyType;
            }

            if (searchDistance !== undefined) {
                localVarQueryParameter['searchDistance'] = searchDistance;
            }

            if (searchDistanceUnit !== undefined) {
                localVarQueryParameter['searchDistanceUnit'] = searchDistanceUnit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a Batch offering for \'Distance To Flood Hazard By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve the distance from nearest water bodies along with body name and location.
         * @summary Post Distance To Flood Hazard By Location
         * @param {DistanceToFloodHazardLocationRequest} distanceToFloodHazardLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistanceToCoastByLocationBatch: async (distanceToFloodHazardLocationRequest: DistanceToFloodHazardLocationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'distanceToFloodHazardLocationRequest' is not null or undefined
            assertParamExists('getDistanceToCoastByLocationBatch', 'distanceToFloodHazardLocationRequest', distanceToFloodHazardLocationRequest)
            const localVarPath = `/risks/v1/shoreline/distancetofloodhazard/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(distanceToFloodHazardLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts postcode as input and Returns historical earthquake details for a particular postcode.
         * @summary Earthquake History
         * @param {string} postCode 5 digit Postal code to search
         * @param {string} [startDate] Start time in milliseconds(UTC)
         * @param {string} [endDate] End time in milliseconds(UTC)
         * @param {string} [minMagnitude] Minimum richter scale magnitude
         * @param {string} [maxMagnitude] Maximum Richter scale magnitude
         * @param {string} [maxCandidates] Maximum response events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarthquakeHistory: async (postCode: string, startDate?: string, endDate?: string, minMagnitude?: string, maxMagnitude?: string, maxCandidates?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postCode' is not null or undefined
            assertParamExists('getEarthquakeHistory', 'postCode', postCode)
            const localVarPath = `/risks/v1/earthquakehistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (postCode !== undefined) {
                localVarQueryParameter['postCode'] = postCode;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (minMagnitude !== undefined) {
                localVarQueryParameter['minMagnitude'] = minMagnitude;
            }

            if (maxMagnitude !== undefined) {
                localVarQueryParameter['maxMagnitude'] = maxMagnitude;
            }

            if (maxCandidates !== undefined) {
                localVarQueryParameter['maxCandidates'] = maxCandidates;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts addresses as input and Returns counts of earthquakes for various richter measurements and values.
         * @summary Get Earthquake Risk By Address
         * @param {string} address free form address text
         * @param {string} [richterValue] all (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE
         * @param {string} [includeGeometry] Y or N (default is N) - if it is Y, then geometry will be part of response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarthquakeRiskByAddress: async (address: string, richterValue?: string, includeGeometry?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getEarthquakeRiskByAddress', 'address', address)
            const localVarPath = `/risks/v1/earthquake/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (richterValue !== undefined) {
                localVarQueryParameter['richterValue'] = richterValue;
            }

            if (includeGeometry !== undefined) {
                localVarQueryParameter['includeGeometry'] = includeGeometry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a Batch offering for \'Earthquake Risk By Address\' service. It accepts a single address or a list of addresses and retrieve counts of earthquakes for various richter measurements and values.
         * @summary Post Earthquake Risk By Address
         * @param {EarthquakeRiskByAddressRequest} earthquakeRiskByAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarthquakeRiskByAddressBatch: async (earthquakeRiskByAddressRequest: EarthquakeRiskByAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'earthquakeRiskByAddressRequest' is not null or undefined
            assertParamExists('getEarthquakeRiskByAddressBatch', 'earthquakeRiskByAddressRequest', earthquakeRiskByAddressRequest)
            const localVarPath = `/risks/v1/earthquake/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(earthquakeRiskByAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts latitude & longitude as input and Returns counts of earthquakes for various richter measurements and values.
         * @summary Get Earthquake Risk By Location
         * @param {string} longitude The longitude of the location
         * @param {string} latitude The latitude of the location
         * @param {string} [richterValue] all (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE
         * @param {string} [includeGeometry] Y or N (default is N) - if it is Y, then geometry will be part of response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarthquakeRiskByLocation: async (longitude: string, latitude: string, richterValue?: string, includeGeometry?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('getEarthquakeRiskByLocation', 'longitude', longitude)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('getEarthquakeRiskByLocation', 'latitude', latitude)
            const localVarPath = `/risks/v1/earthquake/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (richterValue !== undefined) {
                localVarQueryParameter['richterValue'] = richterValue;
            }

            if (includeGeometry !== undefined) {
                localVarQueryParameter['includeGeometry'] = includeGeometry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a Batch offering for \'Earthquake Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve counts of earthquakes for various richter measurements and values.
         * @summary Post Earthquake Risk By Location
         * @param {EarthquakeRiskByLocationRequest} earthquakeRiskByLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarthquakeRiskByLocationBatch: async (earthquakeRiskByLocationRequest: EarthquakeRiskByLocationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'earthquakeRiskByLocationRequest' is not null or undefined
            assertParamExists('getEarthquakeRiskByLocationBatch', 'earthquakeRiskByLocationRequest', earthquakeRiskByLocationRequest)
            const localVarPath = `/risks/v1/earthquake/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(earthquakeRiskByLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts postcode as input and Returns fire event details for a particular postcode.
         * @summary Get Fire History
         * @param {string} postCode 5 digit Postal code to search
         * @param {string} [startDate] Start time in milliseconds(UTC)
         * @param {string} [endDate] End time in milliseconds(UTC)
         * @param {string} [maxCandidates] Maximum response events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFireHistory: async (postCode: string, startDate?: string, endDate?: string, maxCandidates?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postCode' is not null or undefined
            assertParamExists('getFireHistory', 'postCode', postCode)
            const localVarPath = `/risks/v1/firehistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (postCode !== undefined) {
                localVarQueryParameter['postCode'] = postCode;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (maxCandidates !== undefined) {
                localVarQueryParameter['maxCandidates'] = maxCandidates;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts addresses as input and Returns fire risk data by risk types.
         * @summary Get Fire Risk By Address
         * @param {string} address Free form address text
         * @param {string} [includeGeometry] Flag to return Geometry default is N
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFireRiskByAddress: async (address: string, includeGeometry?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getFireRiskByAddress', 'address', address)
            const localVarPath = `/risks/v1/fire/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (includeGeometry !== undefined) {
                localVarQueryParameter['includeGeometry'] = includeGeometry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a Batch offering for \'Fire Risk By Address\' service. It accepts a single address or a list of addresses and retrieve fire risk data by risk types.
         * @summary Post Fire Risk By Address
         * @param {FireRiskByAddressRequest} fireRiskByAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFireRiskByAddressBatch: async (fireRiskByAddressRequest: FireRiskByAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fireRiskByAddressRequest' is not null or undefined
            assertParamExists('getFireRiskByAddressBatch', 'fireRiskByAddressRequest', fireRiskByAddressRequest)
            const localVarPath = `/risks/v1/fire/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fireRiskByAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts latitude & longitude as input and Returns fire risk data by risk types.
         * @summary Get Fire Risk By Location
         * @param {string} longitude Longitude of Location
         * @param {string} latitude Latitude of Location
         * @param {string} [includeGeometry] Flag to return Geometry default is N
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFireRiskByLocation: async (longitude: string, latitude: string, includeGeometry?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('getFireRiskByLocation', 'longitude', longitude)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('getFireRiskByLocation', 'latitude', latitude)
            const localVarPath = `/risks/v1/fire/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (includeGeometry !== undefined) {
                localVarQueryParameter['includeGeometry'] = includeGeometry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a Batch offering for \'Fire Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve fire risk data by risk types.
         * @summary Post Fire Risk By Location
         * @param {FireRiskByLocationRequest} fireRiskByLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFireRiskByLocationBatch: async (fireRiskByLocationRequest: FireRiskByLocationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fireRiskByLocationRequest' is not null or undefined
            assertParamExists('getFireRiskByLocationBatch', 'fireRiskByLocationRequest', fireRiskByLocationRequest)
            const localVarPath = `/risks/v1/fire/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fireRiskByLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts addresses as input and Returns nearest fire stations.
         * @summary Get Fire Station By Address
         * @param {string} address Free Address
         * @param {string} [maxCandidates] Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location.
         * @param {string} [travelTime] Max travel time from input location to fire station. Maximum allowed is 2 hours
         * @param {string} [travelTimeUnit] minutes (default), hours, seconds, milliseconds
         * @param {string} [travelDistance] Max travel distance from input location to fire station. Maximum allowed is 50 miles
         * @param {string} [travelDistanceUnit] Feet (default), Kilometers, Miles, Meters
         * @param {string} [sortBy] time (default), distance
         * @param {string} [historicTrafficTimeBucket] Historic traffic time slab
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFireStationByAddress: async (address: string, maxCandidates?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, sortBy?: string, historicTrafficTimeBucket?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getFireStationByAddress', 'address', address)
            const localVarPath = `/risks/v1/firestation/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (maxCandidates !== undefined) {
                localVarQueryParameter['maxCandidates'] = maxCandidates;
            }

            if (travelTime !== undefined) {
                localVarQueryParameter['travelTime'] = travelTime;
            }

            if (travelTimeUnit !== undefined) {
                localVarQueryParameter['travelTimeUnit'] = travelTimeUnit;
            }

            if (travelDistance !== undefined) {
                localVarQueryParameter['travelDistance'] = travelDistance;
            }

            if (travelDistanceUnit !== undefined) {
                localVarQueryParameter['travelDistanceUnit'] = travelDistanceUnit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (historicTrafficTimeBucket !== undefined) {
                localVarQueryParameter['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts latitude & longitude as input and Returns nearest fire stations.
         * @summary Get Fire Station By Location
         * @param {string} longitude Longitude of Location
         * @param {string} latitude Latitude of Location
         * @param {string} [maxCandidates] Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location.
         * @param {string} [travelTime] Max travel time from input location to fire station. Maximum allowed is 2 hours
         * @param {string} [travelTimeUnit] minutes (default), hours, seconds, milliseconds
         * @param {string} [travelDistance] Max travel distance from input location to fire station. Maximum allowed is 50 miles
         * @param {string} [travelDistanceUnit] Feet (default), Kilometers, Miles, Meters
         * @param {string} [sortBy] time (default), distance
         * @param {string} [historicTrafficTimeBucket] Historic traffic time slab
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFireStationByLocation: async (longitude: string, latitude: string, maxCandidates?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, sortBy?: string, historicTrafficTimeBucket?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('getFireStationByLocation', 'longitude', longitude)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('getFireStationByLocation', 'latitude', latitude)
            const localVarPath = `/risks/v1/firestation/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (maxCandidates !== undefined) {
                localVarQueryParameter['maxCandidates'] = maxCandidates;
            }

            if (travelTime !== undefined) {
                localVarQueryParameter['travelTime'] = travelTime;
            }

            if (travelTimeUnit !== undefined) {
                localVarQueryParameter['travelTimeUnit'] = travelTimeUnit;
            }

            if (travelDistance !== undefined) {
                localVarQueryParameter['travelDistance'] = travelDistance;
            }

            if (travelDistanceUnit !== undefined) {
                localVarQueryParameter['travelDistanceUnit'] = travelDistanceUnit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (historicTrafficTimeBucket !== undefined) {
                localVarQueryParameter['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts addresses as input and Returns flood risk data for flood zones and base flood elevation values.
         * @summary Get Flood Risk By Address
         * @param {string} address Free text Address
         * @param {string} [includeZoneDesc] Flag to return zone description
         * @param {string} [includeGeometry] Flag to return Geometry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFloodRiskByAddress: async (address: string, includeZoneDesc?: string, includeGeometry?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getFloodRiskByAddress', 'address', address)
            const localVarPath = `/risks/v1/flood/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (includeZoneDesc !== undefined) {
                localVarQueryParameter['includeZoneDesc'] = includeZoneDesc;
            }

            if (includeGeometry !== undefined) {
                localVarQueryParameter['includeGeometry'] = includeGeometry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a Batch offering for \'Flood Risk By Address\' service. It accepts a single address or a list of addresses and retrieve flood risk data for flood zones and base flood elevation values.
         * @summary Post Flood Risk By Address
         * @param {FloodRiskByAddressRequest} floodRiskByAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFloodRiskByAddressBatch: async (floodRiskByAddressRequest: FloodRiskByAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'floodRiskByAddressRequest' is not null or undefined
            assertParamExists('getFloodRiskByAddressBatch', 'floodRiskByAddressRequest', floodRiskByAddressRequest)
            const localVarPath = `/risks/v1/flood/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(floodRiskByAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts latitude & longitude as input and Returns flood risk data for flood zones and base flood elevation values.
         * @summary Get Flood Risk By Location
         * @param {string} longitude Longitude of Location
         * @param {string} latitude Latitude of Location
         * @param {string} [includeZoneDesc] Flag to return zone description
         * @param {string} [includeGeometry] Flag to return Geometry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFloodRiskByLocation: async (longitude: string, latitude: string, includeZoneDesc?: string, includeGeometry?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('getFloodRiskByLocation', 'longitude', longitude)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('getFloodRiskByLocation', 'latitude', latitude)
            const localVarPath = `/risks/v1/flood/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (includeZoneDesc !== undefined) {
                localVarQueryParameter['includeZoneDesc'] = includeZoneDesc;
            }

            if (includeGeometry !== undefined) {
                localVarQueryParameter['includeGeometry'] = includeGeometry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a Batch offering for \'Flood Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve flood risk data for flood zones and base flood elevation values.
         * @summary Post Flood Risk By Location
         * @param {FloodRiskByLocationRequest} floodRiskByLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFloodRiskByLocationBatch: async (floodRiskByLocationRequest: FloodRiskByLocationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'floodRiskByLocationRequest' is not null or undefined
            assertParamExists('getFloodRiskByLocationBatch', 'floodRiskByLocationRequest', floodRiskByLocationRequest)
            const localVarPath = `/risks/v1/flood/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(floodRiskByLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RisksServiceApi - functional programming interface
 * @export
 */
export const RisksServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = RisksServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * Accepts addresses as input and Returns local crime indexes.
         * @summary Get Crime Risk By Address
         * @param {string} address free form address text
         * @param {string} [type] this is crime type; valid values are following 11 crime types with \&#39;all\&#39; as default (more than one can also be given as comma separated types)
         * @param {string} [includeGeometry] Y or N (default is N) - if it is Y, then geometry will be part of response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCrimeRiskByAddress(address: string, type?: string, includeGeometry?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrimeRiskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCrimeRiskByAddress(address, type, includeGeometry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a Batch offering for \'Crime Risk By Address\' service. It accepts a single address or a list of addresses and retrieve local crime indexes.
         * @summary Post Crime Risk By Address
         * @param {CrimeRiskByAddressBatchRequest} crimeRiskByAddressBatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCrimeRiskByAddressBatch(crimeRiskByAddressBatchRequest: CrimeRiskByAddressBatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrimeRiskResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCrimeRiskByAddressBatch(crimeRiskByAddressBatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts latitude/longitude as input and returns and Returns local crime indexes.
         * @summary Get Crime Risk By  Location
         * @param {string} longitude The longitude of the location
         * @param {string} latitude The latitude of the location
         * @param {string} [type] this is crime type; valid values are following 11 crime types with \&#39;all\&#39; as default (more than one can also be given as comma separated types)
         * @param {string} [includeGeometry] Y or N (default is N) - if it is Y, then geometry will be part of response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCrimeRiskByLocation(longitude: string, latitude: string, type?: string, includeGeometry?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrimeRiskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCrimeRiskByLocation(longitude, latitude, type, includeGeometry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a Batch offering for \'Crime Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve local crime indexes.
         * @summary Post Crime Risk By Location
         * @param {CrimeRiskByLocationBatchRequest} crimeRiskByLocationBatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCrimeRiskByLocationBatch(crimeRiskByLocationBatchRequest: CrimeRiskByLocationBatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrimeRiskResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCrimeRiskByLocationBatch(crimeRiskByLocationBatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts addresses as input and Returns the distance from nearest water bodies along with body name and location.
         * @summary Get Distance To Flood Hazard By Address
         * @param {string} [address] The address of the location
         * @param {string} [maxCandidates] This specifies the value of maxCandidates
         * @param {string} [waterBodyType] This specifies the value of waterBodyType
         * @param {string} [searchDistance] This specifies the search distance
         * @param {string} [searchDistanceUnit] miles (default value),feet, kilometers, meters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistanceToCoastByAddress(address?: string, maxCandidates?: string, waterBodyType?: string, searchDistance?: string, searchDistanceUnit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WaterBodyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistanceToCoastByAddress(address, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a Batch offering for \'Distance To Flood Hazard By Address\' service. It accepts a single address or a list of addresses and retrieve the distance from nearest water bodies along with body name and location.
         * @summary Post Distance To Flood Hazard By Address
         * @param {DistanceToFloodHazardAddressRequest} distanceToFloodHazardAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistanceToCoastByAddressBatch(distanceToFloodHazardAddressRequest: DistanceToFloodHazardAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistanceToFloodHazardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistanceToCoastByAddressBatch(distanceToFloodHazardAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts latitude & longitude as input and Returns the distance from nearest water bodies along with body name and location.
         * @summary Get Distance To Flood Hazard By Location
         * @param {string} [longitude] The longitude of the location
         * @param {string} [latitude] The latitude of the location
         * @param {string} [maxCandidates] This specifies the value of maxCandidates
         * @param {string} [waterBodyType] This specifies the value of waterBodyType
         * @param {string} [searchDistance] This specifies the search distance
         * @param {string} [searchDistanceUnit] miles (default value),feet, kilometers, meters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistanceToCoastByLocation(longitude?: string, latitude?: string, maxCandidates?: string, waterBodyType?: string, searchDistance?: string, searchDistanceUnit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WaterBodyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistanceToCoastByLocation(longitude, latitude, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a Batch offering for \'Distance To Flood Hazard By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve the distance from nearest water bodies along with body name and location.
         * @summary Post Distance To Flood Hazard By Location
         * @param {DistanceToFloodHazardLocationRequest} distanceToFloodHazardLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistanceToCoastByLocationBatch(distanceToFloodHazardLocationRequest: DistanceToFloodHazardLocationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistanceToFloodHazardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistanceToCoastByLocationBatch(distanceToFloodHazardLocationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts postcode as input and Returns historical earthquake details for a particular postcode.
         * @summary Earthquake History
         * @param {string} postCode 5 digit Postal code to search
         * @param {string} [startDate] Start time in milliseconds(UTC)
         * @param {string} [endDate] End time in milliseconds(UTC)
         * @param {string} [minMagnitude] Minimum richter scale magnitude
         * @param {string} [maxMagnitude] Maximum Richter scale magnitude
         * @param {string} [maxCandidates] Maximum response events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEarthquakeHistory(postCode: string, startDate?: string, endDate?: string, minMagnitude?: string, maxMagnitude?: string, maxCandidates?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EarthquakeHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEarthquakeHistory(postCode, startDate, endDate, minMagnitude, maxMagnitude, maxCandidates, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts addresses as input and Returns counts of earthquakes for various richter measurements and values.
         * @summary Get Earthquake Risk By Address
         * @param {string} address free form address text
         * @param {string} [richterValue] all (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE
         * @param {string} [includeGeometry] Y or N (default is N) - if it is Y, then geometry will be part of response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEarthquakeRiskByAddress(address: string, richterValue?: string, includeGeometry?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EarthquakeRiskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEarthquakeRiskByAddress(address, richterValue, includeGeometry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a Batch offering for \'Earthquake Risk By Address\' service. It accepts a single address or a list of addresses and retrieve counts of earthquakes for various richter measurements and values.
         * @summary Post Earthquake Risk By Address
         * @param {EarthquakeRiskByAddressRequest} earthquakeRiskByAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEarthquakeRiskByAddressBatch(earthquakeRiskByAddressRequest: EarthquakeRiskByAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EarthquakeRiskResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEarthquakeRiskByAddressBatch(earthquakeRiskByAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts latitude & longitude as input and Returns counts of earthquakes for various richter measurements and values.
         * @summary Get Earthquake Risk By Location
         * @param {string} longitude The longitude of the location
         * @param {string} latitude The latitude of the location
         * @param {string} [richterValue] all (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE
         * @param {string} [includeGeometry] Y or N (default is N) - if it is Y, then geometry will be part of response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEarthquakeRiskByLocation(longitude: string, latitude: string, richterValue?: string, includeGeometry?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EarthquakeRiskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEarthquakeRiskByLocation(longitude, latitude, richterValue, includeGeometry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a Batch offering for \'Earthquake Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve counts of earthquakes for various richter measurements and values.
         * @summary Post Earthquake Risk By Location
         * @param {EarthquakeRiskByLocationRequest} earthquakeRiskByLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEarthquakeRiskByLocationBatch(earthquakeRiskByLocationRequest: EarthquakeRiskByLocationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EarthquakeRiskResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEarthquakeRiskByLocationBatch(earthquakeRiskByLocationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts postcode as input and Returns fire event details for a particular postcode.
         * @summary Get Fire History
         * @param {string} postCode 5 digit Postal code to search
         * @param {string} [startDate] Start time in milliseconds(UTC)
         * @param {string} [endDate] End time in milliseconds(UTC)
         * @param {string} [maxCandidates] Maximum response events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFireHistory(postCode: string, startDate?: string, endDate?: string, maxCandidates?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FireHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFireHistory(postCode, startDate, endDate, maxCandidates, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts addresses as input and Returns fire risk data by risk types.
         * @summary Get Fire Risk By Address
         * @param {string} address Free form address text
         * @param {string} [includeGeometry] Flag to return Geometry default is N
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFireRiskByAddress(address: string, includeGeometry?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FireRiskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFireRiskByAddress(address, includeGeometry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a Batch offering for \'Fire Risk By Address\' service. It accepts a single address or a list of addresses and retrieve fire risk data by risk types.
         * @summary Post Fire Risk By Address
         * @param {FireRiskByAddressRequest} fireRiskByAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFireRiskByAddressBatch(fireRiskByAddressRequest: FireRiskByAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FireRiskResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFireRiskByAddressBatch(fireRiskByAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts latitude & longitude as input and Returns fire risk data by risk types.
         * @summary Get Fire Risk By Location
         * @param {string} longitude Longitude of Location
         * @param {string} latitude Latitude of Location
         * @param {string} [includeGeometry] Flag to return Geometry default is N
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFireRiskByLocation(longitude: string, latitude: string, includeGeometry?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FireRiskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFireRiskByLocation(longitude, latitude, includeGeometry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a Batch offering for \'Fire Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve fire risk data by risk types.
         * @summary Post Fire Risk By Location
         * @param {FireRiskByLocationRequest} fireRiskByLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFireRiskByLocationBatch(fireRiskByLocationRequest: FireRiskByLocationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FireRiskResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFireRiskByLocationBatch(fireRiskByLocationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts addresses as input and Returns nearest fire stations.
         * @summary Get Fire Station By Address
         * @param {string} address Free Address
         * @param {string} [maxCandidates] Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location.
         * @param {string} [travelTime] Max travel time from input location to fire station. Maximum allowed is 2 hours
         * @param {string} [travelTimeUnit] minutes (default), hours, seconds, milliseconds
         * @param {string} [travelDistance] Max travel distance from input location to fire station. Maximum allowed is 50 miles
         * @param {string} [travelDistanceUnit] Feet (default), Kilometers, Miles, Meters
         * @param {string} [sortBy] time (default), distance
         * @param {string} [historicTrafficTimeBucket] Historic traffic time slab
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFireStationByAddress(address: string, maxCandidates?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, sortBy?: string, historicTrafficTimeBucket?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FireStations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFireStationByAddress(address, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts latitude & longitude as input and Returns nearest fire stations.
         * @summary Get Fire Station By Location
         * @param {string} longitude Longitude of Location
         * @param {string} latitude Latitude of Location
         * @param {string} [maxCandidates] Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location.
         * @param {string} [travelTime] Max travel time from input location to fire station. Maximum allowed is 2 hours
         * @param {string} [travelTimeUnit] minutes (default), hours, seconds, milliseconds
         * @param {string} [travelDistance] Max travel distance from input location to fire station. Maximum allowed is 50 miles
         * @param {string} [travelDistanceUnit] Feet (default), Kilometers, Miles, Meters
         * @param {string} [sortBy] time (default), distance
         * @param {string} [historicTrafficTimeBucket] Historic traffic time slab
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFireStationByLocation(longitude: string, latitude: string, maxCandidates?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, sortBy?: string, historicTrafficTimeBucket?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FireStations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFireStationByLocation(longitude, latitude, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts addresses as input and Returns flood risk data for flood zones and base flood elevation values.
         * @summary Get Flood Risk By Address
         * @param {string} address Free text Address
         * @param {string} [includeZoneDesc] Flag to return zone description
         * @param {string} [includeGeometry] Flag to return Geometry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFloodRiskByAddress(address: string, includeZoneDesc?: string, includeGeometry?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FloodRiskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFloodRiskByAddress(address, includeZoneDesc, includeGeometry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a Batch offering for \'Flood Risk By Address\' service. It accepts a single address or a list of addresses and retrieve flood risk data for flood zones and base flood elevation values.
         * @summary Post Flood Risk By Address
         * @param {FloodRiskByAddressRequest} floodRiskByAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFloodRiskByAddressBatch(floodRiskByAddressRequest: FloodRiskByAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FloodRiskResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFloodRiskByAddressBatch(floodRiskByAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts latitude & longitude as input and Returns flood risk data for flood zones and base flood elevation values.
         * @summary Get Flood Risk By Location
         * @param {string} longitude Longitude of Location
         * @param {string} latitude Latitude of Location
         * @param {string} [includeZoneDesc] Flag to return zone description
         * @param {string} [includeGeometry] Flag to return Geometry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFloodRiskByLocation(longitude: string, latitude: string, includeZoneDesc?: string, includeGeometry?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FloodRiskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFloodRiskByLocation(longitude, latitude, includeZoneDesc, includeGeometry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a Batch offering for \'Flood Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve flood risk data for flood zones and base flood elevation values.
         * @summary Post Flood Risk By Location
         * @param {FloodRiskByLocationRequest} floodRiskByLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFloodRiskByLocationBatch(floodRiskByLocationRequest: FloodRiskByLocationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FloodRiskResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFloodRiskByLocationBatch(floodRiskByLocationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RisksServiceApi - factory interface
 * @export
 */
export const RisksServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RisksServiceApiFp(oAuth,configuration)
    return {
        /**
         * Accepts addresses as input and Returns local crime indexes.
         * @summary Get Crime Risk By Address
         * @param {string} address free form address text
         * @param {string} [type] this is crime type; valid values are following 11 crime types with \&#39;all\&#39; as default (more than one can also be given as comma separated types)
         * @param {string} [includeGeometry] Y or N (default is N) - if it is Y, then geometry will be part of response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrimeRiskByAddress(address: string, type?: string, includeGeometry?: string, options?: any): AxiosPromise<CrimeRiskResponse> {
            return localVarFp.getCrimeRiskByAddress(address, type, includeGeometry, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a Batch offering for \'Crime Risk By Address\' service. It accepts a single address or a list of addresses and retrieve local crime indexes.
         * @summary Post Crime Risk By Address
         * @param {CrimeRiskByAddressBatchRequest} crimeRiskByAddressBatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrimeRiskByAddressBatch(crimeRiskByAddressBatchRequest: CrimeRiskByAddressBatchRequest, options?: any): AxiosPromise<CrimeRiskResponseList> {
            return localVarFp.getCrimeRiskByAddressBatch(crimeRiskByAddressBatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts latitude/longitude as input and returns and Returns local crime indexes.
         * @summary Get Crime Risk By  Location
         * @param {string} longitude The longitude of the location
         * @param {string} latitude The latitude of the location
         * @param {string} [type] this is crime type; valid values are following 11 crime types with \&#39;all\&#39; as default (more than one can also be given as comma separated types)
         * @param {string} [includeGeometry] Y or N (default is N) - if it is Y, then geometry will be part of response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrimeRiskByLocation(longitude: string, latitude: string, type?: string, includeGeometry?: string, options?: any): AxiosPromise<CrimeRiskResponse> {
            return localVarFp.getCrimeRiskByLocation(longitude, latitude, type, includeGeometry, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a Batch offering for \'Crime Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve local crime indexes.
         * @summary Post Crime Risk By Location
         * @param {CrimeRiskByLocationBatchRequest} crimeRiskByLocationBatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrimeRiskByLocationBatch(crimeRiskByLocationBatchRequest: CrimeRiskByLocationBatchRequest, options?: any): AxiosPromise<CrimeRiskResponseList> {
            return localVarFp.getCrimeRiskByLocationBatch(crimeRiskByLocationBatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts addresses as input and Returns the distance from nearest water bodies along with body name and location.
         * @summary Get Distance To Flood Hazard By Address
         * @param {string} [address] The address of the location
         * @param {string} [maxCandidates] This specifies the value of maxCandidates
         * @param {string} [waterBodyType] This specifies the value of waterBodyType
         * @param {string} [searchDistance] This specifies the search distance
         * @param {string} [searchDistanceUnit] miles (default value),feet, kilometers, meters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistanceToCoastByAddress(address?: string, maxCandidates?: string, waterBodyType?: string, searchDistance?: string, searchDistanceUnit?: string, options?: any): AxiosPromise<WaterBodyResponse> {
            return localVarFp.getDistanceToCoastByAddress(address, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a Batch offering for \'Distance To Flood Hazard By Address\' service. It accepts a single address or a list of addresses and retrieve the distance from nearest water bodies along with body name and location.
         * @summary Post Distance To Flood Hazard By Address
         * @param {DistanceToFloodHazardAddressRequest} distanceToFloodHazardAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistanceToCoastByAddressBatch(distanceToFloodHazardAddressRequest: DistanceToFloodHazardAddressRequest, options?: any): AxiosPromise<DistanceToFloodHazardResponse> {
            return localVarFp.getDistanceToCoastByAddressBatch(distanceToFloodHazardAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts latitude & longitude as input and Returns the distance from nearest water bodies along with body name and location.
         * @summary Get Distance To Flood Hazard By Location
         * @param {string} [longitude] The longitude of the location
         * @param {string} [latitude] The latitude of the location
         * @param {string} [maxCandidates] This specifies the value of maxCandidates
         * @param {string} [waterBodyType] This specifies the value of waterBodyType
         * @param {string} [searchDistance] This specifies the search distance
         * @param {string} [searchDistanceUnit] miles (default value),feet, kilometers, meters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistanceToCoastByLocation(longitude?: string, latitude?: string, maxCandidates?: string, waterBodyType?: string, searchDistance?: string, searchDistanceUnit?: string, options?: any): AxiosPromise<WaterBodyResponse> {
            return localVarFp.getDistanceToCoastByLocation(longitude, latitude, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a Batch offering for \'Distance To Flood Hazard By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve the distance from nearest water bodies along with body name and location.
         * @summary Post Distance To Flood Hazard By Location
         * @param {DistanceToFloodHazardLocationRequest} distanceToFloodHazardLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistanceToCoastByLocationBatch(distanceToFloodHazardLocationRequest: DistanceToFloodHazardLocationRequest, options?: any): AxiosPromise<DistanceToFloodHazardResponse> {
            return localVarFp.getDistanceToCoastByLocationBatch(distanceToFloodHazardLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts postcode as input and Returns historical earthquake details for a particular postcode.
         * @summary Earthquake History
         * @param {string} postCode 5 digit Postal code to search
         * @param {string} [startDate] Start time in milliseconds(UTC)
         * @param {string} [endDate] End time in milliseconds(UTC)
         * @param {string} [minMagnitude] Minimum richter scale magnitude
         * @param {string} [maxMagnitude] Maximum Richter scale magnitude
         * @param {string} [maxCandidates] Maximum response events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarthquakeHistory(postCode: string, startDate?: string, endDate?: string, minMagnitude?: string, maxMagnitude?: string, maxCandidates?: string, options?: any): AxiosPromise<EarthquakeHistory> {
            return localVarFp.getEarthquakeHistory(postCode, startDate, endDate, minMagnitude, maxMagnitude, maxCandidates, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts addresses as input and Returns counts of earthquakes for various richter measurements and values.
         * @summary Get Earthquake Risk By Address
         * @param {string} address free form address text
         * @param {string} [richterValue] all (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE
         * @param {string} [includeGeometry] Y or N (default is N) - if it is Y, then geometry will be part of response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarthquakeRiskByAddress(address: string, richterValue?: string, includeGeometry?: string, options?: any): AxiosPromise<EarthquakeRiskResponse> {
            return localVarFp.getEarthquakeRiskByAddress(address, richterValue, includeGeometry, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a Batch offering for \'Earthquake Risk By Address\' service. It accepts a single address or a list of addresses and retrieve counts of earthquakes for various richter measurements and values.
         * @summary Post Earthquake Risk By Address
         * @param {EarthquakeRiskByAddressRequest} earthquakeRiskByAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarthquakeRiskByAddressBatch(earthquakeRiskByAddressRequest: EarthquakeRiskByAddressRequest, options?: any): AxiosPromise<EarthquakeRiskResponseList> {
            return localVarFp.getEarthquakeRiskByAddressBatch(earthquakeRiskByAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts latitude & longitude as input and Returns counts of earthquakes for various richter measurements and values.
         * @summary Get Earthquake Risk By Location
         * @param {string} longitude The longitude of the location
         * @param {string} latitude The latitude of the location
         * @param {string} [richterValue] all (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE
         * @param {string} [includeGeometry] Y or N (default is N) - if it is Y, then geometry will be part of response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarthquakeRiskByLocation(longitude: string, latitude: string, richterValue?: string, includeGeometry?: string, options?: any): AxiosPromise<EarthquakeRiskResponse> {
            return localVarFp.getEarthquakeRiskByLocation(longitude, latitude, richterValue, includeGeometry, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a Batch offering for \'Earthquake Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve counts of earthquakes for various richter measurements and values.
         * @summary Post Earthquake Risk By Location
         * @param {EarthquakeRiskByLocationRequest} earthquakeRiskByLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarthquakeRiskByLocationBatch(earthquakeRiskByLocationRequest: EarthquakeRiskByLocationRequest, options?: any): AxiosPromise<EarthquakeRiskResponseList> {
            return localVarFp.getEarthquakeRiskByLocationBatch(earthquakeRiskByLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts postcode as input and Returns fire event details for a particular postcode.
         * @summary Get Fire History
         * @param {string} postCode 5 digit Postal code to search
         * @param {string} [startDate] Start time in milliseconds(UTC)
         * @param {string} [endDate] End time in milliseconds(UTC)
         * @param {string} [maxCandidates] Maximum response events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFireHistory(postCode: string, startDate?: string, endDate?: string, maxCandidates?: string, options?: any): AxiosPromise<FireHistory> {
            return localVarFp.getFireHistory(postCode, startDate, endDate, maxCandidates, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts addresses as input and Returns fire risk data by risk types.
         * @summary Get Fire Risk By Address
         * @param {string} address Free form address text
         * @param {string} [includeGeometry] Flag to return Geometry default is N
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFireRiskByAddress(address: string, includeGeometry?: string, options?: any): AxiosPromise<FireRiskResponse> {
            return localVarFp.getFireRiskByAddress(address, includeGeometry, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a Batch offering for \'Fire Risk By Address\' service. It accepts a single address or a list of addresses and retrieve fire risk data by risk types.
         * @summary Post Fire Risk By Address
         * @param {FireRiskByAddressRequest} fireRiskByAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFireRiskByAddressBatch(fireRiskByAddressRequest: FireRiskByAddressRequest, options?: any): AxiosPromise<FireRiskResponseList> {
            return localVarFp.getFireRiskByAddressBatch(fireRiskByAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts latitude & longitude as input and Returns fire risk data by risk types.
         * @summary Get Fire Risk By Location
         * @param {string} longitude Longitude of Location
         * @param {string} latitude Latitude of Location
         * @param {string} [includeGeometry] Flag to return Geometry default is N
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFireRiskByLocation(longitude: string, latitude: string, includeGeometry?: string, options?: any): AxiosPromise<FireRiskResponse> {
            return localVarFp.getFireRiskByLocation(longitude, latitude, includeGeometry, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a Batch offering for \'Fire Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve fire risk data by risk types.
         * @summary Post Fire Risk By Location
         * @param {FireRiskByLocationRequest} fireRiskByLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFireRiskByLocationBatch(fireRiskByLocationRequest: FireRiskByLocationRequest, options?: any): AxiosPromise<FireRiskResponseList> {
            return localVarFp.getFireRiskByLocationBatch(fireRiskByLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts addresses as input and Returns nearest fire stations.
         * @summary Get Fire Station By Address
         * @param {string} address Free Address
         * @param {string} [maxCandidates] Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location.
         * @param {string} [travelTime] Max travel time from input location to fire station. Maximum allowed is 2 hours
         * @param {string} [travelTimeUnit] minutes (default), hours, seconds, milliseconds
         * @param {string} [travelDistance] Max travel distance from input location to fire station. Maximum allowed is 50 miles
         * @param {string} [travelDistanceUnit] Feet (default), Kilometers, Miles, Meters
         * @param {string} [sortBy] time (default), distance
         * @param {string} [historicTrafficTimeBucket] Historic traffic time slab
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFireStationByAddress(address: string, maxCandidates?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, sortBy?: string, historicTrafficTimeBucket?: string, options?: any): AxiosPromise<FireStations> {
            return localVarFp.getFireStationByAddress(address, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts latitude & longitude as input and Returns nearest fire stations.
         * @summary Get Fire Station By Location
         * @param {string} longitude Longitude of Location
         * @param {string} latitude Latitude of Location
         * @param {string} [maxCandidates] Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location.
         * @param {string} [travelTime] Max travel time from input location to fire station. Maximum allowed is 2 hours
         * @param {string} [travelTimeUnit] minutes (default), hours, seconds, milliseconds
         * @param {string} [travelDistance] Max travel distance from input location to fire station. Maximum allowed is 50 miles
         * @param {string} [travelDistanceUnit] Feet (default), Kilometers, Miles, Meters
         * @param {string} [sortBy] time (default), distance
         * @param {string} [historicTrafficTimeBucket] Historic traffic time slab
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFireStationByLocation(longitude: string, latitude: string, maxCandidates?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, sortBy?: string, historicTrafficTimeBucket?: string, options?: any): AxiosPromise<FireStations> {
            return localVarFp.getFireStationByLocation(longitude, latitude, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts addresses as input and Returns flood risk data for flood zones and base flood elevation values.
         * @summary Get Flood Risk By Address
         * @param {string} address Free text Address
         * @param {string} [includeZoneDesc] Flag to return zone description
         * @param {string} [includeGeometry] Flag to return Geometry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFloodRiskByAddress(address: string, includeZoneDesc?: string, includeGeometry?: string, options?: any): AxiosPromise<FloodRiskResponse> {
            return localVarFp.getFloodRiskByAddress(address, includeZoneDesc, includeGeometry, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a Batch offering for \'Flood Risk By Address\' service. It accepts a single address or a list of addresses and retrieve flood risk data for flood zones and base flood elevation values.
         * @summary Post Flood Risk By Address
         * @param {FloodRiskByAddressRequest} floodRiskByAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFloodRiskByAddressBatch(floodRiskByAddressRequest: FloodRiskByAddressRequest, options?: any): AxiosPromise<FloodRiskResponseList> {
            return localVarFp.getFloodRiskByAddressBatch(floodRiskByAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts latitude & longitude as input and Returns flood risk data for flood zones and base flood elevation values.
         * @summary Get Flood Risk By Location
         * @param {string} longitude Longitude of Location
         * @param {string} latitude Latitude of Location
         * @param {string} [includeZoneDesc] Flag to return zone description
         * @param {string} [includeGeometry] Flag to return Geometry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFloodRiskByLocation(longitude: string, latitude: string, includeZoneDesc?: string, includeGeometry?: string, options?: any): AxiosPromise<FloodRiskResponse> {
            return localVarFp.getFloodRiskByLocation(longitude, latitude, includeZoneDesc, includeGeometry, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a Batch offering for \'Flood Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve flood risk data for flood zones and base flood elevation values.
         * @summary Post Flood Risk By Location
         * @param {FloodRiskByLocationRequest} floodRiskByLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFloodRiskByLocationBatch(floodRiskByLocationRequest: FloodRiskByLocationRequest, options?: any): AxiosPromise<FloodRiskResponseList> {
            return localVarFp.getFloodRiskByLocationBatch(floodRiskByLocationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RisksServiceApi - object-oriented interface
 * @export
 * @class RisksServiceApi
 * @extends {BaseAPI}
 */
export class RisksServiceApi extends BaseAPI {
    /**
     * Accepts addresses as input and Returns local crime indexes.
     * @summary Get Crime Risk By Address
     * @param {string} address free form address text
     * @param {string} [type] this is crime type; valid values are following 11 crime types with \&#39;all\&#39; as default (more than one can also be given as comma separated types)
     * @param {string} [includeGeometry] Y or N (default is N) - if it is Y, then geometry will be part of response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getCrimeRiskByAddress(address: string, type?: string, includeGeometry?: string, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getCrimeRiskByAddress(address, type, includeGeometry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a Batch offering for \'Crime Risk By Address\' service. It accepts a single address or a list of addresses and retrieve local crime indexes.
     * @summary Post Crime Risk By Address
     * @param {CrimeRiskByAddressBatchRequest} crimeRiskByAddressBatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getCrimeRiskByAddressBatch(crimeRiskByAddressBatchRequest: CrimeRiskByAddressBatchRequest, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getCrimeRiskByAddressBatch(crimeRiskByAddressBatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts latitude/longitude as input and returns and Returns local crime indexes.
     * @summary Get Crime Risk By  Location
     * @param {string} longitude The longitude of the location
     * @param {string} latitude The latitude of the location
     * @param {string} [type] this is crime type; valid values are following 11 crime types with \&#39;all\&#39; as default (more than one can also be given as comma separated types)
     * @param {string} [includeGeometry] Y or N (default is N) - if it is Y, then geometry will be part of response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getCrimeRiskByLocation(longitude: string, latitude: string, type?: string, includeGeometry?: string, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getCrimeRiskByLocation(longitude, latitude, type, includeGeometry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a Batch offering for \'Crime Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve local crime indexes.
     * @summary Post Crime Risk By Location
     * @param {CrimeRiskByLocationBatchRequest} crimeRiskByLocationBatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getCrimeRiskByLocationBatch(crimeRiskByLocationBatchRequest: CrimeRiskByLocationBatchRequest, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getCrimeRiskByLocationBatch(crimeRiskByLocationBatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts addresses as input and Returns the distance from nearest water bodies along with body name and location.
     * @summary Get Distance To Flood Hazard By Address
     * @param {string} [address] The address of the location
     * @param {string} [maxCandidates] This specifies the value of maxCandidates
     * @param {string} [waterBodyType] This specifies the value of waterBodyType
     * @param {string} [searchDistance] This specifies the search distance
     * @param {string} [searchDistanceUnit] miles (default value),feet, kilometers, meters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getDistanceToCoastByAddress(address?: string, maxCandidates?: string, waterBodyType?: string, searchDistance?: string, searchDistanceUnit?: string, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getDistanceToCoastByAddress(address, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a Batch offering for \'Distance To Flood Hazard By Address\' service. It accepts a single address or a list of addresses and retrieve the distance from nearest water bodies along with body name and location.
     * @summary Post Distance To Flood Hazard By Address
     * @param {DistanceToFloodHazardAddressRequest} distanceToFloodHazardAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getDistanceToCoastByAddressBatch(distanceToFloodHazardAddressRequest: DistanceToFloodHazardAddressRequest, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getDistanceToCoastByAddressBatch(distanceToFloodHazardAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts latitude & longitude as input and Returns the distance from nearest water bodies along with body name and location.
     * @summary Get Distance To Flood Hazard By Location
     * @param {string} [longitude] The longitude of the location
     * @param {string} [latitude] The latitude of the location
     * @param {string} [maxCandidates] This specifies the value of maxCandidates
     * @param {string} [waterBodyType] This specifies the value of waterBodyType
     * @param {string} [searchDistance] This specifies the search distance
     * @param {string} [searchDistanceUnit] miles (default value),feet, kilometers, meters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getDistanceToCoastByLocation(longitude?: string, latitude?: string, maxCandidates?: string, waterBodyType?: string, searchDistance?: string, searchDistanceUnit?: string, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getDistanceToCoastByLocation(longitude, latitude, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a Batch offering for \'Distance To Flood Hazard By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve the distance from nearest water bodies along with body name and location.
     * @summary Post Distance To Flood Hazard By Location
     * @param {DistanceToFloodHazardLocationRequest} distanceToFloodHazardLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getDistanceToCoastByLocationBatch(distanceToFloodHazardLocationRequest: DistanceToFloodHazardLocationRequest, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getDistanceToCoastByLocationBatch(distanceToFloodHazardLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts postcode as input and Returns historical earthquake details for a particular postcode.
     * @summary Earthquake History
     * @param {string} postCode 5 digit Postal code to search
     * @param {string} [startDate] Start time in milliseconds(UTC)
     * @param {string} [endDate] End time in milliseconds(UTC)
     * @param {string} [minMagnitude] Minimum richter scale magnitude
     * @param {string} [maxMagnitude] Maximum Richter scale magnitude
     * @param {string} [maxCandidates] Maximum response events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getEarthquakeHistory(postCode: string, startDate?: string, endDate?: string, minMagnitude?: string, maxMagnitude?: string, maxCandidates?: string, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getEarthquakeHistory(postCode, startDate, endDate, minMagnitude, maxMagnitude, maxCandidates, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts addresses as input and Returns counts of earthquakes for various richter measurements and values.
     * @summary Get Earthquake Risk By Address
     * @param {string} address free form address text
     * @param {string} [richterValue] all (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE
     * @param {string} [includeGeometry] Y or N (default is N) - if it is Y, then geometry will be part of response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getEarthquakeRiskByAddress(address: string, richterValue?: string, includeGeometry?: string, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getEarthquakeRiskByAddress(address, richterValue, includeGeometry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a Batch offering for \'Earthquake Risk By Address\' service. It accepts a single address or a list of addresses and retrieve counts of earthquakes for various richter measurements and values.
     * @summary Post Earthquake Risk By Address
     * @param {EarthquakeRiskByAddressRequest} earthquakeRiskByAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getEarthquakeRiskByAddressBatch(earthquakeRiskByAddressRequest: EarthquakeRiskByAddressRequest, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getEarthquakeRiskByAddressBatch(earthquakeRiskByAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts latitude & longitude as input and Returns counts of earthquakes for various richter measurements and values.
     * @summary Get Earthquake Risk By Location
     * @param {string} longitude The longitude of the location
     * @param {string} latitude The latitude of the location
     * @param {string} [richterValue] all (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE
     * @param {string} [includeGeometry] Y or N (default is N) - if it is Y, then geometry will be part of response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getEarthquakeRiskByLocation(longitude: string, latitude: string, richterValue?: string, includeGeometry?: string, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getEarthquakeRiskByLocation(longitude, latitude, richterValue, includeGeometry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a Batch offering for \'Earthquake Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve counts of earthquakes for various richter measurements and values.
     * @summary Post Earthquake Risk By Location
     * @param {EarthquakeRiskByLocationRequest} earthquakeRiskByLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getEarthquakeRiskByLocationBatch(earthquakeRiskByLocationRequest: EarthquakeRiskByLocationRequest, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getEarthquakeRiskByLocationBatch(earthquakeRiskByLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts postcode as input and Returns fire event details for a particular postcode.
     * @summary Get Fire History
     * @param {string} postCode 5 digit Postal code to search
     * @param {string} [startDate] Start time in milliseconds(UTC)
     * @param {string} [endDate] End time in milliseconds(UTC)
     * @param {string} [maxCandidates] Maximum response events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getFireHistory(postCode: string, startDate?: string, endDate?: string, maxCandidates?: string, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getFireHistory(postCode, startDate, endDate, maxCandidates, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts addresses as input and Returns fire risk data by risk types.
     * @summary Get Fire Risk By Address
     * @param {string} address Free form address text
     * @param {string} [includeGeometry] Flag to return Geometry default is N
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getFireRiskByAddress(address: string, includeGeometry?: string, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getFireRiskByAddress(address, includeGeometry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a Batch offering for \'Fire Risk By Address\' service. It accepts a single address or a list of addresses and retrieve fire risk data by risk types.
     * @summary Post Fire Risk By Address
     * @param {FireRiskByAddressRequest} fireRiskByAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getFireRiskByAddressBatch(fireRiskByAddressRequest: FireRiskByAddressRequest, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getFireRiskByAddressBatch(fireRiskByAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts latitude & longitude as input and Returns fire risk data by risk types.
     * @summary Get Fire Risk By Location
     * @param {string} longitude Longitude of Location
     * @param {string} latitude Latitude of Location
     * @param {string} [includeGeometry] Flag to return Geometry default is N
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getFireRiskByLocation(longitude: string, latitude: string, includeGeometry?: string, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getFireRiskByLocation(longitude, latitude, includeGeometry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a Batch offering for \'Fire Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve fire risk data by risk types.
     * @summary Post Fire Risk By Location
     * @param {FireRiskByLocationRequest} fireRiskByLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getFireRiskByLocationBatch(fireRiskByLocationRequest: FireRiskByLocationRequest, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getFireRiskByLocationBatch(fireRiskByLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts addresses as input and Returns nearest fire stations.
     * @summary Get Fire Station By Address
     * @param {string} address Free Address
     * @param {string} [maxCandidates] Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location.
     * @param {string} [travelTime] Max travel time from input location to fire station. Maximum allowed is 2 hours
     * @param {string} [travelTimeUnit] minutes (default), hours, seconds, milliseconds
     * @param {string} [travelDistance] Max travel distance from input location to fire station. Maximum allowed is 50 miles
     * @param {string} [travelDistanceUnit] Feet (default), Kilometers, Miles, Meters
     * @param {string} [sortBy] time (default), distance
     * @param {string} [historicTrafficTimeBucket] Historic traffic time slab
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getFireStationByAddress(address: string, maxCandidates?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, sortBy?: string, historicTrafficTimeBucket?: string, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getFireStationByAddress(address, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts latitude & longitude as input and Returns nearest fire stations.
     * @summary Get Fire Station By Location
     * @param {string} longitude Longitude of Location
     * @param {string} latitude Latitude of Location
     * @param {string} [maxCandidates] Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location.
     * @param {string} [travelTime] Max travel time from input location to fire station. Maximum allowed is 2 hours
     * @param {string} [travelTimeUnit] minutes (default), hours, seconds, milliseconds
     * @param {string} [travelDistance] Max travel distance from input location to fire station. Maximum allowed is 50 miles
     * @param {string} [travelDistanceUnit] Feet (default), Kilometers, Miles, Meters
     * @param {string} [sortBy] time (default), distance
     * @param {string} [historicTrafficTimeBucket] Historic traffic time slab
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getFireStationByLocation(longitude: string, latitude: string, maxCandidates?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, sortBy?: string, historicTrafficTimeBucket?: string, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getFireStationByLocation(longitude, latitude, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts addresses as input and Returns flood risk data for flood zones and base flood elevation values.
     * @summary Get Flood Risk By Address
     * @param {string} address Free text Address
     * @param {string} [includeZoneDesc] Flag to return zone description
     * @param {string} [includeGeometry] Flag to return Geometry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getFloodRiskByAddress(address: string, includeZoneDesc?: string, includeGeometry?: string, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getFloodRiskByAddress(address, includeZoneDesc, includeGeometry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a Batch offering for \'Flood Risk By Address\' service. It accepts a single address or a list of addresses and retrieve flood risk data for flood zones and base flood elevation values.
     * @summary Post Flood Risk By Address
     * @param {FloodRiskByAddressRequest} floodRiskByAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getFloodRiskByAddressBatch(floodRiskByAddressRequest: FloodRiskByAddressRequest, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getFloodRiskByAddressBatch(floodRiskByAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts latitude & longitude as input and Returns flood risk data for flood zones and base flood elevation values.
     * @summary Get Flood Risk By Location
     * @param {string} longitude Longitude of Location
     * @param {string} latitude Latitude of Location
     * @param {string} [includeZoneDesc] Flag to return zone description
     * @param {string} [includeGeometry] Flag to return Geometry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getFloodRiskByLocation(longitude: string, latitude: string, includeZoneDesc?: string, includeGeometry?: string, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getFloodRiskByLocation(longitude, latitude, includeZoneDesc, includeGeometry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a Batch offering for \'Flood Risk By Location\' service. It accepts a single location coordinate or a list of location coordinates and retrieve flood risk data for flood zones and base flood elevation values.
     * @summary Post Flood Risk By Location
     * @param {FloodRiskByLocationRequest} floodRiskByLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RisksServiceApi
     */
    public getFloodRiskByLocationBatch(floodRiskByLocationRequest: FloodRiskByLocationRequest, options?: AxiosRequestConfig) {
        return RisksServiceApiFp(this.oAuthCred,this.configuration).getFloodRiskByLocationBatch(floodRiskByLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RoutingServiceApi - axios parameter creator
 * @export
 */
export const RoutingServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * Accepts addresses as input and Returns Point-to-Point and Multi-Point travel directions by various travel modes.
         * @summary Gets Route By Address.
         * @param {string} [startAddress] Starting address of the route.
         * @param {string} [endAddress] Ending address of the route.
         * @param {string} [db] Mode of commute.
         * @param {string} [country] Three digit ISO country code.
         * @param {string} [intermediateAddresses] List of intermediate points of the route.
         * @param {string} [returnIntermediatePoints] return intermediate points
         * @param {string} [oip] Specifies whether waypoints need to be optimized.
         * @param {string} [destinationSrs] Specifies the desired coordinate system of the returned route.
         * @param {string} [optimizeBy] Specifies whether the route should be optimized by time or distance.
         * @param {string} [returnDistance] Specifies whether distance needs to be part of direction information in response.
         * @param {string} [distanceUnit] Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
         * @param {string} [returnTime] Specifies whether time needs to be part of direction information in response.
         * @param {string} [timeUnit] Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond)
         * @param {string} [language] Specifies the language of travel directions.
         * @param {string} [directionsStyle] Specifies whether route directions text is to be returned in the response and in what detail (Normal or Terse).
         * @param {string} [segmentGeometryStyle] Specifies whether the route geometry is to be returned in the response and in what detail (End or All).
         * @param {string} [primaryNameOnly] If true then only the primary street name is returned otherwise all the names for a street.
         * @param {string} [majorRoads] Whether to include all roads in route calculation or just major roads.
         * @param {string} [historicTrafficTimeBucket] Specifies whether routing calculation uses the historic traffic speeds.
         * @param {string} [returnDirectionGeometry] Whether to include geometry associated with each route instruction in response.
         * @param {string} [useCvr] This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs.
         * @param {string} [looseningBarrierRestrictions] Specifies that barriers will be removed when determining the route.
         * @param {string} [vehicleType] vehicle type.
         * @param {string} [weight] Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [weightUnit] The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton).
         * @param {string} [height] Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [heightUnit] The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [length] Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [lengthUnit] The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [width] Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [widthUnit] The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteByAddress: async (startAddress?: string, endAddress?: string, db?: string, country?: string, intermediateAddresses?: string, returnIntermediatePoints?: string, oip?: string, destinationSrs?: string, optimizeBy?: string, returnDistance?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, language?: string, directionsStyle?: string, segmentGeometryStyle?: string, primaryNameOnly?: string, majorRoads?: string, historicTrafficTimeBucket?: string, returnDirectionGeometry?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/routing/v1/route/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (startAddress !== undefined) {
                localVarQueryParameter['startAddress'] = startAddress;
            }

            if (endAddress !== undefined) {
                localVarQueryParameter['endAddress'] = endAddress;
            }

            if (db !== undefined) {
                localVarQueryParameter['db'] = db;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (intermediateAddresses !== undefined) {
                localVarQueryParameter['intermediateAddresses'] = intermediateAddresses;
            }

            if (returnIntermediatePoints !== undefined) {
                localVarQueryParameter['returnIntermediatePoints'] = returnIntermediatePoints;
            }

            if (oip !== undefined) {
                localVarQueryParameter['oip'] = oip;
            }

            if (destinationSrs !== undefined) {
                localVarQueryParameter['destinationSrs'] = destinationSrs;
            }

            if (optimizeBy !== undefined) {
                localVarQueryParameter['optimizeBy'] = optimizeBy;
            }

            if (returnDistance !== undefined) {
                localVarQueryParameter['returnDistance'] = returnDistance;
            }

            if (distanceUnit !== undefined) {
                localVarQueryParameter['distanceUnit'] = distanceUnit;
            }

            if (returnTime !== undefined) {
                localVarQueryParameter['returnTime'] = returnTime;
            }

            if (timeUnit !== undefined) {
                localVarQueryParameter['timeUnit'] = timeUnit;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (directionsStyle !== undefined) {
                localVarQueryParameter['directionsStyle'] = directionsStyle;
            }

            if (segmentGeometryStyle !== undefined) {
                localVarQueryParameter['segmentGeometryStyle'] = segmentGeometryStyle;
            }

            if (primaryNameOnly !== undefined) {
                localVarQueryParameter['primaryNameOnly'] = primaryNameOnly;
            }

            if (majorRoads !== undefined) {
                localVarQueryParameter['majorRoads'] = majorRoads;
            }

            if (historicTrafficTimeBucket !== undefined) {
                localVarQueryParameter['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
            }

            if (returnDirectionGeometry !== undefined) {
                localVarQueryParameter['returnDirectionGeometry'] = returnDirectionGeometry;
            }

            if (useCvr !== undefined) {
                localVarQueryParameter['useCvr'] = useCvr;
            }

            if (looseningBarrierRestrictions !== undefined) {
                localVarQueryParameter['looseningBarrierRestrictions'] = looseningBarrierRestrictions;
            }

            if (vehicleType !== undefined) {
                localVarQueryParameter['vehicleType'] = vehicleType;
            }

            if (weight !== undefined) {
                localVarQueryParameter['weight'] = weight;
            }

            if (weightUnit !== undefined) {
                localVarQueryParameter['weightUnit'] = weightUnit;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (heightUnit !== undefined) {
                localVarQueryParameter['heightUnit'] = heightUnit;
            }

            if (length !== undefined) {
                localVarQueryParameter['length'] = length;
            }

            if (lengthUnit !== undefined) {
                localVarQueryParameter['lengthUnit'] = lengthUnit;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (widthUnit !== undefined) {
                localVarQueryParameter['widthUnit'] = widthUnit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts latitude & longitude as input and Returns Point-to-Point and Multi-Point travel directions by various travel modes.
         * @summary Gets Route By Location.
         * @param {string} [startPoint] Start Point in \&#39;Lat,Long,coordsys\&#39; format.
         * @param {string} [endPoint] End Point in \&#39;Lat,Long,coordsys\&#39; format.
         * @param {string} [db] Mode of commute.
         * @param {string} [intermediatePoints] List of intermediate points of the route.
         * @param {string} [returnIntermediatePoints] returnIntermediatePoints route.
         * @param {string} [oip] Specifies whether waypoints need to be optimized.
         * @param {string} [destinationSrs] Specifies the desired coordinate system of the returned route.
         * @param {string} [optimizeBy] Specifies whether the route should be optimized by time or distance.
         * @param {string} [returnDistance] Specifies whether distance needs to be part of direction information in response.
         * @param {string} [distanceUnit] Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
         * @param {string} [returnTime] Specifies whether time needs to be part of direction information in response.
         * @param {string} [timeUnit] Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond)
         * @param {string} [language] Specifies the language of travel directions.
         * @param {string} [directionsStyle] Specifies whether route directions text is to be returned in the response and in what detail (Normal or Terse).
         * @param {string} [segmentGeometryStyle] Specifies whether the route geometry is to be returned in the response and in what detail (End or All).
         * @param {string} [primaryNameOnly] If true then only the primary street name is returned otherwise all the names for a street.
         * @param {string} [majorRoads] Whether to include all roads in route calculation or just major roads.
         * @param {string} [historicTrafficTimeBucket] Specifies whether routing calculation uses the historic traffic speeds.
         * @param {string} [returnDirectionGeometry] Whether to include geometry associated with each route instruction in response.
         * @param {string} [useCvr] This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs.
         * @param {string} [looseningBarrierRestrictions] Specifies that barriers will be removed when determining the route.
         * @param {string} [vehicleType] vehicle type.
         * @param {string} [weight] Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [weightUnit] The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton).
         * @param {string} [height] Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [heightUnit] The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [length] Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [lengthUnit] The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [width] Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [widthUnit] The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteByLocation: async (startPoint?: string, endPoint?: string, db?: string, intermediatePoints?: string, returnIntermediatePoints?: string, oip?: string, destinationSrs?: string, optimizeBy?: string, returnDistance?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, language?: string, directionsStyle?: string, segmentGeometryStyle?: string, primaryNameOnly?: string, majorRoads?: string, historicTrafficTimeBucket?: string, returnDirectionGeometry?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/routing/v1/route/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (startPoint !== undefined) {
                localVarQueryParameter['startPoint'] = startPoint;
            }

            if (endPoint !== undefined) {
                localVarQueryParameter['endPoint'] = endPoint;
            }

            if (db !== undefined) {
                localVarQueryParameter['db'] = db;
            }

            if (intermediatePoints !== undefined) {
                localVarQueryParameter['intermediatePoints'] = intermediatePoints;
            }

            if (returnIntermediatePoints !== undefined) {
                localVarQueryParameter['returnIntermediatePoints'] = returnIntermediatePoints;
            }

            if (oip !== undefined) {
                localVarQueryParameter['oip'] = oip;
            }

            if (destinationSrs !== undefined) {
                localVarQueryParameter['destinationSrs'] = destinationSrs;
            }

            if (optimizeBy !== undefined) {
                localVarQueryParameter['optimizeBy'] = optimizeBy;
            }

            if (returnDistance !== undefined) {
                localVarQueryParameter['returnDistance'] = returnDistance;
            }

            if (distanceUnit !== undefined) {
                localVarQueryParameter['distanceUnit'] = distanceUnit;
            }

            if (returnTime !== undefined) {
                localVarQueryParameter['returnTime'] = returnTime;
            }

            if (timeUnit !== undefined) {
                localVarQueryParameter['timeUnit'] = timeUnit;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (directionsStyle !== undefined) {
                localVarQueryParameter['directionsStyle'] = directionsStyle;
            }

            if (segmentGeometryStyle !== undefined) {
                localVarQueryParameter['segmentGeometryStyle'] = segmentGeometryStyle;
            }

            if (primaryNameOnly !== undefined) {
                localVarQueryParameter['primaryNameOnly'] = primaryNameOnly;
            }

            if (majorRoads !== undefined) {
                localVarQueryParameter['majorRoads'] = majorRoads;
            }

            if (historicTrafficTimeBucket !== undefined) {
                localVarQueryParameter['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
            }

            if (returnDirectionGeometry !== undefined) {
                localVarQueryParameter['returnDirectionGeometry'] = returnDirectionGeometry;
            }

            if (useCvr !== undefined) {
                localVarQueryParameter['useCvr'] = useCvr;
            }

            if (looseningBarrierRestrictions !== undefined) {
                localVarQueryParameter['looseningBarrierRestrictions'] = looseningBarrierRestrictions;
            }

            if (vehicleType !== undefined) {
                localVarQueryParameter['vehicleType'] = vehicleType;
            }

            if (weight !== undefined) {
                localVarQueryParameter['weight'] = weight;
            }

            if (weightUnit !== undefined) {
                localVarQueryParameter['weightUnit'] = weightUnit;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (heightUnit !== undefined) {
                localVarQueryParameter['heightUnit'] = heightUnit;
            }

            if (length !== undefined) {
                localVarQueryParameter['length'] = length;
            }

            if (lengthUnit !== undefined) {
                localVarQueryParameter['lengthUnit'] = lengthUnit;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (widthUnit !== undefined) {
                localVarQueryParameter['widthUnit'] = widthUnit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts addresses as input and Returns travel distances and times for multiple origins to multiple destinations by various travel modes.
         * @summary Get Cost Matrix By Address.
         * @param {string} [startAddresses] Start locations in text based addresses.
         * @param {string} [endAddresses] End locations in text based addresses.
         * @param {string} [country] 3 Digit ISO country code.
         * @param {string} [db] Mode of commute.
         * @param {string} [optimizeBy] Specifies whether routes should be optimized by time or distance.
         * @param {string} [returnDistance] Specifies whether distance needs to be returned in response.
         * @param {string} [destinationSrs] Specifies the desired coordinate system of returned routes.
         * @param {string} [distanceUnit] Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
         * @param {string} [returnTime] Specifies whether time needs to be returned in response.
         * @param {string} [timeUnit] Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
         * @param {string} [majorRoads] Whether to include all roads in routes calculation or just major roads.
         * @param {string} [returnOptimalRoutesOnly] Specifies whether to return only the optimized route for each start and end point combination.
         * @param {string} [historicTrafficTimeBucket] Specifies whether routing calculation uses the historic traffic speeds.
         * @param {string} [useCvr] This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs.
         * @param {string} [looseningBarrierRestrictions] Specifies that barriers will be removed when determining the route.
         * @param {string} [vehicleType] vehicle type.
         * @param {string} [weight] Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [weightUnit] The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton).
         * @param {string} [height] Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [heightUnit] The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [length] Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [lengthUnit] The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [width] Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [widthUnit] The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTravelCostMatrixByAddress: async (startAddresses?: string, endAddresses?: string, country?: string, db?: string, optimizeBy?: string, returnDistance?: string, destinationSrs?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, majorRoads?: string, returnOptimalRoutesOnly?: string, historicTrafficTimeBucket?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/routing/v1/travelcostmatrix/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (startAddresses !== undefined) {
                localVarQueryParameter['startAddresses'] = startAddresses;
            }

            if (endAddresses !== undefined) {
                localVarQueryParameter['endAddresses'] = endAddresses;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (db !== undefined) {
                localVarQueryParameter['db'] = db;
            }

            if (optimizeBy !== undefined) {
                localVarQueryParameter['optimizeBy'] = optimizeBy;
            }

            if (returnDistance !== undefined) {
                localVarQueryParameter['returnDistance'] = returnDistance;
            }

            if (destinationSrs !== undefined) {
                localVarQueryParameter['destinationSrs'] = destinationSrs;
            }

            if (distanceUnit !== undefined) {
                localVarQueryParameter['distanceUnit'] = distanceUnit;
            }

            if (returnTime !== undefined) {
                localVarQueryParameter['returnTime'] = returnTime;
            }

            if (timeUnit !== undefined) {
                localVarQueryParameter['timeUnit'] = timeUnit;
            }

            if (majorRoads !== undefined) {
                localVarQueryParameter['majorRoads'] = majorRoads;
            }

            if (returnOptimalRoutesOnly !== undefined) {
                localVarQueryParameter['returnOptimalRoutesOnly'] = returnOptimalRoutesOnly;
            }

            if (historicTrafficTimeBucket !== undefined) {
                localVarQueryParameter['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
            }

            if (useCvr !== undefined) {
                localVarQueryParameter['useCvr'] = useCvr;
            }

            if (looseningBarrierRestrictions !== undefined) {
                localVarQueryParameter['looseningBarrierRestrictions'] = looseningBarrierRestrictions;
            }

            if (vehicleType !== undefined) {
                localVarQueryParameter['vehicleType'] = vehicleType;
            }

            if (weight !== undefined) {
                localVarQueryParameter['weight'] = weight;
            }

            if (weightUnit !== undefined) {
                localVarQueryParameter['weightUnit'] = weightUnit;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (heightUnit !== undefined) {
                localVarQueryParameter['heightUnit'] = heightUnit;
            }

            if (length !== undefined) {
                localVarQueryParameter['length'] = length;
            }

            if (lengthUnit !== undefined) {
                localVarQueryParameter['lengthUnit'] = lengthUnit;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (widthUnit !== undefined) {
                localVarQueryParameter['widthUnit'] = widthUnit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts latitude & longitude as input and Returns travel distances and times for multiple origins to multiple destinations by various travel modes.
         * @summary Get Cost Matrix By Location.
         * @param {string} [startPoints] The address to be searched.
         * @param {string} [endPoints] The address to be searched.
         * @param {string} [db] Mode of commute.
         * @param {string} [optimizeBy] Specifies whether routes should be optimized by time or distance.
         * @param {string} [returnDistance] Specifies whether distance needs to be returned in response.
         * @param {string} [destinationSrs] Specifies the desired coordinate system of returned routes.
         * @param {string} [distanceUnit] Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
         * @param {string} [returnTime] Specifies whether time needs to be returned in response.
         * @param {string} [timeUnit] Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
         * @param {string} [majorRoads] Whether to include all roads in routes calculation or just major roads.
         * @param {string} [returnOptimalRoutesOnly] Specifies whether to return only the optimized route for each start and end point combination.
         * @param {string} [historicTrafficTimeBucket] Specifies whether routing calculation uses the historic traffic speeds.
         * @param {string} [useCvr] This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs.
         * @param {string} [looseningBarrierRestrictions] Specifies that barriers will be removed when determining the route.
         * @param {string} [vehicleType] vehicle type.
         * @param {string} [weight] Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [weightUnit] The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton).
         * @param {string} [height] Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [heightUnit] The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [length] Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [lengthUnit] The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [width] Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [widthUnit] The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTravelCostMatrixByLocation: async (startPoints?: string, endPoints?: string, db?: string, optimizeBy?: string, returnDistance?: string, destinationSrs?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, majorRoads?: string, returnOptimalRoutesOnly?: string, historicTrafficTimeBucket?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/routing/v1/travelcostmatrix/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (startPoints !== undefined) {
                localVarQueryParameter['startPoints'] = startPoints;
            }

            if (endPoints !== undefined) {
                localVarQueryParameter['endPoints'] = endPoints;
            }

            if (db !== undefined) {
                localVarQueryParameter['db'] = db;
            }

            if (optimizeBy !== undefined) {
                localVarQueryParameter['optimizeBy'] = optimizeBy;
            }

            if (returnDistance !== undefined) {
                localVarQueryParameter['returnDistance'] = returnDistance;
            }

            if (destinationSrs !== undefined) {
                localVarQueryParameter['destinationSrs'] = destinationSrs;
            }

            if (distanceUnit !== undefined) {
                localVarQueryParameter['distanceUnit'] = distanceUnit;
            }

            if (returnTime !== undefined) {
                localVarQueryParameter['returnTime'] = returnTime;
            }

            if (timeUnit !== undefined) {
                localVarQueryParameter['timeUnit'] = timeUnit;
            }

            if (majorRoads !== undefined) {
                localVarQueryParameter['majorRoads'] = majorRoads;
            }

            if (returnOptimalRoutesOnly !== undefined) {
                localVarQueryParameter['returnOptimalRoutesOnly'] = returnOptimalRoutesOnly;
            }

            if (historicTrafficTimeBucket !== undefined) {
                localVarQueryParameter['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
            }

            if (useCvr !== undefined) {
                localVarQueryParameter['useCvr'] = useCvr;
            }

            if (looseningBarrierRestrictions !== undefined) {
                localVarQueryParameter['looseningBarrierRestrictions'] = looseningBarrierRestrictions;
            }

            if (vehicleType !== undefined) {
                localVarQueryParameter['vehicleType'] = vehicleType;
            }

            if (weight !== undefined) {
                localVarQueryParameter['weight'] = weight;
            }

            if (weightUnit !== undefined) {
                localVarQueryParameter['weightUnit'] = weightUnit;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (heightUnit !== undefined) {
                localVarQueryParameter['heightUnit'] = heightUnit;
            }

            if (length !== undefined) {
                localVarQueryParameter['length'] = length;
            }

            if (lengthUnit !== undefined) {
                localVarQueryParameter['lengthUnit'] = lengthUnit;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (widthUnit !== undefined) {
                localVarQueryParameter['widthUnit'] = widthUnit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoutingServiceApi - functional programming interface
 * @export
 */
export const RoutingServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = RoutingServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * Accepts addresses as input and Returns Point-to-Point and Multi-Point travel directions by various travel modes.
         * @summary Gets Route By Address.
         * @param {string} [startAddress] Starting address of the route.
         * @param {string} [endAddress] Ending address of the route.
         * @param {string} [db] Mode of commute.
         * @param {string} [country] Three digit ISO country code.
         * @param {string} [intermediateAddresses] List of intermediate points of the route.
         * @param {string} [returnIntermediatePoints] return intermediate points
         * @param {string} [oip] Specifies whether waypoints need to be optimized.
         * @param {string} [destinationSrs] Specifies the desired coordinate system of the returned route.
         * @param {string} [optimizeBy] Specifies whether the route should be optimized by time or distance.
         * @param {string} [returnDistance] Specifies whether distance needs to be part of direction information in response.
         * @param {string} [distanceUnit] Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
         * @param {string} [returnTime] Specifies whether time needs to be part of direction information in response.
         * @param {string} [timeUnit] Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond)
         * @param {string} [language] Specifies the language of travel directions.
         * @param {string} [directionsStyle] Specifies whether route directions text is to be returned in the response and in what detail (Normal or Terse).
         * @param {string} [segmentGeometryStyle] Specifies whether the route geometry is to be returned in the response and in what detail (End or All).
         * @param {string} [primaryNameOnly] If true then only the primary street name is returned otherwise all the names for a street.
         * @param {string} [majorRoads] Whether to include all roads in route calculation or just major roads.
         * @param {string} [historicTrafficTimeBucket] Specifies whether routing calculation uses the historic traffic speeds.
         * @param {string} [returnDirectionGeometry] Whether to include geometry associated with each route instruction in response.
         * @param {string} [useCvr] This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs.
         * @param {string} [looseningBarrierRestrictions] Specifies that barriers will be removed when determining the route.
         * @param {string} [vehicleType] vehicle type.
         * @param {string} [weight] Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [weightUnit] The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton).
         * @param {string} [height] Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [heightUnit] The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [length] Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [lengthUnit] The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [width] Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [widthUnit] The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteByAddress(startAddress?: string, endAddress?: string, db?: string, country?: string, intermediateAddresses?: string, returnIntermediatePoints?: string, oip?: string, destinationSrs?: string, optimizeBy?: string, returnDistance?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, language?: string, directionsStyle?: string, segmentGeometryStyle?: string, primaryNameOnly?: string, majorRoads?: string, historicTrafficTimeBucket?: string, returnDirectionGeometry?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteByAddress(startAddress, endAddress, db, country, intermediateAddresses, returnIntermediatePoints, oip, destinationSrs, optimizeBy, returnDistance, distanceUnit, returnTime, timeUnit, language, directionsStyle, segmentGeometryStyle, primaryNameOnly, majorRoads, historicTrafficTimeBucket, returnDirectionGeometry, useCvr, looseningBarrierRestrictions, vehicleType, weight, weightUnit, height, heightUnit, length, lengthUnit, width, widthUnit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts latitude & longitude as input and Returns Point-to-Point and Multi-Point travel directions by various travel modes.
         * @summary Gets Route By Location.
         * @param {string} [startPoint] Start Point in \&#39;Lat,Long,coordsys\&#39; format.
         * @param {string} [endPoint] End Point in \&#39;Lat,Long,coordsys\&#39; format.
         * @param {string} [db] Mode of commute.
         * @param {string} [intermediatePoints] List of intermediate points of the route.
         * @param {string} [returnIntermediatePoints] returnIntermediatePoints route.
         * @param {string} [oip] Specifies whether waypoints need to be optimized.
         * @param {string} [destinationSrs] Specifies the desired coordinate system of the returned route.
         * @param {string} [optimizeBy] Specifies whether the route should be optimized by time or distance.
         * @param {string} [returnDistance] Specifies whether distance needs to be part of direction information in response.
         * @param {string} [distanceUnit] Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
         * @param {string} [returnTime] Specifies whether time needs to be part of direction information in response.
         * @param {string} [timeUnit] Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond)
         * @param {string} [language] Specifies the language of travel directions.
         * @param {string} [directionsStyle] Specifies whether route directions text is to be returned in the response and in what detail (Normal or Terse).
         * @param {string} [segmentGeometryStyle] Specifies whether the route geometry is to be returned in the response and in what detail (End or All).
         * @param {string} [primaryNameOnly] If true then only the primary street name is returned otherwise all the names for a street.
         * @param {string} [majorRoads] Whether to include all roads in route calculation or just major roads.
         * @param {string} [historicTrafficTimeBucket] Specifies whether routing calculation uses the historic traffic speeds.
         * @param {string} [returnDirectionGeometry] Whether to include geometry associated with each route instruction in response.
         * @param {string} [useCvr] This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs.
         * @param {string} [looseningBarrierRestrictions] Specifies that barriers will be removed when determining the route.
         * @param {string} [vehicleType] vehicle type.
         * @param {string} [weight] Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [weightUnit] The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton).
         * @param {string} [height] Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [heightUnit] The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [length] Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [lengthUnit] The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [width] Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [widthUnit] The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteByLocation(startPoint?: string, endPoint?: string, db?: string, intermediatePoints?: string, returnIntermediatePoints?: string, oip?: string, destinationSrs?: string, optimizeBy?: string, returnDistance?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, language?: string, directionsStyle?: string, segmentGeometryStyle?: string, primaryNameOnly?: string, majorRoads?: string, historicTrafficTimeBucket?: string, returnDirectionGeometry?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteByLocation(startPoint, endPoint, db, intermediatePoints, returnIntermediatePoints, oip, destinationSrs, optimizeBy, returnDistance, distanceUnit, returnTime, timeUnit, language, directionsStyle, segmentGeometryStyle, primaryNameOnly, majorRoads, historicTrafficTimeBucket, returnDirectionGeometry, useCvr, looseningBarrierRestrictions, vehicleType, weight, weightUnit, height, heightUnit, length, lengthUnit, width, widthUnit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts addresses as input and Returns travel distances and times for multiple origins to multiple destinations by various travel modes.
         * @summary Get Cost Matrix By Address.
         * @param {string} [startAddresses] Start locations in text based addresses.
         * @param {string} [endAddresses] End locations in text based addresses.
         * @param {string} [country] 3 Digit ISO country code.
         * @param {string} [db] Mode of commute.
         * @param {string} [optimizeBy] Specifies whether routes should be optimized by time or distance.
         * @param {string} [returnDistance] Specifies whether distance needs to be returned in response.
         * @param {string} [destinationSrs] Specifies the desired coordinate system of returned routes.
         * @param {string} [distanceUnit] Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
         * @param {string} [returnTime] Specifies whether time needs to be returned in response.
         * @param {string} [timeUnit] Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
         * @param {string} [majorRoads] Whether to include all roads in routes calculation or just major roads.
         * @param {string} [returnOptimalRoutesOnly] Specifies whether to return only the optimized route for each start and end point combination.
         * @param {string} [historicTrafficTimeBucket] Specifies whether routing calculation uses the historic traffic speeds.
         * @param {string} [useCvr] This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs.
         * @param {string} [looseningBarrierRestrictions] Specifies that barriers will be removed when determining the route.
         * @param {string} [vehicleType] vehicle type.
         * @param {string} [weight] Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [weightUnit] The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton).
         * @param {string} [height] Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [heightUnit] The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [length] Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [lengthUnit] The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [width] Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [widthUnit] The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTravelCostMatrixByAddress(startAddresses?: string, endAddresses?: string, country?: string, db?: string, optimizeBy?: string, returnDistance?: string, destinationSrs?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, majorRoads?: string, returnOptimalRoutesOnly?: string, historicTrafficTimeBucket?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TravelCostMatrixResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTravelCostMatrixByAddress(startAddresses, endAddresses, country, db, optimizeBy, returnDistance, destinationSrs, distanceUnit, returnTime, timeUnit, majorRoads, returnOptimalRoutesOnly, historicTrafficTimeBucket, useCvr, looseningBarrierRestrictions, vehicleType, weight, weightUnit, height, heightUnit, length, lengthUnit, width, widthUnit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts latitude & longitude as input and Returns travel distances and times for multiple origins to multiple destinations by various travel modes.
         * @summary Get Cost Matrix By Location.
         * @param {string} [startPoints] The address to be searched.
         * @param {string} [endPoints] The address to be searched.
         * @param {string} [db] Mode of commute.
         * @param {string} [optimizeBy] Specifies whether routes should be optimized by time or distance.
         * @param {string} [returnDistance] Specifies whether distance needs to be returned in response.
         * @param {string} [destinationSrs] Specifies the desired coordinate system of returned routes.
         * @param {string} [distanceUnit] Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
         * @param {string} [returnTime] Specifies whether time needs to be returned in response.
         * @param {string} [timeUnit] Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
         * @param {string} [majorRoads] Whether to include all roads in routes calculation or just major roads.
         * @param {string} [returnOptimalRoutesOnly] Specifies whether to return only the optimized route for each start and end point combination.
         * @param {string} [historicTrafficTimeBucket] Specifies whether routing calculation uses the historic traffic speeds.
         * @param {string} [useCvr] This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs.
         * @param {string} [looseningBarrierRestrictions] Specifies that barriers will be removed when determining the route.
         * @param {string} [vehicleType] vehicle type.
         * @param {string} [weight] Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [weightUnit] The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton).
         * @param {string} [height] Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [heightUnit] The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [length] Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [lengthUnit] The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [width] Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [widthUnit] The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTravelCostMatrixByLocation(startPoints?: string, endPoints?: string, db?: string, optimizeBy?: string, returnDistance?: string, destinationSrs?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, majorRoads?: string, returnOptimalRoutesOnly?: string, historicTrafficTimeBucket?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TravelCostMatrixResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTravelCostMatrixByLocation(startPoints, endPoints, db, optimizeBy, returnDistance, destinationSrs, distanceUnit, returnTime, timeUnit, majorRoads, returnOptimalRoutesOnly, historicTrafficTimeBucket, useCvr, looseningBarrierRestrictions, vehicleType, weight, weightUnit, height, heightUnit, length, lengthUnit, width, widthUnit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RoutingServiceApi - factory interface
 * @export
 */
export const RoutingServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoutingServiceApiFp(oAuth,configuration)
    return {
        /**
         * Accepts addresses as input and Returns Point-to-Point and Multi-Point travel directions by various travel modes.
         * @summary Gets Route By Address.
         * @param {string} [startAddress] Starting address of the route.
         * @param {string} [endAddress] Ending address of the route.
         * @param {string} [db] Mode of commute.
         * @param {string} [country] Three digit ISO country code.
         * @param {string} [intermediateAddresses] List of intermediate points of the route.
         * @param {string} [returnIntermediatePoints] return intermediate points
         * @param {string} [oip] Specifies whether waypoints need to be optimized.
         * @param {string} [destinationSrs] Specifies the desired coordinate system of the returned route.
         * @param {string} [optimizeBy] Specifies whether the route should be optimized by time or distance.
         * @param {string} [returnDistance] Specifies whether distance needs to be part of direction information in response.
         * @param {string} [distanceUnit] Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
         * @param {string} [returnTime] Specifies whether time needs to be part of direction information in response.
         * @param {string} [timeUnit] Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond)
         * @param {string} [language] Specifies the language of travel directions.
         * @param {string} [directionsStyle] Specifies whether route directions text is to be returned in the response and in what detail (Normal or Terse).
         * @param {string} [segmentGeometryStyle] Specifies whether the route geometry is to be returned in the response and in what detail (End or All).
         * @param {string} [primaryNameOnly] If true then only the primary street name is returned otherwise all the names for a street.
         * @param {string} [majorRoads] Whether to include all roads in route calculation or just major roads.
         * @param {string} [historicTrafficTimeBucket] Specifies whether routing calculation uses the historic traffic speeds.
         * @param {string} [returnDirectionGeometry] Whether to include geometry associated with each route instruction in response.
         * @param {string} [useCvr] This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs.
         * @param {string} [looseningBarrierRestrictions] Specifies that barriers will be removed when determining the route.
         * @param {string} [vehicleType] vehicle type.
         * @param {string} [weight] Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [weightUnit] The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton).
         * @param {string} [height] Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [heightUnit] The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [length] Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [lengthUnit] The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [width] Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [widthUnit] The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteByAddress(startAddress?: string, endAddress?: string, db?: string, country?: string, intermediateAddresses?: string, returnIntermediatePoints?: string, oip?: string, destinationSrs?: string, optimizeBy?: string, returnDistance?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, language?: string, directionsStyle?: string, segmentGeometryStyle?: string, primaryNameOnly?: string, majorRoads?: string, historicTrafficTimeBucket?: string, returnDirectionGeometry?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string, options?: any): AxiosPromise<RouteResponse> {
            return localVarFp.getRouteByAddress(startAddress, endAddress, db, country, intermediateAddresses, returnIntermediatePoints, oip, destinationSrs, optimizeBy, returnDistance, distanceUnit, returnTime, timeUnit, language, directionsStyle, segmentGeometryStyle, primaryNameOnly, majorRoads, historicTrafficTimeBucket, returnDirectionGeometry, useCvr, looseningBarrierRestrictions, vehicleType, weight, weightUnit, height, heightUnit, length, lengthUnit, width, widthUnit, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts latitude & longitude as input and Returns Point-to-Point and Multi-Point travel directions by various travel modes.
         * @summary Gets Route By Location.
         * @param {string} [startPoint] Start Point in \&#39;Lat,Long,coordsys\&#39; format.
         * @param {string} [endPoint] End Point in \&#39;Lat,Long,coordsys\&#39; format.
         * @param {string} [db] Mode of commute.
         * @param {string} [intermediatePoints] List of intermediate points of the route.
         * @param {string} [returnIntermediatePoints] returnIntermediatePoints route.
         * @param {string} [oip] Specifies whether waypoints need to be optimized.
         * @param {string} [destinationSrs] Specifies the desired coordinate system of the returned route.
         * @param {string} [optimizeBy] Specifies whether the route should be optimized by time or distance.
         * @param {string} [returnDistance] Specifies whether distance needs to be part of direction information in response.
         * @param {string} [distanceUnit] Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
         * @param {string} [returnTime] Specifies whether time needs to be part of direction information in response.
         * @param {string} [timeUnit] Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond)
         * @param {string} [language] Specifies the language of travel directions.
         * @param {string} [directionsStyle] Specifies whether route directions text is to be returned in the response and in what detail (Normal or Terse).
         * @param {string} [segmentGeometryStyle] Specifies whether the route geometry is to be returned in the response and in what detail (End or All).
         * @param {string} [primaryNameOnly] If true then only the primary street name is returned otherwise all the names for a street.
         * @param {string} [majorRoads] Whether to include all roads in route calculation or just major roads.
         * @param {string} [historicTrafficTimeBucket] Specifies whether routing calculation uses the historic traffic speeds.
         * @param {string} [returnDirectionGeometry] Whether to include geometry associated with each route instruction in response.
         * @param {string} [useCvr] This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs.
         * @param {string} [looseningBarrierRestrictions] Specifies that barriers will be removed when determining the route.
         * @param {string} [vehicleType] vehicle type.
         * @param {string} [weight] Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [weightUnit] The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton).
         * @param {string} [height] Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [heightUnit] The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [length] Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [lengthUnit] The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [width] Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [widthUnit] The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteByLocation(startPoint?: string, endPoint?: string, db?: string, intermediatePoints?: string, returnIntermediatePoints?: string, oip?: string, destinationSrs?: string, optimizeBy?: string, returnDistance?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, language?: string, directionsStyle?: string, segmentGeometryStyle?: string, primaryNameOnly?: string, majorRoads?: string, historicTrafficTimeBucket?: string, returnDirectionGeometry?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string, options?: any): AxiosPromise<RouteResponse> {
            return localVarFp.getRouteByLocation(startPoint, endPoint, db, intermediatePoints, returnIntermediatePoints, oip, destinationSrs, optimizeBy, returnDistance, distanceUnit, returnTime, timeUnit, language, directionsStyle, segmentGeometryStyle, primaryNameOnly, majorRoads, historicTrafficTimeBucket, returnDirectionGeometry, useCvr, looseningBarrierRestrictions, vehicleType, weight, weightUnit, height, heightUnit, length, lengthUnit, width, widthUnit, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts addresses as input and Returns travel distances and times for multiple origins to multiple destinations by various travel modes.
         * @summary Get Cost Matrix By Address.
         * @param {string} [startAddresses] Start locations in text based addresses.
         * @param {string} [endAddresses] End locations in text based addresses.
         * @param {string} [country] 3 Digit ISO country code.
         * @param {string} [db] Mode of commute.
         * @param {string} [optimizeBy] Specifies whether routes should be optimized by time or distance.
         * @param {string} [returnDistance] Specifies whether distance needs to be returned in response.
         * @param {string} [destinationSrs] Specifies the desired coordinate system of returned routes.
         * @param {string} [distanceUnit] Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
         * @param {string} [returnTime] Specifies whether time needs to be returned in response.
         * @param {string} [timeUnit] Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
         * @param {string} [majorRoads] Whether to include all roads in routes calculation or just major roads.
         * @param {string} [returnOptimalRoutesOnly] Specifies whether to return only the optimized route for each start and end point combination.
         * @param {string} [historicTrafficTimeBucket] Specifies whether routing calculation uses the historic traffic speeds.
         * @param {string} [useCvr] This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs.
         * @param {string} [looseningBarrierRestrictions] Specifies that barriers will be removed when determining the route.
         * @param {string} [vehicleType] vehicle type.
         * @param {string} [weight] Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [weightUnit] The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton).
         * @param {string} [height] Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [heightUnit] The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [length] Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [lengthUnit] The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [width] Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [widthUnit] The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTravelCostMatrixByAddress(startAddresses?: string, endAddresses?: string, country?: string, db?: string, optimizeBy?: string, returnDistance?: string, destinationSrs?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, majorRoads?: string, returnOptimalRoutesOnly?: string, historicTrafficTimeBucket?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string, options?: any): AxiosPromise<TravelCostMatrixResponse> {
            return localVarFp.getTravelCostMatrixByAddress(startAddresses, endAddresses, country, db, optimizeBy, returnDistance, destinationSrs, distanceUnit, returnTime, timeUnit, majorRoads, returnOptimalRoutesOnly, historicTrafficTimeBucket, useCvr, looseningBarrierRestrictions, vehicleType, weight, weightUnit, height, heightUnit, length, lengthUnit, width, widthUnit, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts latitude & longitude as input and Returns travel distances and times for multiple origins to multiple destinations by various travel modes.
         * @summary Get Cost Matrix By Location.
         * @param {string} [startPoints] The address to be searched.
         * @param {string} [endPoints] The address to be searched.
         * @param {string} [db] Mode of commute.
         * @param {string} [optimizeBy] Specifies whether routes should be optimized by time or distance.
         * @param {string} [returnDistance] Specifies whether distance needs to be returned in response.
         * @param {string} [destinationSrs] Specifies the desired coordinate system of returned routes.
         * @param {string} [distanceUnit] Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
         * @param {string} [returnTime] Specifies whether time needs to be returned in response.
         * @param {string} [timeUnit] Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
         * @param {string} [majorRoads] Whether to include all roads in routes calculation or just major roads.
         * @param {string} [returnOptimalRoutesOnly] Specifies whether to return only the optimized route for each start and end point combination.
         * @param {string} [historicTrafficTimeBucket] Specifies whether routing calculation uses the historic traffic speeds.
         * @param {string} [useCvr] This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs.
         * @param {string} [looseningBarrierRestrictions] Specifies that barriers will be removed when determining the route.
         * @param {string} [vehicleType] vehicle type.
         * @param {string} [weight] Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [weightUnit] The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton).
         * @param {string} [height] Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [heightUnit] The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [length] Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [lengthUnit] The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {string} [width] Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
         * @param {string} [widthUnit] The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTravelCostMatrixByLocation(startPoints?: string, endPoints?: string, db?: string, optimizeBy?: string, returnDistance?: string, destinationSrs?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, majorRoads?: string, returnOptimalRoutesOnly?: string, historicTrafficTimeBucket?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string, options?: any): AxiosPromise<TravelCostMatrixResponse> {
            return localVarFp.getTravelCostMatrixByLocation(startPoints, endPoints, db, optimizeBy, returnDistance, destinationSrs, distanceUnit, returnTime, timeUnit, majorRoads, returnOptimalRoutesOnly, historicTrafficTimeBucket, useCvr, looseningBarrierRestrictions, vehicleType, weight, weightUnit, height, heightUnit, length, lengthUnit, width, widthUnit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoutingServiceApi - object-oriented interface
 * @export
 * @class RoutingServiceApi
 * @extends {BaseAPI}
 */
export class RoutingServiceApi extends BaseAPI {
    /**
     * Accepts addresses as input and Returns Point-to-Point and Multi-Point travel directions by various travel modes.
     * @summary Gets Route By Address.
     * @param {string} [startAddress] Starting address of the route.
     * @param {string} [endAddress] Ending address of the route.
     * @param {string} [db] Mode of commute.
     * @param {string} [country] Three digit ISO country code.
     * @param {string} [intermediateAddresses] List of intermediate points of the route.
     * @param {string} [returnIntermediatePoints] return intermediate points
     * @param {string} [oip] Specifies whether waypoints need to be optimized.
     * @param {string} [destinationSrs] Specifies the desired coordinate system of the returned route.
     * @param {string} [optimizeBy] Specifies whether the route should be optimized by time or distance.
     * @param {string} [returnDistance] Specifies whether distance needs to be part of direction information in response.
     * @param {string} [distanceUnit] Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param {string} [returnTime] Specifies whether time needs to be part of direction information in response.
     * @param {string} [timeUnit] Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond)
     * @param {string} [language] Specifies the language of travel directions.
     * @param {string} [directionsStyle] Specifies whether route directions text is to be returned in the response and in what detail (Normal or Terse).
     * @param {string} [segmentGeometryStyle] Specifies whether the route geometry is to be returned in the response and in what detail (End or All).
     * @param {string} [primaryNameOnly] If true then only the primary street name is returned otherwise all the names for a street.
     * @param {string} [majorRoads] Whether to include all roads in route calculation or just major roads.
     * @param {string} [historicTrafficTimeBucket] Specifies whether routing calculation uses the historic traffic speeds.
     * @param {string} [returnDirectionGeometry] Whether to include geometry associated with each route instruction in response.
     * @param {string} [useCvr] This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs.
     * @param {string} [looseningBarrierRestrictions] Specifies that barriers will be removed when determining the route.
     * @param {string} [vehicleType] vehicle type.
     * @param {string} [weight] Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param {string} [weightUnit] The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton).
     * @param {string} [height] Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param {string} [heightUnit] The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
     * @param {string} [length] Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param {string} [lengthUnit] The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
     * @param {string} [width] Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param {string} [widthUnit] The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingServiceApi
     */
    public getRouteByAddress(startAddress?: string, endAddress?: string, db?: string, country?: string, intermediateAddresses?: string, returnIntermediatePoints?: string, oip?: string, destinationSrs?: string, optimizeBy?: string, returnDistance?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, language?: string, directionsStyle?: string, segmentGeometryStyle?: string, primaryNameOnly?: string, majorRoads?: string, historicTrafficTimeBucket?: string, returnDirectionGeometry?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string, options?: AxiosRequestConfig) {
        return RoutingServiceApiFp(this.oAuthCred,this.configuration).getRouteByAddress(startAddress, endAddress, db, country, intermediateAddresses, returnIntermediatePoints, oip, destinationSrs, optimizeBy, returnDistance, distanceUnit, returnTime, timeUnit, language, directionsStyle, segmentGeometryStyle, primaryNameOnly, majorRoads, historicTrafficTimeBucket, returnDirectionGeometry, useCvr, looseningBarrierRestrictions, vehicleType, weight, weightUnit, height, heightUnit, length, lengthUnit, width, widthUnit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts latitude & longitude as input and Returns Point-to-Point and Multi-Point travel directions by various travel modes.
     * @summary Gets Route By Location.
     * @param {string} [startPoint] Start Point in \&#39;Lat,Long,coordsys\&#39; format.
     * @param {string} [endPoint] End Point in \&#39;Lat,Long,coordsys\&#39; format.
     * @param {string} [db] Mode of commute.
     * @param {string} [intermediatePoints] List of intermediate points of the route.
     * @param {string} [returnIntermediatePoints] returnIntermediatePoints route.
     * @param {string} [oip] Specifies whether waypoints need to be optimized.
     * @param {string} [destinationSrs] Specifies the desired coordinate system of the returned route.
     * @param {string} [optimizeBy] Specifies whether the route should be optimized by time or distance.
     * @param {string} [returnDistance] Specifies whether distance needs to be part of direction information in response.
     * @param {string} [distanceUnit] Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param {string} [returnTime] Specifies whether time needs to be part of direction information in response.
     * @param {string} [timeUnit] Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond)
     * @param {string} [language] Specifies the language of travel directions.
     * @param {string} [directionsStyle] Specifies whether route directions text is to be returned in the response and in what detail (Normal or Terse).
     * @param {string} [segmentGeometryStyle] Specifies whether the route geometry is to be returned in the response and in what detail (End or All).
     * @param {string} [primaryNameOnly] If true then only the primary street name is returned otherwise all the names for a street.
     * @param {string} [majorRoads] Whether to include all roads in route calculation or just major roads.
     * @param {string} [historicTrafficTimeBucket] Specifies whether routing calculation uses the historic traffic speeds.
     * @param {string} [returnDirectionGeometry] Whether to include geometry associated with each route instruction in response.
     * @param {string} [useCvr] This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs.
     * @param {string} [looseningBarrierRestrictions] Specifies that barriers will be removed when determining the route.
     * @param {string} [vehicleType] vehicle type.
     * @param {string} [weight] Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param {string} [weightUnit] The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton).
     * @param {string} [height] Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param {string} [heightUnit] The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
     * @param {string} [length] Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param {string} [lengthUnit] The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
     * @param {string} [width] Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param {string} [widthUnit] The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingServiceApi
     */
    public getRouteByLocation(startPoint?: string, endPoint?: string, db?: string, intermediatePoints?: string, returnIntermediatePoints?: string, oip?: string, destinationSrs?: string, optimizeBy?: string, returnDistance?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, language?: string, directionsStyle?: string, segmentGeometryStyle?: string, primaryNameOnly?: string, majorRoads?: string, historicTrafficTimeBucket?: string, returnDirectionGeometry?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string, options?: AxiosRequestConfig) {
        return RoutingServiceApiFp(this.oAuthCred,this.configuration).getRouteByLocation(startPoint, endPoint, db, intermediatePoints, returnIntermediatePoints, oip, destinationSrs, optimizeBy, returnDistance, distanceUnit, returnTime, timeUnit, language, directionsStyle, segmentGeometryStyle, primaryNameOnly, majorRoads, historicTrafficTimeBucket, returnDirectionGeometry, useCvr, looseningBarrierRestrictions, vehicleType, weight, weightUnit, height, heightUnit, length, lengthUnit, width, widthUnit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts addresses as input and Returns travel distances and times for multiple origins to multiple destinations by various travel modes.
     * @summary Get Cost Matrix By Address.
     * @param {string} [startAddresses] Start locations in text based addresses.
     * @param {string} [endAddresses] End locations in text based addresses.
     * @param {string} [country] 3 Digit ISO country code.
     * @param {string} [db] Mode of commute.
     * @param {string} [optimizeBy] Specifies whether routes should be optimized by time or distance.
     * @param {string} [returnDistance] Specifies whether distance needs to be returned in response.
     * @param {string} [destinationSrs] Specifies the desired coordinate system of returned routes.
     * @param {string} [distanceUnit] Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param {string} [returnTime] Specifies whether time needs to be returned in response.
     * @param {string} [timeUnit] Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
     * @param {string} [majorRoads] Whether to include all roads in routes calculation or just major roads.
     * @param {string} [returnOptimalRoutesOnly] Specifies whether to return only the optimized route for each start and end point combination.
     * @param {string} [historicTrafficTimeBucket] Specifies whether routing calculation uses the historic traffic speeds.
     * @param {string} [useCvr] This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs.
     * @param {string} [looseningBarrierRestrictions] Specifies that barriers will be removed when determining the route.
     * @param {string} [vehicleType] vehicle type.
     * @param {string} [weight] Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param {string} [weightUnit] The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton).
     * @param {string} [height] Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param {string} [heightUnit] The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
     * @param {string} [length] Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param {string} [lengthUnit] The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
     * @param {string} [width] Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param {string} [widthUnit] The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingServiceApi
     */
    public getTravelCostMatrixByAddress(startAddresses?: string, endAddresses?: string, country?: string, db?: string, optimizeBy?: string, returnDistance?: string, destinationSrs?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, majorRoads?: string, returnOptimalRoutesOnly?: string, historicTrafficTimeBucket?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string, options?: AxiosRequestConfig) {
        return RoutingServiceApiFp(this.oAuthCred,this.configuration).getTravelCostMatrixByAddress(startAddresses, endAddresses, country, db, optimizeBy, returnDistance, destinationSrs, distanceUnit, returnTime, timeUnit, majorRoads, returnOptimalRoutesOnly, historicTrafficTimeBucket, useCvr, looseningBarrierRestrictions, vehicleType, weight, weightUnit, height, heightUnit, length, lengthUnit, width, widthUnit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts latitude & longitude as input and Returns travel distances and times for multiple origins to multiple destinations by various travel modes.
     * @summary Get Cost Matrix By Location.
     * @param {string} [startPoints] The address to be searched.
     * @param {string} [endPoints] The address to be searched.
     * @param {string} [db] Mode of commute.
     * @param {string} [optimizeBy] Specifies whether routes should be optimized by time or distance.
     * @param {string} [returnDistance] Specifies whether distance needs to be returned in response.
     * @param {string} [destinationSrs] Specifies the desired coordinate system of returned routes.
     * @param {string} [distanceUnit] Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param {string} [returnTime] Specifies whether time needs to be returned in response.
     * @param {string} [timeUnit] Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
     * @param {string} [majorRoads] Whether to include all roads in routes calculation or just major roads.
     * @param {string} [returnOptimalRoutesOnly] Specifies whether to return only the optimized route for each start and end point combination.
     * @param {string} [historicTrafficTimeBucket] Specifies whether routing calculation uses the historic traffic speeds.
     * @param {string} [useCvr] This parameter will enable/disable CVR (Commercial Vehicle Restrictions) capability in our APIs.
     * @param {string} [looseningBarrierRestrictions] Specifies that barriers will be removed when determining the route.
     * @param {string} [vehicleType] vehicle type.
     * @param {string} [weight] Specifies the maximum weight of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param {string} [weightUnit] The unit of weight eg. kg(kilogram), lb(pound), mt(metric ton), t(ton).
     * @param {string} [height] Specifies the maximum height of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param {string} [heightUnit] The unit of height e.g m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
     * @param {string} [length] Specifies the maximum length of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param {string} [lengthUnit] The unit of length eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
     * @param {string} [width] Specifies the maximum width of a vehicle. Any vehicles over this value will be restricted when determining the route.
     * @param {string} [widthUnit] The unit of width eg. m(meter), km(kilometer), yd(yard), ft(foot), mi(mile).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingServiceApi
     */
    public getTravelCostMatrixByLocation(startPoints?: string, endPoints?: string, db?: string, optimizeBy?: string, returnDistance?: string, destinationSrs?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, majorRoads?: string, returnOptimalRoutesOnly?: string, historicTrafficTimeBucket?: string, useCvr?: string, looseningBarrierRestrictions?: string, vehicleType?: string, weight?: string, weightUnit?: string, height?: string, heightUnit?: string, length?: string, lengthUnit?: string, width?: string, widthUnit?: string, options?: AxiosRequestConfig) {
        return RoutingServiceApiFp(this.oAuthCred,this.configuration).getTravelCostMatrixByLocation(startPoints, endPoints, db, optimizeBy, returnDistance, destinationSrs, distanceUnit, returnTime, timeUnit, majorRoads, returnOptimalRoutesOnly, historicTrafficTimeBucket, useCvr, looseningBarrierRestrictions, vehicleType, weight, weightUnit, height, heightUnit, length, lengthUnit, width, widthUnit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchoolsServiceApi - axios parameter creator
 * @export
 */
export const SchoolsServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * Search Nearby Schools by Address
         * @summary Search Nearby Schools by Address
         * @param {string} address free form address text
         * @param {string} [edLevel] Single digit code for education level applicable values are P -&gt; primary, M -&gt; Middle, H -&gt; High, O -&gt; Mixed Grades for public school type andE -&gt; Elementary , S -&gt; Secondary , O -&gt; Others mixed grades for private schools 
         * @param {string} [schoolType] Single digit code for schoolTypes applicable values are PRI and PUB
         * @param {string} [schoolSubType] Single digit code for schoolSubType Applicable values are C, M, A, R, I, L, P, V, U, S (i.e. Charter, Magnet, Alternative, Regular, Indian, Military, Reportable Program, Vocational, Unknown, Special Education)
         * @param {string} [gender] Single digit code for gender Applicable values are C, F, M (Coed, All Females, All Males) Applicable for Private Schools Only
         * @param {string} [assignedSchoolsOnly] Single digit code for assignedSchoolOnly applicable values are  Y/N 
         * @param {string} [districtSchoolsOnly] Single digit code for districtSchoolOnly applicable values are Y/N 
         * @param {string} [searchRadius] Search Radius within which schools are searched
         * @param {string} [searchRadiusUnit] Search Radius unit applicable values are feet,kilometers,miles,meters
         * @param {string} [travelTime] Travel Time based on travelMode within which schools are searched.
         * @param {string} [travelTimeUnit] Travel Time unit applicable values are minutes,hours,seconds,milliseconds 
         * @param {string} [travelDistance] Travel Distance based on travelMode within which schools are searched.
         * @param {string} [travelDistanceUnit] Travel distanceUnit applicable values are feet,kilometers,miles,meters
         * @param {string} [travelMode] Travel mode Required when travelDistance or travelTime is specified. Accepted values are walking,driving
         * @param {string} [maxCandidates] Max result to search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsByAddress: async (address: string, edLevel?: string, schoolType?: string, schoolSubType?: string, gender?: string, assignedSchoolsOnly?: string, districtSchoolsOnly?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, maxCandidates?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getSchoolsByAddress', 'address', address)
            const localVarPath = `/schools/v1/school/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (edLevel !== undefined) {
                localVarQueryParameter['edLevel'] = edLevel;
            }

            if (schoolType !== undefined) {
                localVarQueryParameter['schoolType'] = schoolType;
            }

            if (schoolSubType !== undefined) {
                localVarQueryParameter['schoolSubType'] = schoolSubType;
            }

            if (gender !== undefined) {
                localVarQueryParameter['gender'] = gender;
            }

            if (assignedSchoolsOnly !== undefined) {
                localVarQueryParameter['assignedSchoolsOnly'] = assignedSchoolsOnly;
            }

            if (districtSchoolsOnly !== undefined) {
                localVarQueryParameter['districtSchoolsOnly'] = districtSchoolsOnly;
            }

            if (searchRadius !== undefined) {
                localVarQueryParameter['searchRadius'] = searchRadius;
            }

            if (searchRadiusUnit !== undefined) {
                localVarQueryParameter['searchRadiusUnit'] = searchRadiusUnit;
            }

            if (travelTime !== undefined) {
                localVarQueryParameter['travelTime'] = travelTime;
            }

            if (travelTimeUnit !== undefined) {
                localVarQueryParameter['travelTimeUnit'] = travelTimeUnit;
            }

            if (travelDistance !== undefined) {
                localVarQueryParameter['travelDistance'] = travelDistance;
            }

            if (travelDistanceUnit !== undefined) {
                localVarQueryParameter['travelDistanceUnit'] = travelDistanceUnit;
            }

            if (travelMode !== undefined) {
                localVarQueryParameter['travelMode'] = travelMode;
            }

            if (maxCandidates !== undefined) {
                localVarQueryParameter['maxCandidates'] = maxCandidates;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchoolsServiceApi - functional programming interface
 * @export
 */
export const SchoolsServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = SchoolsServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * Search Nearby Schools by Address
         * @summary Search Nearby Schools by Address
         * @param {string} address free form address text
         * @param {string} [edLevel] Single digit code for education level applicable values are P -&gt; primary, M -&gt; Middle, H -&gt; High, O -&gt; Mixed Grades for public school type andE -&gt; Elementary , S -&gt; Secondary , O -&gt; Others mixed grades for private schools 
         * @param {string} [schoolType] Single digit code for schoolTypes applicable values are PRI and PUB
         * @param {string} [schoolSubType] Single digit code for schoolSubType Applicable values are C, M, A, R, I, L, P, V, U, S (i.e. Charter, Magnet, Alternative, Regular, Indian, Military, Reportable Program, Vocational, Unknown, Special Education)
         * @param {string} [gender] Single digit code for gender Applicable values are C, F, M (Coed, All Females, All Males) Applicable for Private Schools Only
         * @param {string} [assignedSchoolsOnly] Single digit code for assignedSchoolOnly applicable values are  Y/N 
         * @param {string} [districtSchoolsOnly] Single digit code for districtSchoolOnly applicable values are Y/N 
         * @param {string} [searchRadius] Search Radius within which schools are searched
         * @param {string} [searchRadiusUnit] Search Radius unit applicable values are feet,kilometers,miles,meters
         * @param {string} [travelTime] Travel Time based on travelMode within which schools are searched.
         * @param {string} [travelTimeUnit] Travel Time unit applicable values are minutes,hours,seconds,milliseconds 
         * @param {string} [travelDistance] Travel Distance based on travelMode within which schools are searched.
         * @param {string} [travelDistanceUnit] Travel distanceUnit applicable values are feet,kilometers,miles,meters
         * @param {string} [travelMode] Travel mode Required when travelDistance or travelTime is specified. Accepted values are walking,driving
         * @param {string} [maxCandidates] Max result to search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchoolsByAddress(address: string, edLevel?: string, schoolType?: string, schoolSubType?: string, gender?: string, assignedSchoolsOnly?: string, districtSchoolsOnly?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, maxCandidates?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolsNearByResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchoolsByAddress(address, edLevel, schoolType, schoolSubType, gender, assignedSchoolsOnly, districtSchoolsOnly, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, maxCandidates, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchoolsServiceApi - factory interface
 * @export
 */
export const SchoolsServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchoolsServiceApiFp(oAuth,configuration)
    return {
        /**
         * Search Nearby Schools by Address
         * @summary Search Nearby Schools by Address
         * @param {string} address free form address text
         * @param {string} [edLevel] Single digit code for education level applicable values are P -&gt; primary, M -&gt; Middle, H -&gt; High, O -&gt; Mixed Grades for public school type andE -&gt; Elementary , S -&gt; Secondary , O -&gt; Others mixed grades for private schools 
         * @param {string} [schoolType] Single digit code for schoolTypes applicable values are PRI and PUB
         * @param {string} [schoolSubType] Single digit code for schoolSubType Applicable values are C, M, A, R, I, L, P, V, U, S (i.e. Charter, Magnet, Alternative, Regular, Indian, Military, Reportable Program, Vocational, Unknown, Special Education)
         * @param {string} [gender] Single digit code for gender Applicable values are C, F, M (Coed, All Females, All Males) Applicable for Private Schools Only
         * @param {string} [assignedSchoolsOnly] Single digit code for assignedSchoolOnly applicable values are  Y/N 
         * @param {string} [districtSchoolsOnly] Single digit code for districtSchoolOnly applicable values are Y/N 
         * @param {string} [searchRadius] Search Radius within which schools are searched
         * @param {string} [searchRadiusUnit] Search Radius unit applicable values are feet,kilometers,miles,meters
         * @param {string} [travelTime] Travel Time based on travelMode within which schools are searched.
         * @param {string} [travelTimeUnit] Travel Time unit applicable values are minutes,hours,seconds,milliseconds 
         * @param {string} [travelDistance] Travel Distance based on travelMode within which schools are searched.
         * @param {string} [travelDistanceUnit] Travel distanceUnit applicable values are feet,kilometers,miles,meters
         * @param {string} [travelMode] Travel mode Required when travelDistance or travelTime is specified. Accepted values are walking,driving
         * @param {string} [maxCandidates] Max result to search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchoolsByAddress(address: string, edLevel?: string, schoolType?: string, schoolSubType?: string, gender?: string, assignedSchoolsOnly?: string, districtSchoolsOnly?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, maxCandidates?: string, options?: any): AxiosPromise<SchoolsNearByResponse> {
            return localVarFp.getSchoolsByAddress(address, edLevel, schoolType, schoolSubType, gender, assignedSchoolsOnly, districtSchoolsOnly, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, maxCandidates, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchoolsServiceApi - object-oriented interface
 * @export
 * @class SchoolsServiceApi
 * @extends {BaseAPI}
 */
export class SchoolsServiceApi extends BaseAPI {
    /**
     * Search Nearby Schools by Address
     * @summary Search Nearby Schools by Address
     * @param {string} address free form address text
     * @param {string} [edLevel] Single digit code for education level applicable values are P -&gt; primary, M -&gt; Middle, H -&gt; High, O -&gt; Mixed Grades for public school type andE -&gt; Elementary , S -&gt; Secondary , O -&gt; Others mixed grades for private schools 
     * @param {string} [schoolType] Single digit code for schoolTypes applicable values are PRI and PUB
     * @param {string} [schoolSubType] Single digit code for schoolSubType Applicable values are C, M, A, R, I, L, P, V, U, S (i.e. Charter, Magnet, Alternative, Regular, Indian, Military, Reportable Program, Vocational, Unknown, Special Education)
     * @param {string} [gender] Single digit code for gender Applicable values are C, F, M (Coed, All Females, All Males) Applicable for Private Schools Only
     * @param {string} [assignedSchoolsOnly] Single digit code for assignedSchoolOnly applicable values are  Y/N 
     * @param {string} [districtSchoolsOnly] Single digit code for districtSchoolOnly applicable values are Y/N 
     * @param {string} [searchRadius] Search Radius within which schools are searched
     * @param {string} [searchRadiusUnit] Search Radius unit applicable values are feet,kilometers,miles,meters
     * @param {string} [travelTime] Travel Time based on travelMode within which schools are searched.
     * @param {string} [travelTimeUnit] Travel Time unit applicable values are minutes,hours,seconds,milliseconds 
     * @param {string} [travelDistance] Travel Distance based on travelMode within which schools are searched.
     * @param {string} [travelDistanceUnit] Travel distanceUnit applicable values are feet,kilometers,miles,meters
     * @param {string} [travelMode] Travel mode Required when travelDistance or travelTime is specified. Accepted values are walking,driving
     * @param {string} [maxCandidates] Max result to search 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolsServiceApi
     */
    public getSchoolsByAddress(address: string, edLevel?: string, schoolType?: string, schoolSubType?: string, gender?: string, assignedSchoolsOnly?: string, districtSchoolsOnly?: string, searchRadius?: string, searchRadiusUnit?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, travelMode?: string, maxCandidates?: string, options?: AxiosRequestConfig) {
        return SchoolsServiceApiFp(this.oAuthCred,this.configuration).getSchoolsByAddress(address, edLevel, schoolType, schoolSubType, gender, assignedSchoolsOnly, districtSchoolsOnly, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, maxCandidates, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StreetsServiceApi - axios parameter creator
 * @export
 */
export const StreetsServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * This service accepts an address as input and returns the Nearest Intersection.
         * @summary Nearest Intesection By Address.
         * @param {string} [address] Address
         * @param {string} [roadClass] Filters roads with specified class, allowed values are (Major, Secondary, Other and All), default is All
         * @param {string} [driveTime] Returns Intersection in specified drive time
         * @param {string} [driveTimeUnit] Drive time unit, allowed values are (hours, minutes, seconds and milliseconds), default is minutes
         * @param {string} [searchRadius] Search radius within which user wants to search, default is 50 miles
         * @param {string} [searchRadiusUnit] Search radius unit, allowed values are (feet, meter, kilometers and miles)
         * @param {string} [historicSpeed] Traffic flow in peak time, allowed values are (AMPEAK,PMPEAK,OFFPEAK,NIGHT)
         * @param {string} [maxCandidates] max candidates to be returned default is 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntersectionByAddress: async (address?: string, roadClass?: string, driveTime?: string, driveTimeUnit?: string, searchRadius?: string, searchRadiusUnit?: string, historicSpeed?: string, maxCandidates?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/streets/v1/intersection/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (roadClass !== undefined) {
                localVarQueryParameter['roadClass'] = roadClass;
            }

            if (driveTime !== undefined) {
                localVarQueryParameter['driveTime'] = driveTime;
            }

            if (driveTimeUnit !== undefined) {
                localVarQueryParameter['driveTimeUnit'] = driveTimeUnit;
            }

            if (searchRadius !== undefined) {
                localVarQueryParameter['searchRadius'] = searchRadius;
            }

            if (searchRadiusUnit !== undefined) {
                localVarQueryParameter['searchRadiusUnit'] = searchRadiusUnit;
            }

            if (historicSpeed !== undefined) {
                localVarQueryParameter['historicSpeed'] = historicSpeed;
            }

            if (maxCandidates !== undefined) {
                localVarQueryParameter['maxCandidates'] = maxCandidates;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service accepts latitude/longitude as input and returns the Nearest Intersection.
         * @summary Nearest Intesection By Location.
         * @param {string} [longitude] Longitude of the location.
         * @param {string} [latitude] Latitude of the location.
         * @param {string} [roadClass] Filters roads with specified class, allowed values are (Major, Secondary, Other and All), default is All
         * @param {string} [driveTime] Returns Intersection in specified drive time
         * @param {string} [driveTimeUnit] Drive time unit, allowed values are (hours, minutes, seconds and milliseconds), default is minutes
         * @param {string} [searchRadius] Search radius within which user wants to search, default is 50 miles
         * @param {string} [searchRadiusUnit] Search radius unit, allowed values are (feet, meter, kilometers and miles)
         * @param {string} [historicSpeed] Traffic flow in peak time, allowed values are (AMPEAK,PMPEAK,OFFPEAK,NIGHT)
         * @param {string} [maxCandidates] max candidates to be returned default is 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntersectionByLocation: async (longitude?: string, latitude?: string, roadClass?: string, driveTime?: string, driveTimeUnit?: string, searchRadius?: string, searchRadiusUnit?: string, historicSpeed?: string, maxCandidates?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/streets/v1/intersection/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (roadClass !== undefined) {
                localVarQueryParameter['roadClass'] = roadClass;
            }

            if (driveTime !== undefined) {
                localVarQueryParameter['driveTime'] = driveTime;
            }

            if (driveTimeUnit !== undefined) {
                localVarQueryParameter['driveTimeUnit'] = driveTimeUnit;
            }

            if (searchRadius !== undefined) {
                localVarQueryParameter['searchRadius'] = searchRadius;
            }

            if (searchRadiusUnit !== undefined) {
                localVarQueryParameter['searchRadiusUnit'] = searchRadiusUnit;
            }

            if (historicSpeed !== undefined) {
                localVarQueryParameter['historicSpeed'] = historicSpeed;
            }

            if (maxCandidates !== undefined) {
                localVarQueryParameter['maxCandidates'] = maxCandidates;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service accepts point coordinates of a path as input and returns the posted speed limit of the road segment on which this path will snap.
         * @summary Nearest Speedlimit.
         * @param {string} [path] Accepts multiple points which will be snapped to the nearest road segment. Longitude and Latitude will be comma separated (longitude,latitude) and Point Coordinates will be separated by semi-colon(;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNearestSpeedLimit: async (path?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/streets/v1/speedlimit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StreetsServiceApi - functional programming interface
 * @export
 */
export const StreetsServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = StreetsServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * This service accepts an address as input and returns the Nearest Intersection.
         * @summary Nearest Intesection By Address.
         * @param {string} [address] Address
         * @param {string} [roadClass] Filters roads with specified class, allowed values are (Major, Secondary, Other and All), default is All
         * @param {string} [driveTime] Returns Intersection in specified drive time
         * @param {string} [driveTimeUnit] Drive time unit, allowed values are (hours, minutes, seconds and milliseconds), default is minutes
         * @param {string} [searchRadius] Search radius within which user wants to search, default is 50 miles
         * @param {string} [searchRadiusUnit] Search radius unit, allowed values are (feet, meter, kilometers and miles)
         * @param {string} [historicSpeed] Traffic flow in peak time, allowed values are (AMPEAK,PMPEAK,OFFPEAK,NIGHT)
         * @param {string} [maxCandidates] max candidates to be returned default is 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntersectionByAddress(address?: string, roadClass?: string, driveTime?: string, driveTimeUnit?: string, searchRadius?: string, searchRadiusUnit?: string, historicSpeed?: string, maxCandidates?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntersectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntersectionByAddress(address, roadClass, driveTime, driveTimeUnit, searchRadius, searchRadiusUnit, historicSpeed, maxCandidates, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This service accepts latitude/longitude as input and returns the Nearest Intersection.
         * @summary Nearest Intesection By Location.
         * @param {string} [longitude] Longitude of the location.
         * @param {string} [latitude] Latitude of the location.
         * @param {string} [roadClass] Filters roads with specified class, allowed values are (Major, Secondary, Other and All), default is All
         * @param {string} [driveTime] Returns Intersection in specified drive time
         * @param {string} [driveTimeUnit] Drive time unit, allowed values are (hours, minutes, seconds and milliseconds), default is minutes
         * @param {string} [searchRadius] Search radius within which user wants to search, default is 50 miles
         * @param {string} [searchRadiusUnit] Search radius unit, allowed values are (feet, meter, kilometers and miles)
         * @param {string} [historicSpeed] Traffic flow in peak time, allowed values are (AMPEAK,PMPEAK,OFFPEAK,NIGHT)
         * @param {string} [maxCandidates] max candidates to be returned default is 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntersectionByLocation(longitude?: string, latitude?: string, roadClass?: string, driveTime?: string, driveTimeUnit?: string, searchRadius?: string, searchRadiusUnit?: string, historicSpeed?: string, maxCandidates?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntersectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntersectionByLocation(longitude, latitude, roadClass, driveTime, driveTimeUnit, searchRadius, searchRadiusUnit, historicSpeed, maxCandidates, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This service accepts point coordinates of a path as input and returns the posted speed limit of the road segment on which this path will snap.
         * @summary Nearest Speedlimit.
         * @param {string} [path] Accepts multiple points which will be snapped to the nearest road segment. Longitude and Latitude will be comma separated (longitude,latitude) and Point Coordinates will be separated by semi-colon(;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNearestSpeedLimit(path?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpeedLimit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNearestSpeedLimit(path, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StreetsServiceApi - factory interface
 * @export
 */
export const StreetsServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StreetsServiceApiFp(oAuth,configuration)
    return {
        /**
         * This service accepts an address as input and returns the Nearest Intersection.
         * @summary Nearest Intesection By Address.
         * @param {string} [address] Address
         * @param {string} [roadClass] Filters roads with specified class, allowed values are (Major, Secondary, Other and All), default is All
         * @param {string} [driveTime] Returns Intersection in specified drive time
         * @param {string} [driveTimeUnit] Drive time unit, allowed values are (hours, minutes, seconds and milliseconds), default is minutes
         * @param {string} [searchRadius] Search radius within which user wants to search, default is 50 miles
         * @param {string} [searchRadiusUnit] Search radius unit, allowed values are (feet, meter, kilometers and miles)
         * @param {string} [historicSpeed] Traffic flow in peak time, allowed values are (AMPEAK,PMPEAK,OFFPEAK,NIGHT)
         * @param {string} [maxCandidates] max candidates to be returned default is 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntersectionByAddress(address?: string, roadClass?: string, driveTime?: string, driveTimeUnit?: string, searchRadius?: string, searchRadiusUnit?: string, historicSpeed?: string, maxCandidates?: string, options?: any): AxiosPromise<IntersectionResponse> {
            return localVarFp.getIntersectionByAddress(address, roadClass, driveTime, driveTimeUnit, searchRadius, searchRadiusUnit, historicSpeed, maxCandidates, options).then((request) => request(axios, basePath));
        },
        /**
         * This service accepts latitude/longitude as input and returns the Nearest Intersection.
         * @summary Nearest Intesection By Location.
         * @param {string} [longitude] Longitude of the location.
         * @param {string} [latitude] Latitude of the location.
         * @param {string} [roadClass] Filters roads with specified class, allowed values are (Major, Secondary, Other and All), default is All
         * @param {string} [driveTime] Returns Intersection in specified drive time
         * @param {string} [driveTimeUnit] Drive time unit, allowed values are (hours, minutes, seconds and milliseconds), default is minutes
         * @param {string} [searchRadius] Search radius within which user wants to search, default is 50 miles
         * @param {string} [searchRadiusUnit] Search radius unit, allowed values are (feet, meter, kilometers and miles)
         * @param {string} [historicSpeed] Traffic flow in peak time, allowed values are (AMPEAK,PMPEAK,OFFPEAK,NIGHT)
         * @param {string} [maxCandidates] max candidates to be returned default is 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntersectionByLocation(longitude?: string, latitude?: string, roadClass?: string, driveTime?: string, driveTimeUnit?: string, searchRadius?: string, searchRadiusUnit?: string, historicSpeed?: string, maxCandidates?: string, options?: any): AxiosPromise<IntersectionResponse> {
            return localVarFp.getIntersectionByLocation(longitude, latitude, roadClass, driveTime, driveTimeUnit, searchRadius, searchRadiusUnit, historicSpeed, maxCandidates, options).then((request) => request(axios, basePath));
        },
        /**
         * This service accepts point coordinates of a path as input and returns the posted speed limit of the road segment on which this path will snap.
         * @summary Nearest Speedlimit.
         * @param {string} [path] Accepts multiple points which will be snapped to the nearest road segment. Longitude and Latitude will be comma separated (longitude,latitude) and Point Coordinates will be separated by semi-colon(;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNearestSpeedLimit(path?: string, options?: any): AxiosPromise<SpeedLimit> {
            return localVarFp.getNearestSpeedLimit(path, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StreetsServiceApi - object-oriented interface
 * @export
 * @class StreetsServiceApi
 * @extends {BaseAPI}
 */
export class StreetsServiceApi extends BaseAPI {
    /**
     * This service accepts an address as input and returns the Nearest Intersection.
     * @summary Nearest Intesection By Address.
     * @param {string} [address] Address
     * @param {string} [roadClass] Filters roads with specified class, allowed values are (Major, Secondary, Other and All), default is All
     * @param {string} [driveTime] Returns Intersection in specified drive time
     * @param {string} [driveTimeUnit] Drive time unit, allowed values are (hours, minutes, seconds and milliseconds), default is minutes
     * @param {string} [searchRadius] Search radius within which user wants to search, default is 50 miles
     * @param {string} [searchRadiusUnit] Search radius unit, allowed values are (feet, meter, kilometers and miles)
     * @param {string} [historicSpeed] Traffic flow in peak time, allowed values are (AMPEAK,PMPEAK,OFFPEAK,NIGHT)
     * @param {string} [maxCandidates] max candidates to be returned default is 1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreetsServiceApi
     */
    public getIntersectionByAddress(address?: string, roadClass?: string, driveTime?: string, driveTimeUnit?: string, searchRadius?: string, searchRadiusUnit?: string, historicSpeed?: string, maxCandidates?: string, options?: AxiosRequestConfig) {
        return StreetsServiceApiFp(this.oAuthCred,this.configuration).getIntersectionByAddress(address, roadClass, driveTime, driveTimeUnit, searchRadius, searchRadiusUnit, historicSpeed, maxCandidates, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service accepts latitude/longitude as input and returns the Nearest Intersection.
     * @summary Nearest Intesection By Location.
     * @param {string} [longitude] Longitude of the location.
     * @param {string} [latitude] Latitude of the location.
     * @param {string} [roadClass] Filters roads with specified class, allowed values are (Major, Secondary, Other and All), default is All
     * @param {string} [driveTime] Returns Intersection in specified drive time
     * @param {string} [driveTimeUnit] Drive time unit, allowed values are (hours, minutes, seconds and milliseconds), default is minutes
     * @param {string} [searchRadius] Search radius within which user wants to search, default is 50 miles
     * @param {string} [searchRadiusUnit] Search radius unit, allowed values are (feet, meter, kilometers and miles)
     * @param {string} [historicSpeed] Traffic flow in peak time, allowed values are (AMPEAK,PMPEAK,OFFPEAK,NIGHT)
     * @param {string} [maxCandidates] max candidates to be returned default is 1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreetsServiceApi
     */
    public getIntersectionByLocation(longitude?: string, latitude?: string, roadClass?: string, driveTime?: string, driveTimeUnit?: string, searchRadius?: string, searchRadiusUnit?: string, historicSpeed?: string, maxCandidates?: string, options?: AxiosRequestConfig) {
        return StreetsServiceApiFp(this.oAuthCred,this.configuration).getIntersectionByLocation(longitude, latitude, roadClass, driveTime, driveTimeUnit, searchRadius, searchRadiusUnit, historicSpeed, maxCandidates, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service accepts point coordinates of a path as input and returns the posted speed limit of the road segment on which this path will snap.
     * @summary Nearest Speedlimit.
     * @param {string} [path] Accepts multiple points which will be snapped to the nearest road segment. Longitude and Latitude will be comma separated (longitude,latitude) and Point Coordinates will be separated by semi-colon(;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreetsServiceApi
     */
    public getNearestSpeedLimit(path?: string, options?: AxiosRequestConfig) {
        return StreetsServiceApiFp(this.oAuthCred,this.configuration).getNearestSpeedLimit(path, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TelecommInfoServiceApi - axios parameter creator
 * @export
 */
export const TelecommInfoServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * Accepts addresses as input and returns Incumbent Local Exchange Carrier (ILEC) doing-business-as names.
         * @summary Rate Center By Address.
         * @param {string} [address] The address to be searched
         * @param {string} [country] 3 letter ISO code of the country to be searched. Allowed values USA,CAN
         * @param {string} [areaCodeInfo] Specifies whether area code information will be part of response.Allowed values True,False.
         * @param {string} [level] Level (basic/detail).Allowed values detail,basic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateCenterByAddress: async (address?: string, country?: string, areaCodeInfo?: string, level?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/telecomm/v1/ratecenter/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (areaCodeInfo !== undefined) {
                localVarQueryParameter['areaCodeInfo'] = areaCodeInfo;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts latitude & longitude as input and returns Incumbent Local Exchange Carrier (ILEC) doing-business-as names.
         * @summary Rate Center By Location.
         * @param {string} [longitude] Longitude of the location
         * @param {string} [latitude] Latitude of the location
         * @param {string} [areaCodeInfo] Specifies whether area code information will be part of response.Allowed values True,False.
         * @param {string} [level] Level (basic/detail).Allowed values detail,basic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateCenterByLocation: async (longitude?: string, latitude?: string, areaCodeInfo?: string, level?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/telecomm/v1/ratecenter/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (areaCodeInfo !== undefined) {
                localVarQueryParameter['areaCodeInfo'] = areaCodeInfo;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TelecommInfoServiceApi - functional programming interface
 * @export
 */
export const TelecommInfoServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = TelecommInfoServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * Accepts addresses as input and returns Incumbent Local Exchange Carrier (ILEC) doing-business-as names.
         * @summary Rate Center By Address.
         * @param {string} [address] The address to be searched
         * @param {string} [country] 3 letter ISO code of the country to be searched. Allowed values USA,CAN
         * @param {string} [areaCodeInfo] Specifies whether area code information will be part of response.Allowed values True,False.
         * @param {string} [level] Level (basic/detail).Allowed values detail,basic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRateCenterByAddress(address?: string, country?: string, areaCodeInfo?: string, level?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RateCenterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRateCenterByAddress(address, country, areaCodeInfo, level, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts latitude & longitude as input and returns Incumbent Local Exchange Carrier (ILEC) doing-business-as names.
         * @summary Rate Center By Location.
         * @param {string} [longitude] Longitude of the location
         * @param {string} [latitude] Latitude of the location
         * @param {string} [areaCodeInfo] Specifies whether area code information will be part of response.Allowed values True,False.
         * @param {string} [level] Level (basic/detail).Allowed values detail,basic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRateCenterByLocation(longitude?: string, latitude?: string, areaCodeInfo?: string, level?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RateCenterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRateCenterByLocation(longitude, latitude, areaCodeInfo, level, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TelecommInfoServiceApi - factory interface
 * @export
 */
export const TelecommInfoServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TelecommInfoServiceApiFp(oAuth,configuration)
    return {
        /**
         * Accepts addresses as input and returns Incumbent Local Exchange Carrier (ILEC) doing-business-as names.
         * @summary Rate Center By Address.
         * @param {string} [address] The address to be searched
         * @param {string} [country] 3 letter ISO code of the country to be searched. Allowed values USA,CAN
         * @param {string} [areaCodeInfo] Specifies whether area code information will be part of response.Allowed values True,False.
         * @param {string} [level] Level (basic/detail).Allowed values detail,basic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateCenterByAddress(address?: string, country?: string, areaCodeInfo?: string, level?: string, options?: any): AxiosPromise<RateCenterResponse> {
            return localVarFp.getRateCenterByAddress(address, country, areaCodeInfo, level, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts latitude & longitude as input and returns Incumbent Local Exchange Carrier (ILEC) doing-business-as names.
         * @summary Rate Center By Location.
         * @param {string} [longitude] Longitude of the location
         * @param {string} [latitude] Latitude of the location
         * @param {string} [areaCodeInfo] Specifies whether area code information will be part of response.Allowed values True,False.
         * @param {string} [level] Level (basic/detail).Allowed values detail,basic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateCenterByLocation(longitude?: string, latitude?: string, areaCodeInfo?: string, level?: string, options?: any): AxiosPromise<RateCenterResponse> {
            return localVarFp.getRateCenterByLocation(longitude, latitude, areaCodeInfo, level, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TelecommInfoServiceApi - object-oriented interface
 * @export
 * @class TelecommInfoServiceApi
 * @extends {BaseAPI}
 */
export class TelecommInfoServiceApi extends BaseAPI {
    /**
     * Accepts addresses as input and returns Incumbent Local Exchange Carrier (ILEC) doing-business-as names.
     * @summary Rate Center By Address.
     * @param {string} [address] The address to be searched
     * @param {string} [country] 3 letter ISO code of the country to be searched. Allowed values USA,CAN
     * @param {string} [areaCodeInfo] Specifies whether area code information will be part of response.Allowed values True,False.
     * @param {string} [level] Level (basic/detail).Allowed values detail,basic.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelecommInfoServiceApi
     */
    public getRateCenterByAddress(address?: string, country?: string, areaCodeInfo?: string, level?: string, options?: AxiosRequestConfig) {
        return TelecommInfoServiceApiFp(this.oAuthCred,this.configuration).getRateCenterByAddress(address, country, areaCodeInfo, level, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts latitude & longitude as input and returns Incumbent Local Exchange Carrier (ILEC) doing-business-as names.
     * @summary Rate Center By Location.
     * @param {string} [longitude] Longitude of the location
     * @param {string} [latitude] Latitude of the location
     * @param {string} [areaCodeInfo] Specifies whether area code information will be part of response.Allowed values True,False.
     * @param {string} [level] Level (basic/detail).Allowed values detail,basic.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelecommInfoServiceApi
     */
    public getRateCenterByLocation(longitude?: string, latitude?: string, areaCodeInfo?: string, level?: string, options?: AxiosRequestConfig) {
        return TelecommInfoServiceApiFp(this.oAuthCred,this.configuration).getRateCenterByLocation(longitude, latitude, areaCodeInfo, level, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TimeZoneServiceApi - axios parameter creator
 * @export
 */
export const TimeZoneServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * Identifies and retrieves the local time of any location in the world for a given latitude, longitude and time. The input and retrieved time format is in milliseconds.
         * @summary Timezone Batch by Location.
         * @param {TimezoneLocationRequest} timezoneLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchTimezoneByLocation: async (timezoneLocationRequest: TimezoneLocationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timezoneLocationRequest' is not null or undefined
            assertParamExists('getBatchTimezoneByLocation', 'timezoneLocationRequest', timezoneLocationRequest)
            const localVarPath = `/timezone/v1/timezone/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timezoneLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Identifies and retrieves the local time of any location in the world for a given address and time. The input and retrieved time format is in milliseconds.
         * @summary Timezone By Address.
         * @param {string} timestamp Timestamp in miliseconds.
         * @param {string} address The address to be searched.
         * @param {string} [matchMode] Match modes determine the leniency used to make a match between the input address and the reference data (Default is relaxed)
         * @param {string} [country] Country ISO code (Default is USA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimezoneByAddress: async (timestamp: string, address: string, matchMode?: string, country?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getTimezoneByAddress', 'timestamp', timestamp)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getTimezoneByAddress', 'address', address)
            const localVarPath = `/timezone/v1/timezone/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (matchMode !== undefined) {
                localVarQueryParameter['matchMode'] = matchMode;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Identifies and retrieves the local time of any location in the world for a given address and time. The input and retrieved time format is in milliseconds.
         * @summary Timezone Batch by Address.
         * @param {TimezoneAddressRequest} timezoneAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimezoneByAddressBatch: async (timezoneAddressRequest: TimezoneAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timezoneAddressRequest' is not null or undefined
            assertParamExists('getTimezoneByAddressBatch', 'timezoneAddressRequest', timezoneAddressRequest)
            const localVarPath = `/timezone/v1/timezone/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timezoneAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Identifies and retrieves the local time of any location in the world for a given latitude, longitude and time. The input and retrieved time format is in milliseconds.
         * @summary Timezone By Location.
         * @param {string} timestamp Timestamp in miliseconds.
         * @param {string} longitude Longitude of the location.
         * @param {string} latitude Latitude of the location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimezoneByLocation: async (timestamp: string, longitude: string, latitude: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getTimezoneByLocation', 'timestamp', timestamp)
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('getTimezoneByLocation', 'longitude', longitude)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('getTimezoneByLocation', 'latitude', latitude)
            const localVarPath = `/timezone/v1/timezone/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeZoneServiceApi - functional programming interface
 * @export
 */
export const TimeZoneServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = TimeZoneServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * Identifies and retrieves the local time of any location in the world for a given latitude, longitude and time. The input and retrieved time format is in milliseconds.
         * @summary Timezone Batch by Location.
         * @param {TimezoneLocationRequest} timezoneLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchTimezoneByLocation(timezoneLocationRequest: TimezoneLocationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimezoneResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchTimezoneByLocation(timezoneLocationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Identifies and retrieves the local time of any location in the world for a given address and time. The input and retrieved time format is in milliseconds.
         * @summary Timezone By Address.
         * @param {string} timestamp Timestamp in miliseconds.
         * @param {string} address The address to be searched.
         * @param {string} [matchMode] Match modes determine the leniency used to make a match between the input address and the reference data (Default is relaxed)
         * @param {string} [country] Country ISO code (Default is USA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimezoneByAddress(timestamp: string, address: string, matchMode?: string, country?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimezoneResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimezoneByAddress(timestamp, address, matchMode, country, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Identifies and retrieves the local time of any location in the world for a given address and time. The input and retrieved time format is in milliseconds.
         * @summary Timezone Batch by Address.
         * @param {TimezoneAddressRequest} timezoneAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimezoneByAddressBatch(timezoneAddressRequest: TimezoneAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimezoneResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimezoneByAddressBatch(timezoneAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Identifies and retrieves the local time of any location in the world for a given latitude, longitude and time. The input and retrieved time format is in milliseconds.
         * @summary Timezone By Location.
         * @param {string} timestamp Timestamp in miliseconds.
         * @param {string} longitude Longitude of the location.
         * @param {string} latitude Latitude of the location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimezoneByLocation(timestamp: string, longitude: string, latitude: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimezoneResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimezoneByLocation(timestamp, longitude, latitude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TimeZoneServiceApi - factory interface
 * @export
 */
export const TimeZoneServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeZoneServiceApiFp(oAuth,configuration)
    return {
        /**
         * Identifies and retrieves the local time of any location in the world for a given latitude, longitude and time. The input and retrieved time format is in milliseconds.
         * @summary Timezone Batch by Location.
         * @param {TimezoneLocationRequest} timezoneLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchTimezoneByLocation(timezoneLocationRequest: TimezoneLocationRequest, options?: any): AxiosPromise<TimezoneResponseList> {
            return localVarFp.getBatchTimezoneByLocation(timezoneLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Identifies and retrieves the local time of any location in the world for a given address and time. The input and retrieved time format is in milliseconds.
         * @summary Timezone By Address.
         * @param {string} timestamp Timestamp in miliseconds.
         * @param {string} address The address to be searched.
         * @param {string} [matchMode] Match modes determine the leniency used to make a match between the input address and the reference data (Default is relaxed)
         * @param {string} [country] Country ISO code (Default is USA)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimezoneByAddress(timestamp: string, address: string, matchMode?: string, country?: string, options?: any): AxiosPromise<TimezoneResponse> {
            return localVarFp.getTimezoneByAddress(timestamp, address, matchMode, country, options).then((request) => request(axios, basePath));
        },
        /**
         * Identifies and retrieves the local time of any location in the world for a given address and time. The input and retrieved time format is in milliseconds.
         * @summary Timezone Batch by Address.
         * @param {TimezoneAddressRequest} timezoneAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimezoneByAddressBatch(timezoneAddressRequest: TimezoneAddressRequest, options?: any): AxiosPromise<TimezoneResponseList> {
            return localVarFp.getTimezoneByAddressBatch(timezoneAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Identifies and retrieves the local time of any location in the world for a given latitude, longitude and time. The input and retrieved time format is in milliseconds.
         * @summary Timezone By Location.
         * @param {string} timestamp Timestamp in miliseconds.
         * @param {string} longitude Longitude of the location.
         * @param {string} latitude Latitude of the location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimezoneByLocation(timestamp: string, longitude: string, latitude: string, options?: any): AxiosPromise<TimezoneResponse> {
            return localVarFp.getTimezoneByLocation(timestamp, longitude, latitude, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimeZoneServiceApi - object-oriented interface
 * @export
 * @class TimeZoneServiceApi
 * @extends {BaseAPI}
 */
export class TimeZoneServiceApi extends BaseAPI {
    /**
     * Identifies and retrieves the local time of any location in the world for a given latitude, longitude and time. The input and retrieved time format is in milliseconds.
     * @summary Timezone Batch by Location.
     * @param {TimezoneLocationRequest} timezoneLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeZoneServiceApi
     */
    public getBatchTimezoneByLocation(timezoneLocationRequest: TimezoneLocationRequest, options?: AxiosRequestConfig) {
        return TimeZoneServiceApiFp(this.oAuthCred,this.configuration).getBatchTimezoneByLocation(timezoneLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Identifies and retrieves the local time of any location in the world for a given address and time. The input and retrieved time format is in milliseconds.
     * @summary Timezone By Address.
     * @param {string} timestamp Timestamp in miliseconds.
     * @param {string} address The address to be searched.
     * @param {string} [matchMode] Match modes determine the leniency used to make a match between the input address and the reference data (Default is relaxed)
     * @param {string} [country] Country ISO code (Default is USA)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeZoneServiceApi
     */
    public getTimezoneByAddress(timestamp: string, address: string, matchMode?: string, country?: string, options?: AxiosRequestConfig) {
        return TimeZoneServiceApiFp(this.oAuthCred,this.configuration).getTimezoneByAddress(timestamp, address, matchMode, country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Identifies and retrieves the local time of any location in the world for a given address and time. The input and retrieved time format is in milliseconds.
     * @summary Timezone Batch by Address.
     * @param {TimezoneAddressRequest} timezoneAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeZoneServiceApi
     */
    public getTimezoneByAddressBatch(timezoneAddressRequest: TimezoneAddressRequest, options?: AxiosRequestConfig) {
        return TimeZoneServiceApiFp(this.oAuthCred,this.configuration).getTimezoneByAddressBatch(timezoneAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Identifies and retrieves the local time of any location in the world for a given latitude, longitude and time. The input and retrieved time format is in milliseconds.
     * @summary Timezone By Location.
     * @param {string} timestamp Timestamp in miliseconds.
     * @param {string} longitude Longitude of the location.
     * @param {string} latitude Latitude of the location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeZoneServiceApi
     */
    public getTimezoneByLocation(timestamp: string, longitude: string, latitude: string, options?: AxiosRequestConfig) {
        return TimeZoneServiceApiFp(this.oAuthCred,this.configuration).getTimezoneByLocation(timestamp, longitude, latitude, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ZonesServiceApi - axios parameter creator
 * @export
 */
export const ZonesServiceApiAxiosParamCreator = function (oAuth: oAuthCredInfo,configuration?: Configuration) {
    return {
        /**
         * Gets Basic Boundary by Address.
         * @summary Gets Basic Boundary by Address.
         * @param {string} address Address around which Basic Boundary is requested
         * @param {string} [country] Three digit ISO country code
         * @param {string} [distance] 
         * @param {string} [distanceUnit] 
         * @param {string} [resolution] This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4.
         * @param {string} [responseSrs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicBoundaryByAddress: async (address: string, country?: string, distance?: string, distanceUnit?: string, resolution?: string, responseSrs?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getBasicBoundaryByAddress', 'address', address)
            const localVarPath = `/zones/v1/basicboundary/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (distance !== undefined) {
                localVarQueryParameter['distance'] = distance;
            }

            if (distanceUnit !== undefined) {
                localVarQueryParameter['distanceUnit'] = distanceUnit;
            }

            if (resolution !== undefined) {
                localVarQueryParameter['resolution'] = resolution;
            }

            if (responseSrs !== undefined) {
                localVarQueryParameter['responseSrs'] = responseSrs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets Basic Boundary by Location.
         * @summary Gets Basic Boundary by Location.
         * @param {string} latitude Latitude around which Basic Boundary is requested
         * @param {string} longitude Longitude around which Basic Boundary is requested
         * @param {string} distance This is width of the buffer (in a complete circular buffer, it would be radius of the buffer). This has to be a positive number.
         * @param {string} [distanceUnit] 
         * @param {string} [resolution] This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4.
         * @param {string} [responseSrs] 
         * @param {string} [srsName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicBoundaryByLocation: async (latitude: string, longitude: string, distance: string, distanceUnit?: string, resolution?: string, responseSrs?: string, srsName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('getBasicBoundaryByLocation', 'latitude', latitude)
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('getBasicBoundaryByLocation', 'longitude', longitude)
            // verify required parameter 'distance' is not null or undefined
            assertParamExists('getBasicBoundaryByLocation', 'distance', distance)
            const localVarPath = `/zones/v1/basicboundary/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (distance !== undefined) {
                localVarQueryParameter['distance'] = distance;
            }

            if (distanceUnit !== undefined) {
                localVarQueryParameter['distanceUnit'] = distanceUnit;
            }

            if (resolution !== undefined) {
                localVarQueryParameter['resolution'] = resolution;
            }

            if (responseSrs !== undefined) {
                localVarQueryParameter['responseSrs'] = responseSrs;
            }

            if (srsName !== undefined) {
                localVarQueryParameter['srsName'] = srsName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets Point of Interests Boundary by Address.
         * @summary Gets Point of Interests Boundary by Address.
         * @param {string} address Address around which POI Boundary is requested
         * @param {string} [categoryCode] Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes.
         * @param {string} [sicCode] Specify starting digits or full sic code to filter the response
         * @param {string} [naicsCode] Will accept naicsCode to filter POIs in results. Max 10 allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIBoundaryByAddress: async (address: string, categoryCode?: string, sicCode?: string, naicsCode?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getPOIBoundaryByAddress', 'address', address)
            const localVarPath = `/zones/v1/poiboundary/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (categoryCode !== undefined) {
                localVarQueryParameter['categoryCode'] = categoryCode;
            }

            if (sicCode !== undefined) {
                localVarQueryParameter['sicCode'] = sicCode;
            }

            if (naicsCode !== undefined) {
                localVarQueryParameter['naicsCode'] = naicsCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Batch method for getting Point of Interests Boundary by Address.
         * @summary Batch method for getting Point of Interests Boundary by Address.
         * @param {POIBoundaryAddressRequest} pOIBoundaryAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIBoundaryByAddressBatch: async (pOIBoundaryAddressRequest: POIBoundaryAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pOIBoundaryAddressRequest' is not null or undefined
            assertParamExists('getPOIBoundaryByAddressBatch', 'pOIBoundaryAddressRequest', pOIBoundaryAddressRequest)
            const localVarPath = `/zones/v1/poiboundary/byaddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pOIBoundaryAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Point of Interests Boundary by Location.
         * @summary Get Point of Interests Boundary by Location.
         * @param {string} latitude Latitude around which POI Boundary is requested
         * @param {string} longitude Longitude around which POI Boundary is requested
         * @param {string} [categoryCode] Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes
         * @param {string} [sicCode] Specify starting digits or full sic code to filter the response
         * @param {string} [naicsCode] Will accept naicsCode to filter POIs in results. Max 10 allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIBoundaryByLocation: async (latitude: string, longitude: string, categoryCode?: string, sicCode?: string, naicsCode?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('getPOIBoundaryByLocation', 'latitude', latitude)
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('getPOIBoundaryByLocation', 'longitude', longitude)
            const localVarPath = `/zones/v1/poiboundary/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (categoryCode !== undefined) {
                localVarQueryParameter['categoryCode'] = categoryCode;
            }

            if (sicCode !== undefined) {
                localVarQueryParameter['sicCode'] = sicCode;
            }

            if (naicsCode !== undefined) {
                localVarQueryParameter['naicsCode'] = naicsCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Batch method for getting Point of Interests Boundary by Location.
         * @summary Batch method for getting Point of Interests Boundary by Location.
         * @param {POIBoundaryLocationRequest} pOIBoundaryLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIBoundaryByLocationBatch: async (pOIBoundaryLocationRequest: POIBoundaryLocationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pOIBoundaryLocationRequest' is not null or undefined
            assertParamExists('getPOIBoundaryByLocationBatch', 'pOIBoundaryLocationRequest', pOIBoundaryLocationRequest)
            const localVarPath = `/zones/v1/poiboundary/bylocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pOIBoundaryLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the travel boundary based on travel distance.
         * @summary Get TravelBoundary By Distance.
         * @param {string} [point] Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format
         * @param {string} [address] Address around which Basic Boundary is requested.
         * @param {string} [costs] Travel time used to calculate the travel boundary.
         * @param {string} [costUnit] Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
         * @param {string} [db] Mode of commute.
         * @param {string} [country] 3 character ISO code or country name.
         * @param {string} [maxOffroadDistance] Maximum distance to allow travel off the road network.
         * @param {string} [maxOffroadDistanceUnit] MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
         * @param {string} [destinationSrs] Desired coordinate system of the travel boundary.
         * @param {string} [majorRoads] Whether to include all roads in the calculation or just major roads.
         * @param {string} [returnHoles] Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time
         * @param {string} [returnIslands] Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time
         * @param {string} [simplificationFactor] Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex
         * @param {string} [bandingStyle] Style of banding to be used in the result
         * @param {string} [historicTrafficTimeBucket] Whether routing calculation uses the historic traffic speeds
         * @param {string} [defaultAmbientSpeed] The speed to travel when going off a network road to find the travel boundary (for all road types).
         * @param {string} [ambientSpeedUnit] The unit of measure to use to calculate the ambient speed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTravelBoundaryByDistance: async (point?: string, address?: string, costs?: string, costUnit?: string, db?: string, country?: string, maxOffroadDistance?: string, maxOffroadDistanceUnit?: string, destinationSrs?: string, majorRoads?: string, returnHoles?: string, returnIslands?: string, simplificationFactor?: string, bandingStyle?: string, historicTrafficTimeBucket?: string, defaultAmbientSpeed?: string, ambientSpeedUnit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/zones/v1/travelboundary/bydistance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (point !== undefined) {
                localVarQueryParameter['point'] = point;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (costs !== undefined) {
                localVarQueryParameter['costs'] = costs;
            }

            if (costUnit !== undefined) {
                localVarQueryParameter['costUnit'] = costUnit;
            }

            if (db !== undefined) {
                localVarQueryParameter['db'] = db;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (maxOffroadDistance !== undefined) {
                localVarQueryParameter['maxOffroadDistance'] = maxOffroadDistance;
            }

            if (maxOffroadDistanceUnit !== undefined) {
                localVarQueryParameter['maxOffroadDistanceUnit'] = maxOffroadDistanceUnit;
            }

            if (destinationSrs !== undefined) {
                localVarQueryParameter['destinationSrs'] = destinationSrs;
            }

            if (majorRoads !== undefined) {
                localVarQueryParameter['majorRoads'] = majorRoads;
            }

            if (returnHoles !== undefined) {
                localVarQueryParameter['returnHoles'] = returnHoles;
            }

            if (returnIslands !== undefined) {
                localVarQueryParameter['returnIslands'] = returnIslands;
            }

            if (simplificationFactor !== undefined) {
                localVarQueryParameter['simplificationFactor'] = simplificationFactor;
            }

            if (bandingStyle !== undefined) {
                localVarQueryParameter['bandingStyle'] = bandingStyle;
            }

            if (historicTrafficTimeBucket !== undefined) {
                localVarQueryParameter['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
            }

            if (defaultAmbientSpeed !== undefined) {
                localVarQueryParameter['defaultAmbientSpeed'] = defaultAmbientSpeed;
            }

            if (ambientSpeedUnit !== undefined) {
                localVarQueryParameter['ambientSpeedUnit'] = ambientSpeedUnit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Travel boundary based on travel time.
         * @summary Get TravelBoundary By Time.
         * @param {string} [point] Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format
         * @param {string} [address] Starting address from where the travel boundary is calculated.
         * @param {string} [costs] Travel time used to calculate the travel boundary.
         * @param {string} [costUnit] Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
         * @param {string} [db] Mode of commute.
         * @param {string} [country] 3 character ISO code or country name.
         * @param {string} [maxOffroadDistance] Maximum distance to allow travel off the road network.
         * @param {string} [maxOffroadDistanceUnit] MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
         * @param {string} [destinationSrs] Desired coordinate system of the travel boundary.
         * @param {string} [majorRoads] Whether to include all roads in the calculation or just major roads.
         * @param {string} [returnHoles] Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time
         * @param {string} [returnIslands] Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time
         * @param {string} [simplificationFactor] Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex
         * @param {string} [bandingStyle] Style of banding to be used in the result
         * @param {string} [historicTrafficTimeBucket] Whether routing calculation uses the historic traffic speeds
         * @param {string} [defaultAmbientSpeed] The speed to travel when going off a network road to find the travel boundary (for all road types).
         * @param {string} [ambientSpeedUnit] The unit of measure to use to calculate the ambient speed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTravelBoundaryByTime: async (point?: string, address?: string, costs?: string, costUnit?: string, db?: string, country?: string, maxOffroadDistance?: string, maxOffroadDistanceUnit?: string, destinationSrs?: string, majorRoads?: string, returnHoles?: string, returnIslands?: string, simplificationFactor?: string, bandingStyle?: string, historicTrafficTimeBucket?: string, defaultAmbientSpeed?: string, ambientSpeedUnit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/zones/v1/travelboundary/bytime`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

			 localVarHeaderParameter['Authorization'] = 'Bearer '+oAuth.access_token;
            if (point !== undefined) {
                localVarQueryParameter['point'] = point;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (costs !== undefined) {
                localVarQueryParameter['costs'] = costs;
            }

            if (costUnit !== undefined) {
                localVarQueryParameter['costUnit'] = costUnit;
            }

            if (db !== undefined) {
                localVarQueryParameter['db'] = db;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (maxOffroadDistance !== undefined) {
                localVarQueryParameter['maxOffroadDistance'] = maxOffroadDistance;
            }

            if (maxOffroadDistanceUnit !== undefined) {
                localVarQueryParameter['maxOffroadDistanceUnit'] = maxOffroadDistanceUnit;
            }

            if (destinationSrs !== undefined) {
                localVarQueryParameter['destinationSrs'] = destinationSrs;
            }

            if (majorRoads !== undefined) {
                localVarQueryParameter['majorRoads'] = majorRoads;
            }

            if (returnHoles !== undefined) {
                localVarQueryParameter['returnHoles'] = returnHoles;
            }

            if (returnIslands !== undefined) {
                localVarQueryParameter['returnIslands'] = returnIslands;
            }

            if (simplificationFactor !== undefined) {
                localVarQueryParameter['simplificationFactor'] = simplificationFactor;
            }

            if (bandingStyle !== undefined) {
                localVarQueryParameter['bandingStyle'] = bandingStyle;
            }

            if (historicTrafficTimeBucket !== undefined) {
                localVarQueryParameter['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
            }

            if (defaultAmbientSpeed !== undefined) {
                localVarQueryParameter['defaultAmbientSpeed'] = defaultAmbientSpeed;
            }

            if (ambientSpeedUnit !== undefined) {
                localVarQueryParameter['ambientSpeedUnit'] = ambientSpeedUnit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ZonesServiceApi - functional programming interface
 * @export
 */
export const ZonesServiceApiFp = function(oAuth: oAuthCredInfo,configuration?: Configuration,) {
    const localVarAxiosParamCreator = ZonesServiceApiAxiosParamCreator(oAuth,configuration)
    return {
        /**
         * Gets Basic Boundary by Address.
         * @summary Gets Basic Boundary by Address.
         * @param {string} address Address around which Basic Boundary is requested
         * @param {string} [country] Three digit ISO country code
         * @param {string} [distance] 
         * @param {string} [distanceUnit] 
         * @param {string} [resolution] This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4.
         * @param {string} [responseSrs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBasicBoundaryByAddress(address: string, country?: string, distance?: string, distanceUnit?: string, resolution?: string, responseSrs?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasicBoundary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBasicBoundaryByAddress(address, country, distance, distanceUnit, resolution, responseSrs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets Basic Boundary by Location.
         * @summary Gets Basic Boundary by Location.
         * @param {string} latitude Latitude around which Basic Boundary is requested
         * @param {string} longitude Longitude around which Basic Boundary is requested
         * @param {string} distance This is width of the buffer (in a complete circular buffer, it would be radius of the buffer). This has to be a positive number.
         * @param {string} [distanceUnit] 
         * @param {string} [resolution] This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4.
         * @param {string} [responseSrs] 
         * @param {string} [srsName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBasicBoundaryByLocation(latitude: string, longitude: string, distance: string, distanceUnit?: string, resolution?: string, responseSrs?: string, srsName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasicBoundary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBasicBoundaryByLocation(latitude, longitude, distance, distanceUnit, resolution, responseSrs, srsName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets Point of Interests Boundary by Address.
         * @summary Gets Point of Interests Boundary by Address.
         * @param {string} address Address around which POI Boundary is requested
         * @param {string} [categoryCode] Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes.
         * @param {string} [sicCode] Specify starting digits or full sic code to filter the response
         * @param {string} [naicsCode] Will accept naicsCode to filter POIs in results. Max 10 allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPOIBoundaryByAddress(address: string, categoryCode?: string, sicCode?: string, naicsCode?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoiBoundary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPOIBoundaryByAddress(address, categoryCode, sicCode, naicsCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Batch method for getting Point of Interests Boundary by Address.
         * @summary Batch method for getting Point of Interests Boundary by Address.
         * @param {POIBoundaryAddressRequest} pOIBoundaryAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPOIBoundaryByAddressBatch(pOIBoundaryAddressRequest: POIBoundaryAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<POIBoundaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPOIBoundaryByAddressBatch(pOIBoundaryAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Point of Interests Boundary by Location.
         * @summary Get Point of Interests Boundary by Location.
         * @param {string} latitude Latitude around which POI Boundary is requested
         * @param {string} longitude Longitude around which POI Boundary is requested
         * @param {string} [categoryCode] Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes
         * @param {string} [sicCode] Specify starting digits or full sic code to filter the response
         * @param {string} [naicsCode] Will accept naicsCode to filter POIs in results. Max 10 allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPOIBoundaryByLocation(latitude: string, longitude: string, categoryCode?: string, sicCode?: string, naicsCode?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoiBoundary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPOIBoundaryByLocation(latitude, longitude, categoryCode, sicCode, naicsCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Batch method for getting Point of Interests Boundary by Location.
         * @summary Batch method for getting Point of Interests Boundary by Location.
         * @param {POIBoundaryLocationRequest} pOIBoundaryLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPOIBoundaryByLocationBatch(pOIBoundaryLocationRequest: POIBoundaryLocationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<POIBoundaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPOIBoundaryByLocationBatch(pOIBoundaryLocationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the travel boundary based on travel distance.
         * @summary Get TravelBoundary By Distance.
         * @param {string} [point] Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format
         * @param {string} [address] Address around which Basic Boundary is requested.
         * @param {string} [costs] Travel time used to calculate the travel boundary.
         * @param {string} [costUnit] Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
         * @param {string} [db] Mode of commute.
         * @param {string} [country] 3 character ISO code or country name.
         * @param {string} [maxOffroadDistance] Maximum distance to allow travel off the road network.
         * @param {string} [maxOffroadDistanceUnit] MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
         * @param {string} [destinationSrs] Desired coordinate system of the travel boundary.
         * @param {string} [majorRoads] Whether to include all roads in the calculation or just major roads.
         * @param {string} [returnHoles] Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time
         * @param {string} [returnIslands] Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time
         * @param {string} [simplificationFactor] Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex
         * @param {string} [bandingStyle] Style of banding to be used in the result
         * @param {string} [historicTrafficTimeBucket] Whether routing calculation uses the historic traffic speeds
         * @param {string} [defaultAmbientSpeed] The speed to travel when going off a network road to find the travel boundary (for all road types).
         * @param {string} [ambientSpeedUnit] The unit of measure to use to calculate the ambient speed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTravelBoundaryByDistance(point?: string, address?: string, costs?: string, costUnit?: string, db?: string, country?: string, maxOffroadDistance?: string, maxOffroadDistanceUnit?: string, destinationSrs?: string, majorRoads?: string, returnHoles?: string, returnIslands?: string, simplificationFactor?: string, bandingStyle?: string, historicTrafficTimeBucket?: string, defaultAmbientSpeed?: string, ambientSpeedUnit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TravelBoundaries>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTravelBoundaryByDistance(point, address, costs, costUnit, db, country, maxOffroadDistance, maxOffroadDistanceUnit, destinationSrs, majorRoads, returnHoles, returnIslands, simplificationFactor, bandingStyle, historicTrafficTimeBucket, defaultAmbientSpeed, ambientSpeedUnit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Travel boundary based on travel time.
         * @summary Get TravelBoundary By Time.
         * @param {string} [point] Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format
         * @param {string} [address] Starting address from where the travel boundary is calculated.
         * @param {string} [costs] Travel time used to calculate the travel boundary.
         * @param {string} [costUnit] Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
         * @param {string} [db] Mode of commute.
         * @param {string} [country] 3 character ISO code or country name.
         * @param {string} [maxOffroadDistance] Maximum distance to allow travel off the road network.
         * @param {string} [maxOffroadDistanceUnit] MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
         * @param {string} [destinationSrs] Desired coordinate system of the travel boundary.
         * @param {string} [majorRoads] Whether to include all roads in the calculation or just major roads.
         * @param {string} [returnHoles] Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time
         * @param {string} [returnIslands] Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time
         * @param {string} [simplificationFactor] Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex
         * @param {string} [bandingStyle] Style of banding to be used in the result
         * @param {string} [historicTrafficTimeBucket] Whether routing calculation uses the historic traffic speeds
         * @param {string} [defaultAmbientSpeed] The speed to travel when going off a network road to find the travel boundary (for all road types).
         * @param {string} [ambientSpeedUnit] The unit of measure to use to calculate the ambient speed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTravelBoundaryByTime(point?: string, address?: string, costs?: string, costUnit?: string, db?: string, country?: string, maxOffroadDistance?: string, maxOffroadDistanceUnit?: string, destinationSrs?: string, majorRoads?: string, returnHoles?: string, returnIslands?: string, simplificationFactor?: string, bandingStyle?: string, historicTrafficTimeBucket?: string, defaultAmbientSpeed?: string, ambientSpeedUnit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TravelBoundaries>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTravelBoundaryByTime(point, address, costs, costUnit, db, country, maxOffroadDistance, maxOffroadDistanceUnit, destinationSrs, majorRoads, returnHoles, returnIslands, simplificationFactor, bandingStyle, historicTrafficTimeBucket, defaultAmbientSpeed, ambientSpeedUnit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ZonesServiceApi - factory interface
 * @export
 */
export const ZonesServiceApiFactory = function (oAuth: oAuthCredInfo,configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ZonesServiceApiFp(oAuth,configuration)
    return {
        /**
         * Gets Basic Boundary by Address.
         * @summary Gets Basic Boundary by Address.
         * @param {string} address Address around which Basic Boundary is requested
         * @param {string} [country] Three digit ISO country code
         * @param {string} [distance] 
         * @param {string} [distanceUnit] 
         * @param {string} [resolution] This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4.
         * @param {string} [responseSrs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicBoundaryByAddress(address: string, country?: string, distance?: string, distanceUnit?: string, resolution?: string, responseSrs?: string, options?: any): AxiosPromise<BasicBoundary> {
            return localVarFp.getBasicBoundaryByAddress(address, country, distance, distanceUnit, resolution, responseSrs, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets Basic Boundary by Location.
         * @summary Gets Basic Boundary by Location.
         * @param {string} latitude Latitude around which Basic Boundary is requested
         * @param {string} longitude Longitude around which Basic Boundary is requested
         * @param {string} distance This is width of the buffer (in a complete circular buffer, it would be radius of the buffer). This has to be a positive number.
         * @param {string} [distanceUnit] 
         * @param {string} [resolution] This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4.
         * @param {string} [responseSrs] 
         * @param {string} [srsName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicBoundaryByLocation(latitude: string, longitude: string, distance: string, distanceUnit?: string, resolution?: string, responseSrs?: string, srsName?: string, options?: any): AxiosPromise<BasicBoundary> {
            return localVarFp.getBasicBoundaryByLocation(latitude, longitude, distance, distanceUnit, resolution, responseSrs, srsName, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets Point of Interests Boundary by Address.
         * @summary Gets Point of Interests Boundary by Address.
         * @param {string} address Address around which POI Boundary is requested
         * @param {string} [categoryCode] Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes.
         * @param {string} [sicCode] Specify starting digits or full sic code to filter the response
         * @param {string} [naicsCode] Will accept naicsCode to filter POIs in results. Max 10 allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIBoundaryByAddress(address: string, categoryCode?: string, sicCode?: string, naicsCode?: string, options?: any): AxiosPromise<PoiBoundary> {
            return localVarFp.getPOIBoundaryByAddress(address, categoryCode, sicCode, naicsCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Batch method for getting Point of Interests Boundary by Address.
         * @summary Batch method for getting Point of Interests Boundary by Address.
         * @param {POIBoundaryAddressRequest} pOIBoundaryAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIBoundaryByAddressBatch(pOIBoundaryAddressRequest: POIBoundaryAddressRequest, options?: any): AxiosPromise<POIBoundaryResponse> {
            return localVarFp.getPOIBoundaryByAddressBatch(pOIBoundaryAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Point of Interests Boundary by Location.
         * @summary Get Point of Interests Boundary by Location.
         * @param {string} latitude Latitude around which POI Boundary is requested
         * @param {string} longitude Longitude around which POI Boundary is requested
         * @param {string} [categoryCode] Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes
         * @param {string} [sicCode] Specify starting digits or full sic code to filter the response
         * @param {string} [naicsCode] Will accept naicsCode to filter POIs in results. Max 10 allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIBoundaryByLocation(latitude: string, longitude: string, categoryCode?: string, sicCode?: string, naicsCode?: string, options?: any): AxiosPromise<PoiBoundary> {
            return localVarFp.getPOIBoundaryByLocation(latitude, longitude, categoryCode, sicCode, naicsCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Batch method for getting Point of Interests Boundary by Location.
         * @summary Batch method for getting Point of Interests Boundary by Location.
         * @param {POIBoundaryLocationRequest} pOIBoundaryLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOIBoundaryByLocationBatch(pOIBoundaryLocationRequest: POIBoundaryLocationRequest, options?: any): AxiosPromise<POIBoundaryResponse> {
            return localVarFp.getPOIBoundaryByLocationBatch(pOIBoundaryLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the travel boundary based on travel distance.
         * @summary Get TravelBoundary By Distance.
         * @param {string} [point] Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format
         * @param {string} [address] Address around which Basic Boundary is requested.
         * @param {string} [costs] Travel time used to calculate the travel boundary.
         * @param {string} [costUnit] Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
         * @param {string} [db] Mode of commute.
         * @param {string} [country] 3 character ISO code or country name.
         * @param {string} [maxOffroadDistance] Maximum distance to allow travel off the road network.
         * @param {string} [maxOffroadDistanceUnit] MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
         * @param {string} [destinationSrs] Desired coordinate system of the travel boundary.
         * @param {string} [majorRoads] Whether to include all roads in the calculation or just major roads.
         * @param {string} [returnHoles] Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time
         * @param {string} [returnIslands] Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time
         * @param {string} [simplificationFactor] Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex
         * @param {string} [bandingStyle] Style of banding to be used in the result
         * @param {string} [historicTrafficTimeBucket] Whether routing calculation uses the historic traffic speeds
         * @param {string} [defaultAmbientSpeed] The speed to travel when going off a network road to find the travel boundary (for all road types).
         * @param {string} [ambientSpeedUnit] The unit of measure to use to calculate the ambient speed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTravelBoundaryByDistance(point?: string, address?: string, costs?: string, costUnit?: string, db?: string, country?: string, maxOffroadDistance?: string, maxOffroadDistanceUnit?: string, destinationSrs?: string, majorRoads?: string, returnHoles?: string, returnIslands?: string, simplificationFactor?: string, bandingStyle?: string, historicTrafficTimeBucket?: string, defaultAmbientSpeed?: string, ambientSpeedUnit?: string, options?: any): AxiosPromise<TravelBoundaries> {
            return localVarFp.getTravelBoundaryByDistance(point, address, costs, costUnit, db, country, maxOffroadDistance, maxOffroadDistanceUnit, destinationSrs, majorRoads, returnHoles, returnIslands, simplificationFactor, bandingStyle, historicTrafficTimeBucket, defaultAmbientSpeed, ambientSpeedUnit, options).then((request) => request(axios, basePath));
        },
        /**
         * Travel boundary based on travel time.
         * @summary Get TravelBoundary By Time.
         * @param {string} [point] Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format
         * @param {string} [address] Starting address from where the travel boundary is calculated.
         * @param {string} [costs] Travel time used to calculate the travel boundary.
         * @param {string} [costUnit] Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
         * @param {string} [db] Mode of commute.
         * @param {string} [country] 3 character ISO code or country name.
         * @param {string} [maxOffroadDistance] Maximum distance to allow travel off the road network.
         * @param {string} [maxOffroadDistanceUnit] MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
         * @param {string} [destinationSrs] Desired coordinate system of the travel boundary.
         * @param {string} [majorRoads] Whether to include all roads in the calculation or just major roads.
         * @param {string} [returnHoles] Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time
         * @param {string} [returnIslands] Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time
         * @param {string} [simplificationFactor] Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex
         * @param {string} [bandingStyle] Style of banding to be used in the result
         * @param {string} [historicTrafficTimeBucket] Whether routing calculation uses the historic traffic speeds
         * @param {string} [defaultAmbientSpeed] The speed to travel when going off a network road to find the travel boundary (for all road types).
         * @param {string} [ambientSpeedUnit] The unit of measure to use to calculate the ambient speed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTravelBoundaryByTime(point?: string, address?: string, costs?: string, costUnit?: string, db?: string, country?: string, maxOffroadDistance?: string, maxOffroadDistanceUnit?: string, destinationSrs?: string, majorRoads?: string, returnHoles?: string, returnIslands?: string, simplificationFactor?: string, bandingStyle?: string, historicTrafficTimeBucket?: string, defaultAmbientSpeed?: string, ambientSpeedUnit?: string, options?: any): AxiosPromise<TravelBoundaries> {
            return localVarFp.getTravelBoundaryByTime(point, address, costs, costUnit, db, country, maxOffroadDistance, maxOffroadDistanceUnit, destinationSrs, majorRoads, returnHoles, returnIslands, simplificationFactor, bandingStyle, historicTrafficTimeBucket, defaultAmbientSpeed, ambientSpeedUnit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ZonesServiceApi - object-oriented interface
 * @export
 * @class ZonesServiceApi
 * @extends {BaseAPI}
 */
export class ZonesServiceApi extends BaseAPI {
    /**
     * Gets Basic Boundary by Address.
     * @summary Gets Basic Boundary by Address.
     * @param {string} address Address around which Basic Boundary is requested
     * @param {string} [country] Three digit ISO country code
     * @param {string} [distance] 
     * @param {string} [distanceUnit] 
     * @param {string} [resolution] This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4.
     * @param {string} [responseSrs] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZonesServiceApi
     */
    public getBasicBoundaryByAddress(address: string, country?: string, distance?: string, distanceUnit?: string, resolution?: string, responseSrs?: string, options?: AxiosRequestConfig) {
        return ZonesServiceApiFp(this.oAuthCred,this.configuration).getBasicBoundaryByAddress(address, country, distance, distanceUnit, resolution, responseSrs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets Basic Boundary by Location.
     * @summary Gets Basic Boundary by Location.
     * @param {string} latitude Latitude around which Basic Boundary is requested
     * @param {string} longitude Longitude around which Basic Boundary is requested
     * @param {string} distance This is width of the buffer (in a complete circular buffer, it would be radius of the buffer). This has to be a positive number.
     * @param {string} [distanceUnit] 
     * @param {string} [resolution] This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4.
     * @param {string} [responseSrs] 
     * @param {string} [srsName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZonesServiceApi
     */
    public getBasicBoundaryByLocation(latitude: string, longitude: string, distance: string, distanceUnit?: string, resolution?: string, responseSrs?: string, srsName?: string, options?: AxiosRequestConfig) {
        return ZonesServiceApiFp(this.oAuthCred,this.configuration).getBasicBoundaryByLocation(latitude, longitude, distance, distanceUnit, resolution, responseSrs, srsName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets Point of Interests Boundary by Address.
     * @summary Gets Point of Interests Boundary by Address.
     * @param {string} address Address around which POI Boundary is requested
     * @param {string} [categoryCode] Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes.
     * @param {string} [sicCode] Specify starting digits or full sic code to filter the response
     * @param {string} [naicsCode] Will accept naicsCode to filter POIs in results. Max 10 allowed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZonesServiceApi
     */
    public getPOIBoundaryByAddress(address: string, categoryCode?: string, sicCode?: string, naicsCode?: string, options?: AxiosRequestConfig) {
        return ZonesServiceApiFp(this.oAuthCred,this.configuration).getPOIBoundaryByAddress(address, categoryCode, sicCode, naicsCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Batch method for getting Point of Interests Boundary by Address.
     * @summary Batch method for getting Point of Interests Boundary by Address.
     * @param {POIBoundaryAddressRequest} pOIBoundaryAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZonesServiceApi
     */
    public getPOIBoundaryByAddressBatch(pOIBoundaryAddressRequest: POIBoundaryAddressRequest, options?: AxiosRequestConfig) {
        return ZonesServiceApiFp(this.oAuthCred,this.configuration).getPOIBoundaryByAddressBatch(pOIBoundaryAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Point of Interests Boundary by Location.
     * @summary Get Point of Interests Boundary by Location.
     * @param {string} latitude Latitude around which POI Boundary is requested
     * @param {string} longitude Longitude around which POI Boundary is requested
     * @param {string} [categoryCode] Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes
     * @param {string} [sicCode] Specify starting digits or full sic code to filter the response
     * @param {string} [naicsCode] Will accept naicsCode to filter POIs in results. Max 10 allowed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZonesServiceApi
     */
    public getPOIBoundaryByLocation(latitude: string, longitude: string, categoryCode?: string, sicCode?: string, naicsCode?: string, options?: AxiosRequestConfig) {
        return ZonesServiceApiFp(this.oAuthCred,this.configuration).getPOIBoundaryByLocation(latitude, longitude, categoryCode, sicCode, naicsCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Batch method for getting Point of Interests Boundary by Location.
     * @summary Batch method for getting Point of Interests Boundary by Location.
     * @param {POIBoundaryLocationRequest} pOIBoundaryLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZonesServiceApi
     */
    public getPOIBoundaryByLocationBatch(pOIBoundaryLocationRequest: POIBoundaryLocationRequest, options?: AxiosRequestConfig) {
        return ZonesServiceApiFp(this.oAuthCred,this.configuration).getPOIBoundaryByLocationBatch(pOIBoundaryLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the travel boundary based on travel distance.
     * @summary Get TravelBoundary By Distance.
     * @param {string} [point] Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format
     * @param {string} [address] Address around which Basic Boundary is requested.
     * @param {string} [costs] Travel time used to calculate the travel boundary.
     * @param {string} [costUnit] Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
     * @param {string} [db] Mode of commute.
     * @param {string} [country] 3 character ISO code or country name.
     * @param {string} [maxOffroadDistance] Maximum distance to allow travel off the road network.
     * @param {string} [maxOffroadDistanceUnit] MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param {string} [destinationSrs] Desired coordinate system of the travel boundary.
     * @param {string} [majorRoads] Whether to include all roads in the calculation or just major roads.
     * @param {string} [returnHoles] Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time
     * @param {string} [returnIslands] Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time
     * @param {string} [simplificationFactor] Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex
     * @param {string} [bandingStyle] Style of banding to be used in the result
     * @param {string} [historicTrafficTimeBucket] Whether routing calculation uses the historic traffic speeds
     * @param {string} [defaultAmbientSpeed] The speed to travel when going off a network road to find the travel boundary (for all road types).
     * @param {string} [ambientSpeedUnit] The unit of measure to use to calculate the ambient speed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZonesServiceApi
     */
    public getTravelBoundaryByDistance(point?: string, address?: string, costs?: string, costUnit?: string, db?: string, country?: string, maxOffroadDistance?: string, maxOffroadDistanceUnit?: string, destinationSrs?: string, majorRoads?: string, returnHoles?: string, returnIslands?: string, simplificationFactor?: string, bandingStyle?: string, historicTrafficTimeBucket?: string, defaultAmbientSpeed?: string, ambientSpeedUnit?: string, options?: AxiosRequestConfig) {
        return ZonesServiceApiFp(this.oAuthCred,this.configuration).getTravelBoundaryByDistance(point, address, costs, costUnit, db, country, maxOffroadDistance, maxOffroadDistanceUnit, destinationSrs, majorRoads, returnHoles, returnIslands, simplificationFactor, bandingStyle, historicTrafficTimeBucket, defaultAmbientSpeed, ambientSpeedUnit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Travel boundary based on travel time.
     * @summary Get TravelBoundary By Time.
     * @param {string} [point] Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format
     * @param {string} [address] Starting address from where the travel boundary is calculated.
     * @param {string} [costs] Travel time used to calculate the travel boundary.
     * @param {string} [costUnit] Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
     * @param {string} [db] Mode of commute.
     * @param {string} [country] 3 character ISO code or country name.
     * @param {string} [maxOffroadDistance] Maximum distance to allow travel off the road network.
     * @param {string} [maxOffroadDistanceUnit] MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param {string} [destinationSrs] Desired coordinate system of the travel boundary.
     * @param {string} [majorRoads] Whether to include all roads in the calculation or just major roads.
     * @param {string} [returnHoles] Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time
     * @param {string} [returnIslands] Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time
     * @param {string} [simplificationFactor] Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex
     * @param {string} [bandingStyle] Style of banding to be used in the result
     * @param {string} [historicTrafficTimeBucket] Whether routing calculation uses the historic traffic speeds
     * @param {string} [defaultAmbientSpeed] The speed to travel when going off a network road to find the travel boundary (for all road types).
     * @param {string} [ambientSpeedUnit] The unit of measure to use to calculate the ambient speed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZonesServiceApi
     */
    public getTravelBoundaryByTime(point?: string, address?: string, costs?: string, costUnit?: string, db?: string, country?: string, maxOffroadDistance?: string, maxOffroadDistanceUnit?: string, destinationSrs?: string, majorRoads?: string, returnHoles?: string, returnIslands?: string, simplificationFactor?: string, bandingStyle?: string, historicTrafficTimeBucket?: string, defaultAmbientSpeed?: string, ambientSpeedUnit?: string, options?: AxiosRequestConfig) {
        return ZonesServiceApiFp(this.oAuthCred,this.configuration).getTravelBoundaryByTime(point, address, costs, costUnit, db, country, maxOffroadDistance, maxOffroadDistanceUnit, destinationSrs, majorRoads, returnHoles, returnIslands, simplificationFactor, bandingStyle, historicTrafficTimeBucket, defaultAmbientSpeed, ambientSpeedUnit, options).then((request) => request(this.axios, this.basePath));
    }
}


